{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/esnext.set.difference.v2.js\";\nimport \"core-js/modules/esnext.set.intersection.v2.js\";\nimport \"core-js/modules/esnext.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/esnext.set.is-subset-of.v2.js\";\nimport \"core-js/modules/esnext.set.is-superset-of.v2.js\";\nimport \"core-js/modules/esnext.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/esnext.set.union.v2.js\";\nimport { ref, shallowRef, watch, computed, nextTick } from 'vue';\nimport { TreeOptionsEnum, NODE_CLICK, CURRENT_CHANGE, NODE_EXPAND, NODE_COLLAPSE } from '../virtual-tree.mjs';\nimport { useCheck } from './useCheck.mjs';\nimport { useFilter } from './useFilter.mjs';\nfunction useTree(props, emit) {\n  const expandedKeySet = ref(new Set(props.defaultExpandedKeys));\n  const currentKey = ref();\n  const tree = shallowRef();\n  watch(() => props.currentNodeKey, key => {\n    currentKey.value = key;\n  }, {\n    immediate: true\n  });\n  watch(() => props.data, data => {\n    setData(data);\n  }, {\n    immediate: true\n  });\n  const {\n    isIndeterminate,\n    isChecked,\n    toggleCheckbox,\n    getCheckedKeys,\n    getCheckedNodes,\n    getHalfCheckedKeys,\n    getHalfCheckedNodes,\n    setChecked,\n    setCheckedKeys\n  } = useCheck(props, tree);\n  const {\n    doFilter,\n    hiddenNodeKeySet,\n    isForceHiddenExpandIcon\n  } = useFilter(props, tree);\n  const valueKey = computed(() => {\n    var _a;\n    return ((_a = props.props) == null ? void 0 : _a.value) || TreeOptionsEnum.KEY;\n  });\n  const childrenKey = computed(() => {\n    var _a;\n    return ((_a = props.props) == null ? void 0 : _a.children) || TreeOptionsEnum.CHILDREN;\n  });\n  const disabledKey = computed(() => {\n    var _a;\n    return ((_a = props.props) == null ? void 0 : _a.disabled) || TreeOptionsEnum.DISABLED;\n  });\n  const labelKey = computed(() => {\n    var _a;\n    return ((_a = props.props) == null ? void 0 : _a.label) || TreeOptionsEnum.LABEL;\n  });\n  const flattenTree = computed(() => {\n    const expandedKeys = expandedKeySet.value;\n    const hiddenKeys = hiddenNodeKeySet.value;\n    const flattenNodes = [];\n    const nodes = tree.value && tree.value.treeNodes || [];\n    function traverse() {\n      const stack = [];\n      for (let i = nodes.length - 1; i >= 0; --i) {\n        stack.push(nodes[i]);\n      }\n      while (stack.length) {\n        const node = stack.pop();\n        if (!node) continue;\n        if (!hiddenKeys.has(node.key)) {\n          flattenNodes.push(node);\n        }\n        if (expandedKeys.has(node.key)) {\n          const children = node.children;\n          if (children) {\n            const length = children.length;\n            for (let i = length - 1; i >= 0; --i) {\n              stack.push(children[i]);\n            }\n          }\n        }\n      }\n    }\n    traverse();\n    return flattenNodes;\n  });\n  const isNotEmpty = computed(() => {\n    return flattenTree.value.length > 0;\n  });\n  function createTree(data) {\n    const treeNodeMap = /* @__PURE__ */new Map();\n    const levelTreeNodeMap = /* @__PURE__ */new Map();\n    let maxLevel = 1;\n    function traverse(nodes, level = 1, parent = void 0) {\n      var _a;\n      const siblings = [];\n      for (let index = 0; index < nodes.length; ++index) {\n        const rawNode = nodes[index];\n        const value = getKey(rawNode);\n        const node = {\n          level,\n          key: value,\n          data: rawNode\n        };\n        node.label = getLabel(rawNode);\n        node.parent = parent;\n        const children = getChildren(rawNode);\n        node.disabled = getDisabled(rawNode);\n        node.isLeaf = !children || children.length === 0;\n        if (children && children.length) {\n          node.children = traverse(children, level + 1, node);\n        }\n        siblings.push(node);\n        treeNodeMap.set(value, node);\n        if (!levelTreeNodeMap.has(level)) {\n          levelTreeNodeMap.set(level, []);\n        }\n        (_a = levelTreeNodeMap.get(level)) == null ? void 0 : _a.push(node);\n      }\n      if (level > maxLevel) {\n        maxLevel = level;\n      }\n      return siblings;\n    }\n    const treeNodes = traverse(data);\n    return {\n      treeNodeMap,\n      levelTreeNodeMap,\n      maxLevel,\n      treeNodes\n    };\n  }\n  function filter(query) {\n    const keys = doFilter(query);\n    if (keys) {\n      expandedKeySet.value = keys;\n    }\n  }\n  function getChildren(node) {\n    return node[childrenKey.value];\n  }\n  function getKey(node) {\n    if (!node) {\n      return \"\";\n    }\n    return node[valueKey.value];\n  }\n  function getDisabled(node) {\n    return node[disabledKey.value];\n  }\n  function getLabel(node) {\n    return node[labelKey.value];\n  }\n  function toggleExpand(node) {\n    const expandedKeys = expandedKeySet.value;\n    if (expandedKeys.has(node.key)) {\n      collapse(node);\n    } else {\n      expand(node);\n    }\n  }\n  function handleNodeClick(node) {\n    emit(NODE_CLICK, node.data, node);\n    handleCurrentChange(node);\n    if (props.expandOnClickNode) {\n      toggleExpand(node);\n    }\n    if (props.showCheckbox && props.checkOnClickNode && !node.disabled) {\n      toggleCheckbox(node, !isChecked(node), true);\n    }\n  }\n  function handleCurrentChange(node) {\n    if (!isCurrent(node)) {\n      currentKey.value = node.key;\n      emit(CURRENT_CHANGE, node.data, node);\n    }\n  }\n  function handleNodeCheck(node, checked) {\n    toggleCheckbox(node, checked);\n  }\n  function expand(node) {\n    const keySet = expandedKeySet.value;\n    if ((tree == null ? void 0 : tree.value) && props.accordion) {\n      const {\n        treeNodeMap\n      } = tree.value;\n      keySet.forEach(key => {\n        const node2 = treeNodeMap.get(key);\n        if (node2 && node2.level === node2.level) {\n          keySet.delete(key);\n        }\n      });\n    }\n    keySet.add(node.key);\n    emit(NODE_EXPAND, node.data, node);\n  }\n  function collapse(node) {\n    expandedKeySet.value.delete(node.key);\n    emit(NODE_COLLAPSE, node.data, node);\n  }\n  function isExpanded(node) {\n    return expandedKeySet.value.has(node.key);\n  }\n  function isDisabled(node) {\n    return !!node.disabled;\n  }\n  function isCurrent(node) {\n    const current = currentKey.value;\n    return !!current && current === node.key;\n  }\n  function getCurrentNode() {\n    var _a, _b;\n    if (!currentKey.value) return void 0;\n    return (_b = (_a = tree == null ? void 0 : tree.value) == null ? void 0 : _a.treeNodeMap.get(currentKey.value)) == null ? void 0 : _b.data;\n  }\n  function getCurrentKey() {\n    return currentKey.value;\n  }\n  function setCurrentKey(key) {\n    currentKey.value = key;\n  }\n  function setData(data) {\n    nextTick(() => tree.value = createTree(data));\n  }\n  return {\n    tree,\n    flattenTree,\n    isNotEmpty,\n    getKey,\n    getChildren,\n    toggleExpand,\n    toggleCheckbox,\n    isExpanded,\n    isChecked,\n    isIndeterminate,\n    isDisabled,\n    isCurrent,\n    isForceHiddenExpandIcon,\n    handleNodeClick,\n    handleNodeCheck,\n    getCurrentNode,\n    getCurrentKey,\n    setCurrentKey,\n    getCheckedKeys,\n    getCheckedNodes,\n    getHalfCheckedKeys,\n    getHalfCheckedNodes,\n    setChecked,\n    setCheckedKeys,\n    filter,\n    setData\n  };\n}\nexport { useTree };","map":{"version":3,"names":["props","emit","expandedKeySet","ref","Set","defaultExpandedKeys","currentKey","tree","shallowRef","watch","currentNodeKey","key","value","immediate","data","setData","isIndeterminate","isChecked","toggleCheckbox","getCheckedKeys","getCheckedNodes","getHalfCheckedKeys","getHalfCheckedNodes","setChecked","setCheckedKeys","useCheck","doFilter","hiddenNodeKeySet","isForceHiddenExpandIcon","useFilter","valueKey","computed","_a","TreeOptionsEnum","KEY","childrenKey","children","CHILDREN","disabledKey","disabled","DISABLED","labelKey","label","LABEL","flattenTree","expandedKeys","hiddenKeys","flattenNodes","nodes","treeNodes","traverse","stack","i","length","push","node","pop","has","isNotEmpty","createTree","treeNodeMap","Map","levelTreeNodeMap","maxLevel","level","parent","siblings","index","rawNode","getKey","getLabel","getChildren","getDisabled","isLeaf","set","get","filter","query","keys","toggleExpand","collapse","expand","handleNodeClick","NODE_CLICK","handleCurrentChange","expandOnClickNode","showCheckbox","checkOnClickNode","isCurrent","CURRENT_CHANGE","handleNodeCheck","checked","keySet","accordion","forEach","node2","delete","add","NODE_EXPAND","NODE_COLLAPSE","isExpanded","isDisabled","current","getCurrentNode","_b","getCurrentKey","setCurrentKey","nextTick"],"sources":["../../../../../../../packages/components/tree-v2/src/composables/useTree.ts"],"sourcesContent":["import { computed, nextTick, ref, shallowRef, watch } from 'vue'\nimport {\n  NODE_CLICK,\n  NODE_COLLAPSE,\n  NODE_EXPAND,\n  CURRENT_CHANGE,\n  TreeOptionsEnum,\n} from '../virtual-tree'\nimport { useCheck } from './useCheck'\nimport { useFilter } from './useFilter'\nimport type {\n  TreeProps,\n  TreeNodeData,\n  TreeKey,\n  TreeNode,\n  TreeData,\n  Tree,\n} from '../types'\n\nexport function useTree(props: TreeProps, emit) {\n  const expandedKeySet = ref<Set<TreeKey>>(new Set(props.defaultExpandedKeys))\n  const currentKey = ref<TreeKey | undefined>()\n  const tree = shallowRef<Tree | undefined>()\n\n  watch(\n    () => props.currentNodeKey,\n    (key) => {\n      currentKey.value = key\n    },\n    {\n      immediate: true,\n    }\n  )\n\n  watch(\n    () => props.data,\n    (data: TreeData) => {\n      setData(data)\n    },\n    {\n      immediate: true,\n    }\n  )\n\n  const {\n    isIndeterminate,\n    isChecked,\n    toggleCheckbox,\n    getCheckedKeys,\n    getCheckedNodes,\n    getHalfCheckedKeys,\n    getHalfCheckedNodes,\n    setChecked,\n    setCheckedKeys,\n  } = useCheck(props, tree)\n\n  const { doFilter, hiddenNodeKeySet, isForceHiddenExpandIcon } = useFilter(\n    props,\n    tree\n  )\n\n  const valueKey = computed(() => {\n    return props.props?.value || TreeOptionsEnum.KEY\n  })\n  const childrenKey = computed(() => {\n    return props.props?.children || TreeOptionsEnum.CHILDREN\n  })\n  const disabledKey = computed(() => {\n    return props.props?.disabled || TreeOptionsEnum.DISABLED\n  })\n  const labelKey = computed(() => {\n    return props.props?.label || TreeOptionsEnum.LABEL\n  })\n\n  const flattenTree = computed(() => {\n    const expandedKeys = expandedKeySet.value\n    const hiddenKeys = hiddenNodeKeySet.value\n    const flattenNodes: TreeNode[] = []\n    const nodes = (tree.value && tree.value.treeNodes) || []\n    function traverse() {\n      const stack: TreeNode[] = []\n      for (let i = nodes.length - 1; i >= 0; --i) {\n        stack.push(nodes[i])\n      }\n      while (stack.length) {\n        const node = stack.pop()\n        if (!node) continue\n        if (!hiddenKeys.has(node.key)) {\n          flattenNodes.push(node)\n        }\n        // Only \"visible\" nodes will be rendered\n        if (expandedKeys.has(node.key)) {\n          const children = node.children\n          if (children) {\n            const length = children.length\n            for (let i = length - 1; i >= 0; --i) {\n              stack.push(children[i])\n            }\n          }\n        }\n      }\n    }\n    traverse()\n    return flattenNodes\n  })\n\n  const isNotEmpty = computed(() => {\n    return flattenTree.value.length > 0\n  })\n\n  function createTree(data: TreeData): Tree {\n    const treeNodeMap: Map<TreeKey, TreeNode> = new Map()\n    const levelTreeNodeMap: Map<number, TreeNode[]> = new Map()\n    let maxLevel = 1\n    function traverse(\n      nodes: TreeData,\n      level = 1,\n      parent: TreeNode | undefined = undefined\n    ) {\n      const siblings: TreeNode[] = []\n      for (let index = 0; index < nodes.length; ++index) {\n        const rawNode = nodes[index]\n        const value = getKey(rawNode)\n        const node: TreeNode = {\n          level,\n          key: value,\n          data: rawNode,\n        }\n        node.label = getLabel(rawNode)\n        node.parent = parent\n        const children = getChildren(rawNode)\n        node.disabled = getDisabled(rawNode)\n        node.isLeaf = !children || children.length === 0\n        if (children && children.length) {\n          node.children = traverse(children, level + 1, node)\n        }\n        siblings.push(node)\n        treeNodeMap.set(value, node)\n        if (!levelTreeNodeMap.has(level)) {\n          levelTreeNodeMap.set(level, [])\n        }\n        levelTreeNodeMap.get(level)?.push(node)\n      }\n      if (level > maxLevel) {\n        maxLevel = level\n      }\n      return siblings\n    }\n    const treeNodes: TreeNode[] = traverse(data)\n    return {\n      treeNodeMap,\n      levelTreeNodeMap,\n      maxLevel,\n      treeNodes,\n    }\n  }\n\n  function filter(query: string) {\n    const keys = doFilter(query)\n    if (keys) {\n      expandedKeySet.value = keys\n    }\n  }\n\n  function getChildren(node: TreeNodeData): TreeNodeData[] {\n    return node[childrenKey.value]\n  }\n\n  function getKey(node: TreeNodeData): TreeKey {\n    if (!node) {\n      return ''\n    }\n    return node[valueKey.value]\n  }\n\n  function getDisabled(node: TreeNodeData): boolean {\n    return node[disabledKey.value]\n  }\n\n  function getLabel(node: TreeNodeData): string {\n    return node[labelKey.value]\n  }\n\n  function toggleExpand(node: TreeNode) {\n    const expandedKeys = expandedKeySet.value\n    if (expandedKeys.has(node.key)) {\n      collapse(node)\n    } else {\n      expand(node)\n    }\n  }\n\n  function handleNodeClick(node: TreeNode) {\n    emit(NODE_CLICK, node.data, node)\n    handleCurrentChange(node)\n    if (props.expandOnClickNode) {\n      toggleExpand(node)\n    }\n    if (props.showCheckbox && props.checkOnClickNode && !node.disabled) {\n      toggleCheckbox(node, !isChecked(node), true)\n    }\n  }\n\n  function handleCurrentChange(node: TreeNode) {\n    if (!isCurrent(node)) {\n      currentKey.value = node.key\n      emit(CURRENT_CHANGE, node.data, node)\n    }\n  }\n\n  function handleNodeCheck(node: TreeNode, checked: boolean) {\n    toggleCheckbox(node, checked)\n  }\n\n  function expand(node: TreeNode) {\n    const keySet = expandedKeySet.value\n    if (tree?.value && props.accordion) {\n      // whether only one node among the same level can be expanded at one time\n      const { treeNodeMap } = tree.value\n      keySet.forEach((key) => {\n        const node = treeNodeMap.get(key)\n        if (node && node.level === node.level) {\n          keySet.delete(key)\n        }\n      })\n    }\n    keySet.add(node.key)\n    emit(NODE_EXPAND, node.data, node)\n  }\n\n  function collapse(node: TreeNode) {\n    expandedKeySet.value.delete(node.key)\n    emit(NODE_COLLAPSE, node.data, node)\n  }\n\n  function isExpanded(node: TreeNode): boolean {\n    return expandedKeySet.value.has(node.key)\n  }\n\n  function isDisabled(node: TreeNode): boolean {\n    return !!node.disabled\n  }\n\n  function isCurrent(node: TreeNode): boolean {\n    const current = currentKey.value\n    return !!current && current === node.key\n  }\n\n  function getCurrentNode(): TreeNodeData | undefined {\n    if (!currentKey.value) return undefined\n    return tree?.value?.treeNodeMap.get(currentKey.value)?.data\n  }\n\n  function getCurrentKey(): TreeKey | undefined {\n    return currentKey.value\n  }\n\n  function setCurrentKey(key: TreeKey): void {\n    currentKey.value = key\n  }\n\n  function setData(data: TreeData) {\n    nextTick(() => (tree.value = createTree(data)))\n  }\n\n  return {\n    tree,\n    flattenTree,\n    isNotEmpty,\n    getKey,\n    getChildren,\n    toggleExpand,\n    toggleCheckbox,\n    isExpanded,\n    isChecked,\n    isIndeterminate,\n    isDisabled,\n    isCurrent,\n    isForceHiddenExpandIcon,\n    handleNodeClick,\n    handleNodeCheck,\n    // expose\n    getCurrentNode,\n    getCurrentKey,\n    setCurrentKey,\n    getCheckedKeys,\n    getCheckedNodes,\n    getHalfCheckedKeys,\n    getHalfCheckedNodes,\n    setChecked,\n    setCheckedKeys,\n    filter,\n    setData,\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}