{"ast":null,"code":"import { hasOwn } from '@vue/shared';\nfunction getError(action, option, xhr) {\n  let msg;\n  if (xhr.response) {\n    msg = `${xhr.response.error || xhr.response}`;\n  } else if (xhr.responseText) {\n    msg = `${xhr.responseText}`;\n  } else {\n    msg = `fail to ${option.method} ${action} ${xhr.status}`;\n  }\n  const err = new Error(msg);\n  err.status = xhr.status;\n  err.method = option.method;\n  err.url = action;\n  return err;\n}\nfunction getBody(xhr) {\n  const text = xhr.responseText || xhr.response;\n  if (!text) {\n    return text;\n  }\n  try {\n    return JSON.parse(text);\n  } catch (e) {\n    return text;\n  }\n}\nfunction upload(option) {\n  if (typeof XMLHttpRequest === \"undefined\") {\n    return;\n  }\n  const xhr = new XMLHttpRequest();\n  const action = option.action;\n  if (xhr.upload) {\n    xhr.upload.onprogress = function progress(e) {\n      if (e.total > 0) {\n        ;\n        e.percent = e.loaded / e.total * 100;\n      }\n      option.onProgress(e);\n    };\n  }\n  const formData = new FormData();\n  if (option.data) {\n    Object.keys(option.data).forEach(key => {\n      formData.append(key, option.data[key]);\n    });\n  }\n  formData.append(option.filename, option.file, option.file.name);\n  xhr.onerror = function error() {\n    option.onError(getError(action, option, xhr));\n  };\n  xhr.onload = function onload() {\n    if (xhr.status < 200 || xhr.status >= 300) {\n      return option.onError(getError(action, option, xhr));\n    }\n    option.onSuccess(getBody(xhr));\n  };\n  xhr.open(option.method, action, true);\n  if (option.withCredentials && \"withCredentials\" in xhr) {\n    xhr.withCredentials = true;\n  }\n  const headers = option.headers || {};\n  for (const item in headers) {\n    if (hasOwn(headers, item) && headers[item] !== null) {\n      xhr.setRequestHeader(item, headers[item]);\n    }\n  }\n  if (headers instanceof Headers) {\n    headers.forEach((value, key) => {\n      xhr.setRequestHeader(key, value);\n    });\n  }\n  xhr.send(formData);\n  return xhr;\n}\nexport { upload as default };","map":{"version":3,"names":["getError","action","option","xhr","msg","response","error","responseText","method","status","err","Error","url","getBody","text","JSON","parse","e","XMLHttpRequest","upload","onprogress","progress","total","percent","loaded","onProgress","formData","FormData","data","Object","keys","forEach","key","append","filename","file","name","onerror","onError","onload","onSuccess","open","withCredentials","headers","item","hasOwn","setRequestHeader","Headers","value","send"],"sources":["../../../../../../packages/components/upload/src/ajax.ts"],"sourcesContent":["import { hasOwn } from '@vue/shared'\nimport type {\n  ElUploadProgressEvent,\n  ElUploadRequestOptions,\n  ElUploadAjaxError,\n} from './upload.type'\n\nfunction getError(\n  action: string,\n  option: ElUploadRequestOptions,\n  xhr: XMLHttpRequest\n) {\n  let msg: string\n  if (xhr.response) {\n    msg = `${xhr.response.error || xhr.response}`\n  } else if (xhr.responseText) {\n    msg = `${xhr.responseText}`\n  } else {\n    msg = `fail to ${option.method} ${action} ${xhr.status}`\n  }\n\n  const err = new Error(msg) as ElUploadAjaxError\n  err.status = xhr.status\n  err.method = option.method\n  err.url = action\n  return err\n}\n\nfunction getBody(xhr: XMLHttpRequest): XMLHttpRequestResponseType {\n  const text = xhr.responseText || xhr.response\n  if (!text) {\n    return text\n  }\n\n  try {\n    return JSON.parse(text)\n  } catch (e) {\n    return text\n  }\n}\n\nexport default function upload(option: ElUploadRequestOptions) {\n  if (typeof XMLHttpRequest === 'undefined') {\n    return\n  }\n\n  const xhr = new XMLHttpRequest()\n  const action = option.action\n\n  if (xhr.upload) {\n    xhr.upload.onprogress = function progress(e) {\n      if (e.total > 0) {\n        ;(e as ElUploadProgressEvent).percent = (e.loaded / e.total) * 100\n      }\n      option.onProgress(e)\n    }\n  }\n\n  const formData = new FormData()\n\n  if (option.data) {\n    Object.keys(option.data).forEach((key) => {\n      formData.append(key, option.data[key])\n    })\n  }\n\n  formData.append(option.filename, option.file, option.file.name)\n\n  xhr.onerror = function error() {\n    option.onError(getError(action, option, xhr))\n  }\n\n  xhr.onload = function onload() {\n    if (xhr.status < 200 || xhr.status >= 300) {\n      return option.onError(getError(action, option, xhr))\n    }\n\n    option.onSuccess(getBody(xhr))\n  }\n\n  xhr.open(option.method, action, true)\n\n  if (option.withCredentials && 'withCredentials' in xhr) {\n    xhr.withCredentials = true\n  }\n\n  const headers = option.headers || {}\n\n  for (const item in headers) {\n    if (hasOwn(headers, item) && headers[item] !== null) {\n      xhr.setRequestHeader(item, headers[item])\n    }\n  }\n\n  if (headers instanceof Headers) {\n    headers.forEach((value, key) => {\n      xhr.setRequestHeader(key, value)\n    })\n  }\n\n  xhr.send(formData)\n  return xhr\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}