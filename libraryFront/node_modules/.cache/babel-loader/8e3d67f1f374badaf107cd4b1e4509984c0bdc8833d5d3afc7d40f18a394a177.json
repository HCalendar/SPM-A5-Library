{"ast":null,"code":"import { throwError } from '../../../../utils/error.mjs';\nimport createList from '../builders/build-list.mjs';\nimport { isHorizontal } from '../utils.mjs';\nimport { SMART_ALIGNMENT, AUTO_ALIGNMENT, CENTERED_ALIGNMENT, END_ALIGNMENT, START_ALIGNMENT, DEFAULT_DYNAMIC_LIST_ITEM_SIZE } from '../defaults.mjs';\nconst SCOPE = \"ElDynamicSizeList\";\nconst getItemFromCache = (props, index, listCache) => {\n  const {\n    itemSize\n  } = props;\n  const {\n    items,\n    lastVisitedIndex\n  } = listCache;\n  if (index > lastVisitedIndex) {\n    let offset = 0;\n    if (lastVisitedIndex >= 0) {\n      const item = items[lastVisitedIndex];\n      offset = item.offset + item.size;\n    }\n    for (let i = lastVisitedIndex + 1; i <= index; i++) {\n      const size = itemSize(i);\n      items[i] = {\n        offset,\n        size\n      };\n      offset += size;\n    }\n    listCache.lastVisitedIndex = index;\n  }\n  return items[index];\n};\nconst findItem = (props, listCache, offset) => {\n  const {\n    items,\n    lastVisitedIndex\n  } = listCache;\n  const lastVisitedOffset = lastVisitedIndex > 0 ? items[lastVisitedIndex].offset : 0;\n  if (lastVisitedOffset >= offset) {\n    return bs(props, listCache, 0, lastVisitedIndex, offset);\n  }\n  return es(props, listCache, Math.max(0, lastVisitedIndex), offset);\n};\nconst bs = (props, listCache, low, high, offset) => {\n  while (low <= high) {\n    const mid = low + Math.floor((high - low) / 2);\n    const currentOffset = getItemFromCache(props, mid, listCache).offset;\n    if (currentOffset === offset) {\n      return mid;\n    } else if (currentOffset < offset) {\n      low = mid + 1;\n    } else if (currentOffset > offset) {\n      high = mid - 1;\n    }\n  }\n  return Math.max(0, low - 1);\n};\nconst es = (props, listCache, index, offset) => {\n  const {\n    total\n  } = props;\n  let exponent = 1;\n  while (index < total && getItemFromCache(props, index, listCache).offset < offset) {\n    index += exponent;\n    exponent *= 2;\n  }\n  return bs(props, listCache, Math.floor(index / 2), Math.min(index, total - 1), offset);\n};\nconst getEstimatedTotalSize = ({\n  total\n}, {\n  items,\n  estimatedItemSize,\n  lastVisitedIndex\n}) => {\n  let totalSizeOfMeasuredItems = 0;\n  if (lastVisitedIndex >= total) {\n    lastVisitedIndex = total - 1;\n  }\n  if (lastVisitedIndex >= 0) {\n    const item = items[lastVisitedIndex];\n    totalSizeOfMeasuredItems = item.offset + item.size;\n  }\n  const numUnmeasuredItems = total - lastVisitedIndex - 1;\n  const totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedItemSize;\n  return totalSizeOfMeasuredItems + totalSizeOfUnmeasuredItems;\n};\nconst DynamicSizeList = createList({\n  name: \"ElDynamicSizeList\",\n  getItemOffset: (props, index, listCache) => getItemFromCache(props, index, listCache).offset,\n  getItemSize: (_, index, {\n    items\n  }) => items[index].size,\n  getEstimatedTotalSize,\n  getOffset: (props, index, alignment, scrollOffset, listCache) => {\n    const {\n      height,\n      layout,\n      width\n    } = props;\n    const size = isHorizontal(layout) ? width : height;\n    const item = getItemFromCache(props, index, listCache);\n    const estimatedTotalSize = getEstimatedTotalSize(props, listCache);\n    const maxOffset = Math.max(0, Math.min(estimatedTotalSize - size, item.offset));\n    const minOffset = Math.max(0, item.offset - size + item.size);\n    if (alignment === SMART_ALIGNMENT) {\n      if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\n        alignment = AUTO_ALIGNMENT;\n      } else {\n        alignment = CENTERED_ALIGNMENT;\n      }\n    }\n    switch (alignment) {\n      case START_ALIGNMENT:\n        {\n          return maxOffset;\n        }\n      case END_ALIGNMENT:\n        {\n          return minOffset;\n        }\n      case CENTERED_ALIGNMENT:\n        {\n          return Math.round(minOffset + (maxOffset - minOffset) / 2);\n        }\n      case AUTO_ALIGNMENT:\n      default:\n        {\n          if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n            return scrollOffset;\n          } else if (scrollOffset < minOffset) {\n            return minOffset;\n          } else {\n            return maxOffset;\n          }\n        }\n    }\n  },\n  getStartIndexForOffset: (props, offset, listCache) => findItem(props, listCache, offset),\n  getStopIndexForStartIndex: (props, startIndex, scrollOffset, listCache) => {\n    const {\n      height,\n      total,\n      layout,\n      width\n    } = props;\n    const size = isHorizontal(layout) ? width : height;\n    const item = getItemFromCache(props, startIndex, listCache);\n    const maxOffset = scrollOffset + size;\n    let offset = item.offset + item.size;\n    let stopIndex = startIndex;\n    while (stopIndex < total - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemFromCache(props, stopIndex, listCache).size;\n    }\n    return stopIndex;\n  },\n  initCache({\n    estimatedItemSize = DEFAULT_DYNAMIC_LIST_ITEM_SIZE\n  }, instance) {\n    const cache = {\n      items: {},\n      estimatedItemSize,\n      lastVisitedIndex: -1\n    };\n    cache.clearCacheAfterIndex = (index, forceUpdate = true) => {\n      var _a, _b;\n      cache.lastVisitedIndex = Math.min(cache.lastVisitedIndex, index - 1);\n      (_a = instance.exposed) == null ? void 0 : _a.getItemStyleCache(-1);\n      if (forceUpdate) {\n        (_b = instance.proxy) == null ? void 0 : _b.$forceUpdate();\n      }\n    };\n    return cache;\n  },\n  clearCache: false,\n  validateProps: ({\n    itemSize\n  }) => {\n    if (process.env.NODE_ENV !== \"production\") {\n      if (typeof itemSize !== \"function\") {\n        throwError(SCOPE, `\n          itemSize is required as function, but the given value was ${typeof itemSize}\n        `);\n      }\n    }\n  }\n});\nexport { DynamicSizeList as default };","map":{"version":3,"names":["SCOPE","getItemFromCache","props","index","listCache","itemSize","items","lastVisitedIndex","offset","item","size","i","findItem","lastVisitedOffset","bs","es","Math","max","low","high","mid","floor","currentOffset","total","exponent","min","getEstimatedTotalSize","estimatedItemSize","totalSizeOfMeasuredItems","numUnmeasuredItems","totalSizeOfUnmeasuredItems","DynamicSizeList","createList","name","getItemOffset","getItemSize","_","getOffset","alignment","scrollOffset","height","layout","width","isHorizontal","estimatedTotalSize","maxOffset","minOffset","SMART_ALIGNMENT","AUTO_ALIGNMENT","CENTERED_ALIGNMENT","START_ALIGNMENT","END_ALIGNMENT","round","getStartIndexForOffset","getStopIndexForStartIndex","startIndex","stopIndex","initCache","DEFAULT_DYNAMIC_LIST_ITEM_SIZE","instance","cache","clearCacheAfterIndex","forceUpdate","_a","_b","exposed","getItemStyleCache","proxy","$forceUpdate","clearCache","validateProps","process","env","NODE_ENV","throwError"],"sources":["../../../../../../../packages/components/virtual-list/src/components/dynamic-size-list.ts"],"sourcesContent":["import { throwError } from '@element-plus/utils/error'\n\nimport createList from '../builders/build-list'\n\nimport { isHorizontal } from '../utils'\nimport {\n  AUTO_ALIGNMENT,\n  CENTERED_ALIGNMENT,\n  DEFAULT_DYNAMIC_LIST_ITEM_SIZE,\n  END_ALIGNMENT,\n  SMART_ALIGNMENT,\n  START_ALIGNMENT,\n} from '../defaults'\nimport type { VirtualizedListProps } from '../props'\n\nimport type { ListCache, ListItem, ItemSize } from '../types'\n\ntype Props = VirtualizedListProps\n\nconst SCOPE = 'ElDynamicSizeList'\nconst getItemFromCache = (\n  props: Props,\n  index: number,\n  listCache: ListCache\n): ListItem => {\n  const { itemSize } = props\n  const { items, lastVisitedIndex } = listCache\n\n  if (index > lastVisitedIndex) {\n    let offset = 0\n    if (lastVisitedIndex >= 0) {\n      const item = items[lastVisitedIndex]\n      offset = item.offset + item.size\n    }\n\n    for (let i = lastVisitedIndex + 1; i <= index; i++) {\n      const size = (itemSize as ItemSize)(i)\n\n      items[i] = {\n        offset,\n        size,\n      }\n\n      offset += size\n    }\n\n    listCache.lastVisitedIndex = index\n  }\n\n  return items[index]\n}\n\nconst findItem = (props: Props, listCache: ListCache, offset: number) => {\n  const { items, lastVisitedIndex } = listCache\n\n  const lastVisitedOffset =\n    lastVisitedIndex > 0 ? items[lastVisitedIndex].offset : 0\n\n  if (lastVisitedOffset >= offset) {\n    return bs(props, listCache, 0, lastVisitedIndex, offset)\n  }\n  return es(props, listCache, Math.max(0, lastVisitedIndex), offset)\n}\n\n// bs stands for binary search which has approximately time complexity of O(Log n)\n// space complexity of O(1)\n// in this case we use it for search the offset of each item, since\n// the cached items' offset is monotonically increasing\nconst bs = (\n  props: Props,\n  listCache: ListCache,\n  low: number,\n  high: number,\n  offset: number\n) => {\n  while (low <= high) {\n    const mid = low + Math.floor((high - low) / 2)\n    const currentOffset = getItemFromCache(props, mid, listCache).offset\n\n    if (currentOffset === offset) {\n      return mid\n    } else if (currentOffset < offset) {\n      low = mid + 1\n    } else if (currentOffset > offset) {\n      high = mid - 1\n    }\n  }\n\n  return Math.max(0, low - 1)\n}\n\n// es stands for exponential search which has time complexity of O(Log n) and\n// space complexity of O(1) in the case of finding the boundary element.\n// the exponential indicator in this case is 2.\n// for more detail about exponential search click this link\n// https://www.freecodecamp.org/news/search-algorithms-exponential-search-explained/\n\nconst es = (\n  props: Props,\n  listCache: ListCache,\n  index: number,\n  offset: number\n) => {\n  const { total } = props\n  let exponent = 1\n\n  while (\n    index < total &&\n    getItemFromCache(props, index, listCache).offset < offset\n  ) {\n    index += exponent\n    exponent *= 2\n  }\n\n  return bs(\n    props,\n    listCache,\n    Math.floor(index / 2),\n    Math.min(index, total - 1),\n    offset\n  )\n}\n\nconst getEstimatedTotalSize = (\n  { total }: Props,\n  { items, estimatedItemSize, lastVisitedIndex }: ListCache\n) => {\n  let totalSizeOfMeasuredItems = 0\n\n  if (lastVisitedIndex >= total) {\n    lastVisitedIndex = total - 1\n  }\n\n  if (lastVisitedIndex >= 0) {\n    const item = items[lastVisitedIndex]\n    totalSizeOfMeasuredItems = item.offset + item.size\n  }\n\n  const numUnmeasuredItems = total - lastVisitedIndex - 1\n  const totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedItemSize\n  return totalSizeOfMeasuredItems + totalSizeOfUnmeasuredItems\n}\n\nconst DynamicSizeList = createList({\n  name: 'ElDynamicSizeList',\n  getItemOffset: (props, index, listCache) =>\n    getItemFromCache(props, index, listCache).offset,\n\n  getItemSize: (_, index, { items }) => items[index].size,\n\n  getEstimatedTotalSize,\n\n  getOffset: (props, index, alignment, scrollOffset, listCache) => {\n    const { height, layout, width } = props\n\n    const size = (isHorizontal(layout) ? width : height) as number\n    const item = getItemFromCache(props, index, listCache)\n\n    const estimatedTotalSize = getEstimatedTotalSize(props, listCache)\n\n    const maxOffset = Math.max(\n      0,\n      Math.min(estimatedTotalSize - size, item.offset)\n    )\n    const minOffset = Math.max(0, item.offset - size + item.size)\n\n    if (alignment === SMART_ALIGNMENT) {\n      if (\n        scrollOffset >= minOffset - size &&\n        scrollOffset <= maxOffset + size\n      ) {\n        alignment = AUTO_ALIGNMENT\n      } else {\n        alignment = CENTERED_ALIGNMENT\n      }\n    }\n\n    switch (alignment) {\n      case START_ALIGNMENT: {\n        return maxOffset\n      }\n      case END_ALIGNMENT: {\n        return minOffset\n      }\n      case CENTERED_ALIGNMENT: {\n        return Math.round(minOffset + (maxOffset - minOffset) / 2)\n      }\n      case AUTO_ALIGNMENT:\n      default: {\n        if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n          return scrollOffset\n        } else if (scrollOffset < minOffset) {\n          return minOffset\n        } else {\n          return maxOffset\n        }\n      }\n    }\n  },\n\n  getStartIndexForOffset: (props, offset, listCache) =>\n    findItem(props, listCache, offset),\n\n  getStopIndexForStartIndex: (props, startIndex, scrollOffset, listCache) => {\n    const { height, total, layout, width } = props\n\n    const size = (isHorizontal(layout) ? width : height) as number\n    const item = getItemFromCache(props, startIndex, listCache)\n    const maxOffset = scrollOffset + size\n\n    let offset = item.offset + item.size\n    let stopIndex = startIndex\n\n    while (stopIndex < total - 1 && offset < maxOffset) {\n      stopIndex++\n      offset += getItemFromCache(props, stopIndex, listCache).size\n    }\n\n    return stopIndex\n  },\n\n  initCache({ estimatedItemSize = DEFAULT_DYNAMIC_LIST_ITEM_SIZE }, instance) {\n    const cache = {\n      items: {},\n      estimatedItemSize,\n      lastVisitedIndex: -1,\n    } as ListCache\n\n    cache.clearCacheAfterIndex = (index: number, forceUpdate = true) => {\n      cache.lastVisitedIndex = Math.min(cache.lastVisitedIndex, index - 1)\n      instance.exposed?.getItemStyleCache(-1)\n\n      if (forceUpdate) {\n        instance.proxy?.$forceUpdate()\n      }\n    }\n\n    return cache\n  },\n\n  clearCache: false,\n\n  validateProps: ({ itemSize }) => {\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof itemSize !== 'function') {\n        throwError(\n          SCOPE,\n          `\n          itemSize is required as function, but the given value was ${typeof itemSize}\n        `\n        )\n      }\n    }\n  },\n})\n\nexport default DynamicSizeList\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}