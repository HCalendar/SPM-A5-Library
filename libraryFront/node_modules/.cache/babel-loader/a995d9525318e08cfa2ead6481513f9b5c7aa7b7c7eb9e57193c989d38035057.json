{"ast":null,"code":"const EVENT_CODE = {\n  tab: \"Tab\",\n  enter: \"Enter\",\n  space: \"Space\",\n  left: \"ArrowLeft\",\n  up: \"ArrowUp\",\n  right: \"ArrowRight\",\n  down: \"ArrowDown\",\n  esc: \"Escape\",\n  delete: \"Delete\",\n  backspace: \"Backspace\",\n  numpadEnter: \"NumpadEnter\"\n};\nconst FOCUSABLE_ELEMENT_SELECTORS = `a[href],button:not([disabled]),button:not([hidden]),:not([tabindex=\"-1\"]),input:not([disabled]),input:not([type=\"hidden\"]),select:not([disabled]),textarea:not([disabled])`;\nconst isVisible = element => {\n  if (process.env.NODE_ENV === \"test\") return true;\n  const computed = getComputedStyle(element);\n  return computed.position === \"fixed\" ? false : element.offsetParent !== null;\n};\nconst obtainAllFocusableElements = element => {\n  return Array.from(element.querySelectorAll(FOCUSABLE_ELEMENT_SELECTORS)).filter(item => isFocusable(item) && isVisible(item));\n};\nconst isFocusable = element => {\n  if (element.tabIndex > 0 || element.tabIndex === 0 && element.getAttribute(\"tabIndex\") !== null) {\n    return true;\n  }\n  if (element.disabled) {\n    return false;\n  }\n  switch (element.nodeName) {\n    case \"A\":\n      {\n        return !!element.href && element.rel !== \"ignore\";\n      }\n    case \"INPUT\":\n      {\n        return !(element.type === \"hidden\" || element.type === \"file\");\n      }\n    case \"BUTTON\":\n    case \"SELECT\":\n    case \"TEXTAREA\":\n      {\n        return true;\n      }\n    default:\n      {\n        return false;\n      }\n  }\n};\nconst attemptFocus = element => {\n  var _a;\n  if (!isFocusable(element)) {\n    return false;\n  }\n  Utils.IgnoreUtilFocusChanges = true;\n  (_a = element.focus) == null ? void 0 : _a.call(element);\n  Utils.IgnoreUtilFocusChanges = false;\n  return document.activeElement === element;\n};\nconst triggerEvent = function (elm, name, ...opts) {\n  let eventName;\n  if (name.includes(\"mouse\") || name.includes(\"click\")) {\n    eventName = \"MouseEvents\";\n  } else if (name.includes(\"key\")) {\n    eventName = \"KeyboardEvent\";\n  } else {\n    eventName = \"HTMLEvents\";\n  }\n  const evt = document.createEvent(eventName);\n  evt.initEvent(name, ...opts);\n  elm.dispatchEvent(evt);\n  return elm;\n};\nconst isLeaf = el => !el.getAttribute(\"aria-owns\");\nconst getSibling = (el, distance, elClass) => {\n  const {\n    parentNode\n  } = el;\n  if (!parentNode) return null;\n  const siblings = parentNode.querySelectorAll(elClass);\n  const index = Array.prototype.indexOf.call(siblings, el);\n  return siblings[index + distance] || null;\n};\nconst focusNode = el => {\n  if (!el) return;\n  el.focus();\n  !isLeaf(el) && el.click();\n};\nconst Utils = {\n  IgnoreUtilFocusChanges: false,\n  focusFirstDescendant(element) {\n    for (let i = 0; i < element.childNodes.length; i++) {\n      const child = element.childNodes[i];\n      if (attemptFocus(child) || this.focusFirstDescendant(child)) {\n        return true;\n      }\n    }\n    return false;\n  },\n  focusLastDescendant(element) {\n    for (let i = element.childNodes.length - 1; i >= 0; i--) {\n      const child = element.childNodes[i];\n      if (attemptFocus(child) || this.focusLastDescendant(child)) {\n        return true;\n      }\n    }\n    return false;\n  }\n};\nexport { EVENT_CODE, attemptFocus, Utils as default, focusNode, getSibling, isFocusable, isLeaf, isVisible, obtainAllFocusableElements, triggerEvent };","map":{"version":3,"names":["EVENT_CODE","tab","enter","space","left","up","right","down","esc","delete","backspace","numpadEnter","FOCUSABLE_ELEMENT_SELECTORS","isVisible","element","process","env","NODE_ENV","computed","getComputedStyle","position","offsetParent","obtainAllFocusableElements","Array","from","querySelectorAll","filter","item","isFocusable","tabIndex","getAttribute","disabled","nodeName","href","rel","type","attemptFocus","_a","Utils","IgnoreUtilFocusChanges","focus","call","document","activeElement","triggerEvent","elm","name","opts","eventName","includes","evt","createEvent","initEvent","dispatchEvent","isLeaf","el","getSibling","distance","elClass","parentNode","siblings","index","prototype","indexOf","focusNode","click","focusFirstDescendant","i","childNodes","length","child","focusLastDescendant"],"sources":["../../../../packages/utils/aria.ts"],"sourcesContent":["import type { Nullable } from '@element-plus/utils/types'\nexport const EVENT_CODE = {\n  tab: 'Tab',\n  enter: 'Enter',\n  space: 'Space',\n  left: 'ArrowLeft', // 37\n  up: 'ArrowUp', // 38\n  right: 'ArrowRight', // 39\n  down: 'ArrowDown', // 40\n  esc: 'Escape',\n  delete: 'Delete',\n  backspace: 'Backspace',\n  numpadEnter: 'NumpadEnter',\n}\n\nconst FOCUSABLE_ELEMENT_SELECTORS = `a[href],button:not([disabled]),button:not([hidden]),:not([tabindex=\"-1\"]),input:not([disabled]),input:not([type=\"hidden\"]),select:not([disabled]),textarea:not([disabled])`\n\n/**\n * Determine if the testing element is visible on screen no matter if its on the viewport or not\n */\nexport const isVisible = (element: HTMLElement) => {\n  if (process.env.NODE_ENV === 'test') return true\n  const computed = getComputedStyle(element)\n  // element.offsetParent won't work on fix positioned\n  // WARNING: potential issue here, going to need some expert advices on this issue\n  return computed.position === 'fixed' ? false : element.offsetParent !== null\n}\n\nexport const obtainAllFocusableElements = (\n  element: HTMLElement\n): HTMLElement[] => {\n  return Array.from(\n    element.querySelectorAll<HTMLElement>(FOCUSABLE_ELEMENT_SELECTORS)\n  ).filter((item: HTMLElement) => isFocusable(item) && isVisible(item))\n}\n\n/**\n * @desc Determine if target element is focusable\n * @param element {HTMLElement}\n * @returns {Boolean} true if it is focusable\n */\nexport const isFocusable = (element: HTMLElement): boolean => {\n  if (\n    element.tabIndex > 0 ||\n    (element.tabIndex === 0 && element.getAttribute('tabIndex') !== null)\n  ) {\n    return true\n  }\n  // HTMLButtonElement has disabled\n  if ((element as HTMLButtonElement).disabled) {\n    return false\n  }\n\n  switch (element.nodeName) {\n    case 'A': {\n      // casting current element to Specific HTMLElement in order to be more type precise\n      return (\n        !!(element as HTMLAnchorElement).href &&\n        (element as HTMLAnchorElement).rel !== 'ignore'\n      )\n    }\n    case 'INPUT': {\n      return !(\n        (element as HTMLInputElement).type === 'hidden' ||\n        (element as HTMLInputElement).type === 'file'\n      )\n    }\n    case 'BUTTON':\n    case 'SELECT':\n    case 'TEXTAREA': {\n      return true\n    }\n    default: {\n      return false\n    }\n  }\n}\n\n/**\n * @desc Set Attempt to set focus on the current node.\n * @param element\n *          The node to attempt to focus on.\n * @returns\n *  true if element is focused.\n */\nexport const attemptFocus = (element: HTMLElement): boolean => {\n  if (!isFocusable(element)) {\n    return false\n  }\n  Utils.IgnoreUtilFocusChanges = true\n  // Remove the old try catch block since there will be no error to be thrown\n  element.focus?.()\n  Utils.IgnoreUtilFocusChanges = false\n  return document.activeElement === element\n}\n\n/**\n * Trigger an event\n * mouseenter, mouseleave, mouseover, keyup, change, click, etc.\n * @param  {HTMLElement} elm\n * @param  {String} name\n * @param  {*} opts\n */\nexport const triggerEvent = function (\n  elm: HTMLElement,\n  name: string,\n  ...opts: Array<boolean>\n): HTMLElement {\n  let eventName: string\n\n  if (name.includes('mouse') || name.includes('click')) {\n    eventName = 'MouseEvents'\n  } else if (name.includes('key')) {\n    eventName = 'KeyboardEvent'\n  } else {\n    eventName = 'HTMLEvents'\n  }\n  const evt = document.createEvent(eventName)\n\n  evt.initEvent(name, ...opts)\n  elm.dispatchEvent(evt)\n  return elm\n}\n\nexport const isLeaf = (el: HTMLElement) => !el.getAttribute('aria-owns')\n\nexport const getSibling = (\n  el: HTMLElement,\n  distance: number,\n  elClass: string\n): Nullable<Element> => {\n  const { parentNode } = el\n  if (!parentNode) return null\n  const siblings = parentNode.querySelectorAll(elClass)\n  const index = Array.prototype.indexOf.call(siblings, el)\n  return siblings[index + distance] || null\n}\n\nexport const focusNode = (el) => {\n  if (!el) return\n  el.focus()\n  !isLeaf(el) && el.click()\n}\n\nconst Utils = {\n  IgnoreUtilFocusChanges: false,\n  /**\n   * @desc Set focus on descendant nodes until the first focusable element is\n   *       found.\n   * @param {HTMLElement} element\n   *          DOM node for which to find the first focusable descendant.\n   * @returns {Boolean}\n   *  true if a focusable element is found and focus is set.\n   */\n  focusFirstDescendant(element: HTMLElement): boolean {\n    for (let i = 0; i < element.childNodes.length; i++) {\n      const child = element.childNodes[i] as HTMLElement\n      if (attemptFocus(child) || this.focusFirstDescendant(child)) {\n        return true\n      }\n    }\n    return false\n  },\n  /**\n   * @desc Find the last descendant node that is focusable.\n   * @param {HTMLElement} element\n   *          DOM node for which to find the last focusable descendant.\n   * @returns {Boolean}\n   *  true if a focusable element is found and focus is set.\n   */\n  focusLastDescendant(element: HTMLElement): boolean {\n    for (let i = element.childNodes.length - 1; i >= 0; i--) {\n      const child = element.childNodes[i] as HTMLElement\n      if (attemptFocus(child) || this.focusLastDescendant(child)) {\n        return true\n      }\n    }\n    return false\n  },\n}\n\nexport default Utils\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}