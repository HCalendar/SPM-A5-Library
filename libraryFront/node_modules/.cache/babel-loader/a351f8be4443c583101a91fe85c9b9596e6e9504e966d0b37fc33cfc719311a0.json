{"ast":null,"code":"import { hasOwn } from '@vue/shared';\nconst hsv2hsl = function (hue, sat, val) {\n  return [hue, sat * val / ((hue = (2 - sat) * val) < 1 ? hue : 2 - hue) || 0, hue / 2];\n};\nconst isOnePointZero = function (n) {\n  return typeof n === \"string\" && n.indexOf(\".\") !== -1 && parseFloat(n) === 1;\n};\nconst isPercentage = function (n) {\n  return typeof n === \"string\" && n.indexOf(\"%\") !== -1;\n};\nconst bound01 = function (value, max) {\n  if (isOnePointZero(value)) value = \"100%\";\n  const processPercent = isPercentage(value);\n  value = Math.min(max, Math.max(0, parseFloat(`${value}`)));\n  if (processPercent) {\n    value = parseInt(`${value * max}`, 10) / 100;\n  }\n  if (Math.abs(value - max) < 1e-6) {\n    return 1;\n  }\n  return value % max / parseFloat(max);\n};\nconst INT_HEX_MAP = {\n  10: \"A\",\n  11: \"B\",\n  12: \"C\",\n  13: \"D\",\n  14: \"E\",\n  15: \"F\"\n};\nconst hexOne = function (value) {\n  value = Math.min(Math.round(value), 255);\n  const high = Math.floor(value / 16);\n  const low = value % 16;\n  return `${INT_HEX_MAP[high] || high}${INT_HEX_MAP[low] || low}`;\n};\nconst toHex = function ({\n  r,\n  g,\n  b\n}) {\n  if (isNaN(r) || isNaN(g) || isNaN(b)) return \"\";\n  return `#${hexOne(r)}${hexOne(g)}${hexOne(b)}`;\n};\nconst HEX_INT_MAP = {\n  A: 10,\n  B: 11,\n  C: 12,\n  D: 13,\n  E: 14,\n  F: 15\n};\nconst parseHexChannel = function (hex) {\n  if (hex.length === 2) {\n    return (HEX_INT_MAP[hex[0].toUpperCase()] || +hex[0]) * 16 + (HEX_INT_MAP[hex[1].toUpperCase()] || +hex[1]);\n  }\n  return HEX_INT_MAP[hex[1].toUpperCase()] || +hex[1];\n};\nconst hsl2hsv = function (hue, sat, light) {\n  sat = sat / 100;\n  light = light / 100;\n  let smin = sat;\n  const lmin = Math.max(light, 0.01);\n  light *= 2;\n  sat *= light <= 1 ? light : 2 - light;\n  smin *= lmin <= 1 ? lmin : 2 - lmin;\n  const v = (light + sat) / 2;\n  const sv = light === 0 ? 2 * smin / (lmin + smin) : 2 * sat / (light + sat);\n  return {\n    h: hue,\n    s: sv * 100,\n    v: v * 100\n  };\n};\nconst rgb2hsv = function (r, g, b) {\n  r = bound01(r, 255);\n  g = bound01(g, 255);\n  b = bound01(b, 255);\n  const max = Math.max(r, g, b);\n  const min = Math.min(r, g, b);\n  let h;\n  const v = max;\n  const d = max - min;\n  const s = max === 0 ? 0 : d / max;\n  if (max === min) {\n    h = 0;\n  } else {\n    switch (max) {\n      case r:\n        {\n          h = (g - b) / d + (g < b ? 6 : 0);\n          break;\n        }\n      case g:\n        {\n          h = (b - r) / d + 2;\n          break;\n        }\n      case b:\n        {\n          h = (r - g) / d + 4;\n          break;\n        }\n    }\n    h /= 6;\n  }\n  return {\n    h: h * 360,\n    s: s * 100,\n    v: v * 100\n  };\n};\nconst hsv2rgb = function (h, s, v) {\n  h = bound01(h, 360) * 6;\n  s = bound01(s, 100);\n  v = bound01(v, 100);\n  const i = Math.floor(h);\n  const f = h - i;\n  const p = v * (1 - s);\n  const q = v * (1 - f * s);\n  const t = v * (1 - (1 - f) * s);\n  const mod = i % 6;\n  const r = [v, q, p, p, t, v][mod];\n  const g = [t, v, v, q, p, p][mod];\n  const b = [p, p, t, v, v, q][mod];\n  return {\n    r: Math.round(r * 255),\n    g: Math.round(g * 255),\n    b: Math.round(b * 255)\n  };\n};\nclass Color {\n  constructor(options) {\n    this._hue = 0;\n    this._saturation = 100;\n    this._value = 100;\n    this._alpha = 100;\n    this.enableAlpha = false;\n    this.format = \"hex\";\n    this.value = \"\";\n    options = options || {};\n    for (const option in options) {\n      if (hasOwn(options, option)) {\n        this[option] = options[option];\n      }\n    }\n    this.doOnChange();\n  }\n  set(prop, value) {\n    if (arguments.length === 1 && typeof prop === \"object\") {\n      for (const p in prop) {\n        if (hasOwn(prop, p)) {\n          this.set(p, prop[p]);\n        }\n      }\n      return;\n    }\n    this[`_${prop}`] = value;\n    this.doOnChange();\n  }\n  get(prop) {\n    if (prop === \"alpha\") {\n      return Math.floor(this[`_${prop}`]);\n    }\n    return this[`_${prop}`];\n  }\n  toRgb() {\n    return hsv2rgb(this._hue, this._saturation, this._value);\n  }\n  fromString(value) {\n    if (!value) {\n      this._hue = 0;\n      this._saturation = 100;\n      this._value = 100;\n      this.doOnChange();\n      return;\n    }\n    const fromHSV = (h, s, v) => {\n      this._hue = Math.max(0, Math.min(360, h));\n      this._saturation = Math.max(0, Math.min(100, s));\n      this._value = Math.max(0, Math.min(100, v));\n      this.doOnChange();\n    };\n    if (value.indexOf(\"hsl\") !== -1) {\n      const parts = value.replace(/hsla|hsl|\\(|\\)/gm, \"\").split(/\\s|,/g).filter(val => val !== \"\").map((val, index) => index > 2 ? parseFloat(val) : parseInt(val, 10));\n      if (parts.length === 4) {\n        this._alpha = parseFloat(parts[3]) * 100;\n      } else if (parts.length === 3) {\n        this._alpha = 100;\n      }\n      if (parts.length >= 3) {\n        const {\n          h,\n          s,\n          v\n        } = hsl2hsv(parts[0], parts[1], parts[2]);\n        fromHSV(h, s, v);\n      }\n    } else if (value.indexOf(\"hsv\") !== -1) {\n      const parts = value.replace(/hsva|hsv|\\(|\\)/gm, \"\").split(/\\s|,/g).filter(val => val !== \"\").map((val, index) => index > 2 ? parseFloat(val) : parseInt(val, 10));\n      if (parts.length === 4) {\n        this._alpha = parseFloat(parts[3]) * 100;\n      } else if (parts.length === 3) {\n        this._alpha = 100;\n      }\n      if (parts.length >= 3) {\n        fromHSV(parts[0], parts[1], parts[2]);\n      }\n    } else if (value.indexOf(\"rgb\") !== -1) {\n      const parts = value.replace(/rgba|rgb|\\(|\\)/gm, \"\").split(/\\s|,/g).filter(val => val !== \"\").map((val, index) => index > 2 ? parseFloat(val) : parseInt(val, 10));\n      if (parts.length === 4) {\n        this._alpha = parseFloat(parts[3]) * 100;\n      } else if (parts.length === 3) {\n        this._alpha = 100;\n      }\n      if (parts.length >= 3) {\n        const {\n          h,\n          s,\n          v\n        } = rgb2hsv(parts[0], parts[1], parts[2]);\n        fromHSV(h, s, v);\n      }\n    } else if (value.indexOf(\"#\") !== -1) {\n      const hex = value.replace(\"#\", \"\").trim();\n      if (!/^[0-9a-fA-F]{3}$|^[0-9a-fA-F]{6}$|^[0-9a-fA-F]{8}$/.test(hex)) return;\n      let r, g, b;\n      if (hex.length === 3) {\n        r = parseHexChannel(hex[0] + hex[0]);\n        g = parseHexChannel(hex[1] + hex[1]);\n        b = parseHexChannel(hex[2] + hex[2]);\n      } else if (hex.length === 6 || hex.length === 8) {\n        r = parseHexChannel(hex.substring(0, 2));\n        g = parseHexChannel(hex.substring(2, 4));\n        b = parseHexChannel(hex.substring(4, 6));\n      }\n      if (hex.length === 8) {\n        this._alpha = parseHexChannel(hex.substring(6)) / 255 * 100;\n      } else if (hex.length === 3 || hex.length === 6) {\n        this._alpha = 100;\n      }\n      const {\n        h,\n        s,\n        v\n      } = rgb2hsv(r, g, b);\n      fromHSV(h, s, v);\n    }\n  }\n  compare(color) {\n    return Math.abs(color._hue - this._hue) < 2 && Math.abs(color._saturation - this._saturation) < 1 && Math.abs(color._value - this._value) < 1 && Math.abs(color._alpha - this._alpha) < 1;\n  }\n  doOnChange() {\n    const {\n      _hue,\n      _saturation,\n      _value,\n      _alpha,\n      format\n    } = this;\n    if (this.enableAlpha) {\n      switch (format) {\n        case \"hsl\":\n          {\n            const hsl = hsv2hsl(_hue, _saturation / 100, _value / 100);\n            this.value = `hsla(${_hue}, ${Math.round(hsl[1] * 100)}%, ${Math.round(hsl[2] * 100)}%, ${this.get(\"alpha\") / 100})`;\n            break;\n          }\n        case \"hsv\":\n          {\n            this.value = `hsva(${_hue}, ${Math.round(_saturation)}%, ${Math.round(_value)}%, ${this.get(\"alpha\") / 100})`;\n            break;\n          }\n        case \"hex\":\n          {\n            this.value = `${toHex(hsv2rgb(_hue, _saturation, _value))}${hexOne(_alpha * 255 / 100)}`;\n            break;\n          }\n        default:\n          {\n            const {\n              r,\n              g,\n              b\n            } = hsv2rgb(_hue, _saturation, _value);\n            this.value = `rgba(${r}, ${g}, ${b}, ${this.get(\"alpha\") / 100})`;\n          }\n      }\n    } else {\n      switch (format) {\n        case \"hsl\":\n          {\n            const hsl = hsv2hsl(_hue, _saturation / 100, _value / 100);\n            this.value = `hsl(${_hue}, ${Math.round(hsl[1] * 100)}%, ${Math.round(hsl[2] * 100)}%)`;\n            break;\n          }\n        case \"hsv\":\n          {\n            this.value = `hsv(${_hue}, ${Math.round(_saturation)}%, ${Math.round(_value)}%)`;\n            break;\n          }\n        case \"rgb\":\n          {\n            const {\n              r,\n              g,\n              b\n            } = hsv2rgb(_hue, _saturation, _value);\n            this.value = `rgb(${r}, ${g}, ${b})`;\n            break;\n          }\n        default:\n          {\n            this.value = toHex(hsv2rgb(_hue, _saturation, _value));\n          }\n      }\n    }\n  }\n}\nexport { Color as default };","map":{"version":3,"names":["hsv2hsl","hue","sat","val","isOnePointZero","n","indexOf","parseFloat","isPercentage","bound01","value","max","processPercent","Math","min","parseInt","abs","INT_HEX_MAP","hexOne","round","high","floor","low","toHex","r","g","b","isNaN","HEX_INT_MAP","A","B","C","D","E","F","parseHexChannel","hex","length","toUpperCase","hsl2hsv","light","smin","lmin","v","sv","h","s","rgb2hsv","d","hsv2rgb","i","f","p","q","t","mod","constructor","options","_hue","_saturation","_value","_alpha","enableAlpha","format","option","hasOwn","doOnChange","set","prop","arguments","get","toRgb","fromString","fromHSV","parts","replace","split","filter","map","index","trim","test","substring","compare","color","hsl"],"sources":["../../../../../../packages/components/color-picker/src/color.ts"],"sourcesContent":["import { hasOwn } from '@vue/shared'\n\nconst hsv2hsl = function (hue: number, sat: number, val: number) {\n  return [\n    hue,\n    (sat * val) / ((hue = (2 - sat) * val) < 1 ? hue : 2 - hue) || 0,\n    hue / 2,\n  ]\n}\n\n// Need to handle 1.0 as 100%, since once it is a number, there is no difference between it and 1\n// <http://stackoverflow.com/questions/7422072/javascript-how-to-detect-number-as-a-decimal-including-1-0>\nconst isOnePointZero = function (n: unknown) {\n  return typeof n === 'string' && n.indexOf('.') !== -1 && parseFloat(n) === 1\n}\n\nconst isPercentage = function (n: unknown) {\n  return typeof n === 'string' && n.indexOf('%') !== -1\n}\n\n// Take input from [0, n] and return it as [0, 1]\nconst bound01 = function (value: number | string, max: number | string) {\n  if (isOnePointZero(value)) value = '100%'\n\n  const processPercent = isPercentage(value)\n  value = Math.min(max as number, Math.max(0, parseFloat(`${value}`)))\n\n  // Automatically convert percentage into number\n  if (processPercent) {\n    value = parseInt(`${value * (max as number)}`, 10) / 100\n  }\n\n  // Handle floating point rounding errors\n  if (Math.abs(value - (max as number)) < 0.000001) {\n    return 1\n  }\n\n  // Convert into [0, 1] range if it isn't already\n  return (value % (max as number)) / parseFloat(max as string)\n}\n\nconst INT_HEX_MAP = { 10: 'A', 11: 'B', 12: 'C', 13: 'D', 14: 'E', 15: 'F' }\n\nconst hexOne = function (value: number) {\n  value = Math.min(Math.round(value), 255)\n  const high = Math.floor(value / 16)\n  const low = value % 16\n  return `${INT_HEX_MAP[high] || high}${INT_HEX_MAP[low] || low}`\n}\n\nconst toHex = function ({ r, g, b }) {\n  if (isNaN(r) || isNaN(g) || isNaN(b)) return ''\n\n  return `#${hexOne(r)}${hexOne(g)}${hexOne(b)}`\n}\n\nconst HEX_INT_MAP = { A: 10, B: 11, C: 12, D: 13, E: 14, F: 15 }\n\nconst parseHexChannel = function (hex: string) {\n  if (hex.length === 2) {\n    return (\n      (HEX_INT_MAP[hex[0].toUpperCase()] || +hex[0]) * 16 +\n      (HEX_INT_MAP[hex[1].toUpperCase()] || +hex[1])\n    )\n  }\n\n  return HEX_INT_MAP[hex[1].toUpperCase()] || +hex[1]\n}\n\nconst hsl2hsv = function (hue: number, sat: number, light: number) {\n  sat = sat / 100\n  light = light / 100\n  let smin = sat\n  const lmin = Math.max(light, 0.01)\n  // let sv\n  // let v\n\n  light *= 2\n  sat *= light <= 1 ? light : 2 - light\n  smin *= lmin <= 1 ? lmin : 2 - lmin\n  const v = (light + sat) / 2\n  const sv =\n    light === 0 ? (2 * smin) / (lmin + smin) : (2 * sat) / (light + sat)\n\n  return {\n    h: hue,\n    s: sv * 100,\n    v: v * 100,\n  }\n}\n\n// `rgbToHsv`\n// Converts an RGB color value to HSV\n// *Assumes:* r, g, and b are contained in the set [0, 255] or [0, 1]\n// *Returns:* { h, s, v } in [0,1]\nconst rgb2hsv = function (r, g, b) {\n  r = bound01(r, 255)\n  g = bound01(g, 255)\n  b = bound01(b, 255)\n\n  const max = Math.max(r, g, b)\n  const min = Math.min(r, g, b)\n  let h\n  const v = max\n\n  const d = max - min\n  const s = max === 0 ? 0 : d / max\n\n  if (max === min) {\n    h = 0 // achromatic\n  } else {\n    switch (max) {\n      case r: {\n        h = (g - b) / d + (g < b ? 6 : 0)\n        break\n      }\n      case g: {\n        h = (b - r) / d + 2\n        break\n      }\n      case b: {\n        h = (r - g) / d + 4\n        break\n      }\n    }\n    h /= 6\n  }\n\n  return { h: h * 360, s: s * 100, v: v * 100 }\n}\n\n// `hsvToRgb`\n// Converts an HSV color value to RGB.\n// *Assumes:* h is contained in [0, 1] or [0, 360] and s and v are contained in [0, 1] or [0, 100]\n// *Returns:* { r, g, b } in the set [0, 255]\nconst hsv2rgb = function (h, s, v) {\n  h = bound01(h, 360) * 6\n  s = bound01(s, 100)\n  v = bound01(v, 100)\n\n  const i = Math.floor(h)\n  const f = h - i\n  const p = v * (1 - s)\n  const q = v * (1 - f * s)\n  const t = v * (1 - (1 - f) * s)\n  const mod = i % 6\n  const r = [v, q, p, p, t, v][mod]\n  const g = [t, v, v, q, p, p][mod]\n  const b = [p, p, t, v, v, q][mod]\n\n  return {\n    r: Math.round(r * 255),\n    g: Math.round(g * 255),\n    b: Math.round(b * 255),\n  }\n}\n\nexport interface Options {\n  enableAlpha: boolean\n  format: string\n  value?: string\n}\n\nexport default class Color {\n  private _hue = 0\n  private _saturation = 100\n  private _value = 100\n  private _alpha = 100\n  public enableAlpha = false\n  public format = 'hex'\n  public value = ''\n  public selected?: boolean\n  constructor(options?: Options) {\n    options = options || ({} as Options)\n\n    for (const option in options) {\n      if (hasOwn(options, option)) {\n        this[option] = options[option]\n      }\n    }\n\n    this.doOnChange()\n  }\n\n  set(prop: { [key: string]: any } | any, value?: number) {\n    if (arguments.length === 1 && typeof prop === 'object') {\n      for (const p in prop) {\n        if (hasOwn(prop, p)) {\n          this.set(p, prop[p])\n        }\n      }\n\n      return\n    }\n\n    this[`_${prop}`] = value\n    this.doOnChange()\n  }\n\n  get(prop: string) {\n    if (prop === 'alpha') {\n      return Math.floor(this[`_${prop}`])\n    }\n    return this[`_${prop}`]\n  }\n\n  toRgb() {\n    return hsv2rgb(this._hue, this._saturation, this._value)\n  }\n\n  fromString(value) {\n    if (!value) {\n      this._hue = 0\n      this._saturation = 100\n      this._value = 100\n\n      this.doOnChange()\n      return\n    }\n\n    const fromHSV = (h, s, v) => {\n      this._hue = Math.max(0, Math.min(360, h))\n      this._saturation = Math.max(0, Math.min(100, s))\n      this._value = Math.max(0, Math.min(100, v))\n\n      this.doOnChange()\n    }\n\n    if (value.indexOf('hsl') !== -1) {\n      const parts = value\n        .replace(/hsla|hsl|\\(|\\)/gm, '')\n        .split(/\\s|,/g)\n        .filter((val) => val !== '')\n        .map((val, index) => (index > 2 ? parseFloat(val) : parseInt(val, 10)))\n\n      if (parts.length === 4) {\n        this._alpha = parseFloat(parts[3]) * 100\n      } else if (parts.length === 3) {\n        this._alpha = 100\n      }\n      if (parts.length >= 3) {\n        const { h, s, v } = hsl2hsv(parts[0], parts[1], parts[2])\n        fromHSV(h, s, v)\n      }\n    } else if (value.indexOf('hsv') !== -1) {\n      const parts = value\n        .replace(/hsva|hsv|\\(|\\)/gm, '')\n        .split(/\\s|,/g)\n        .filter((val) => val !== '')\n        .map((val, index) => (index > 2 ? parseFloat(val) : parseInt(val, 10)))\n\n      if (parts.length === 4) {\n        this._alpha = parseFloat(parts[3]) * 100\n      } else if (parts.length === 3) {\n        this._alpha = 100\n      }\n      if (parts.length >= 3) {\n        fromHSV(parts[0], parts[1], parts[2])\n      }\n    } else if (value.indexOf('rgb') !== -1) {\n      const parts = value\n        .replace(/rgba|rgb|\\(|\\)/gm, '')\n        .split(/\\s|,/g)\n        .filter((val) => val !== '')\n        .map((val, index) => (index > 2 ? parseFloat(val) : parseInt(val, 10)))\n\n      if (parts.length === 4) {\n        this._alpha = parseFloat(parts[3]) * 100\n      } else if (parts.length === 3) {\n        this._alpha = 100\n      }\n      if (parts.length >= 3) {\n        const { h, s, v } = rgb2hsv(parts[0], parts[1], parts[2])\n        fromHSV(h, s, v)\n      }\n    } else if (value.indexOf('#') !== -1) {\n      const hex = value.replace('#', '').trim()\n      if (!/^[0-9a-fA-F]{3}$|^[0-9a-fA-F]{6}$|^[0-9a-fA-F]{8}$/.test(hex))\n        return\n      let r, g, b\n\n      if (hex.length === 3) {\n        r = parseHexChannel(hex[0] + hex[0])\n        g = parseHexChannel(hex[1] + hex[1])\n        b = parseHexChannel(hex[2] + hex[2])\n      } else if (hex.length === 6 || hex.length === 8) {\n        r = parseHexChannel(hex.substring(0, 2))\n        g = parseHexChannel(hex.substring(2, 4))\n        b = parseHexChannel(hex.substring(4, 6))\n      }\n\n      if (hex.length === 8) {\n        this._alpha = (parseHexChannel(hex.substring(6)) / 255) * 100\n      } else if (hex.length === 3 || hex.length === 6) {\n        this._alpha = 100\n      }\n\n      const { h, s, v } = rgb2hsv(r, g, b)\n      fromHSV(h, s, v)\n    }\n  }\n\n  compare(color) {\n    return (\n      Math.abs(color._hue - this._hue) < 2 &&\n      Math.abs(color._saturation - this._saturation) < 1 &&\n      Math.abs(color._value - this._value) < 1 &&\n      Math.abs(color._alpha - this._alpha) < 1\n    )\n  }\n\n  doOnChange() {\n    const { _hue, _saturation, _value, _alpha, format } = this\n\n    if (this.enableAlpha) {\n      switch (format) {\n        case 'hsl': {\n          const hsl = hsv2hsl(_hue, _saturation / 100, _value / 100)\n          this.value = `hsla(${_hue}, ${Math.round(\n            hsl[1] * 100\n          )}%, ${Math.round(hsl[2] * 100)}%, ${this.get('alpha') / 100})`\n          break\n        }\n        case 'hsv': {\n          this.value = `hsva(${_hue}, ${Math.round(_saturation)}%, ${Math.round(\n            _value\n          )}%, ${this.get('alpha') / 100})`\n          break\n        }\n        case 'hex': {\n          this.value = `${toHex(hsv2rgb(_hue, _saturation, _value))}${hexOne(\n            (_alpha * 255) / 100\n          )}`\n          break\n        }\n        default: {\n          const { r, g, b } = hsv2rgb(_hue, _saturation, _value)\n          this.value = `rgba(${r}, ${g}, ${b}, ${this.get('alpha') / 100})`\n        }\n      }\n    } else {\n      switch (format) {\n        case 'hsl': {\n          const hsl = hsv2hsl(_hue, _saturation / 100, _value / 100)\n          this.value = `hsl(${_hue}, ${Math.round(hsl[1] * 100)}%, ${Math.round(\n            hsl[2] * 100\n          )}%)`\n          break\n        }\n        case 'hsv': {\n          this.value = `hsv(${_hue}, ${Math.round(_saturation)}%, ${Math.round(\n            _value\n          )}%)`\n          break\n        }\n        case 'rgb': {\n          const { r, g, b } = hsv2rgb(_hue, _saturation, _value)\n          this.value = `rgb(${r}, ${g}, ${b})`\n          break\n        }\n        default: {\n          this.value = toHex(hsv2rgb(_hue, _saturation, _value))\n        }\n      }\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}