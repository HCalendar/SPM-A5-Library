{"ast":null,"code":"import { ref, computed, inject, nextTick, watch } from 'vue';\nimport debounce from 'lodash/debounce';\nimport { UPDATE_MODEL_EVENT } from '../../../utils/constants.mjs';\nimport { on, off } from '../../../utils/dom.mjs';\nconst useTooltip = (props, formatTooltip, showTooltip) => {\n  const tooltip = ref(null);\n  const tooltipVisible = ref(false);\n  const enableFormat = computed(() => {\n    return formatTooltip.value instanceof Function;\n  });\n  const formatValue = computed(() => {\n    return enableFormat.value && formatTooltip.value(props.modelValue) || props.modelValue;\n  });\n  const displayTooltip = debounce(() => {\n    showTooltip.value && (tooltipVisible.value = true);\n  }, 50);\n  const hideTooltip = debounce(() => {\n    showTooltip.value && (tooltipVisible.value = false);\n  }, 50);\n  return {\n    tooltip,\n    tooltipVisible,\n    formatValue,\n    displayTooltip,\n    hideTooltip\n  };\n};\nconst useSliderButton = (props, initData, emit) => {\n  const {\n    disabled,\n    min,\n    max,\n    step,\n    showTooltip,\n    precision,\n    sliderSize,\n    formatTooltip,\n    emitChange,\n    resetSize,\n    updateDragging\n  } = inject(\"SliderProvider\");\n  const {\n    tooltip,\n    tooltipVisible,\n    formatValue,\n    displayTooltip,\n    hideTooltip\n  } = useTooltip(props, formatTooltip, showTooltip);\n  const currentPosition = computed(() => {\n    return `${(props.modelValue - min.value) / (max.value - min.value) * 100}%`;\n  });\n  const wrapperStyle = computed(() => {\n    return props.vertical ? {\n      bottom: currentPosition.value\n    } : {\n      left: currentPosition.value\n    };\n  });\n  const handleMouseEnter = () => {\n    initData.hovering = true;\n    displayTooltip();\n  };\n  const handleMouseLeave = () => {\n    initData.hovering = false;\n    if (!initData.dragging) {\n      hideTooltip();\n    }\n  };\n  const onButtonDown = event => {\n    if (disabled.value) return;\n    event.preventDefault();\n    onDragStart(event);\n    on(window, \"mousemove\", onDragging);\n    on(window, \"touchmove\", onDragging);\n    on(window, \"mouseup\", onDragEnd);\n    on(window, \"touchend\", onDragEnd);\n    on(window, \"contextmenu\", onDragEnd);\n  };\n  const onLeftKeyDown = () => {\n    if (disabled.value) return;\n    initData.newPosition = parseFloat(currentPosition.value) - step.value / (max.value - min.value) * 100;\n    setPosition(initData.newPosition);\n    emitChange();\n  };\n  const onRightKeyDown = () => {\n    if (disabled.value) return;\n    initData.newPosition = parseFloat(currentPosition.value) + step.value / (max.value - min.value) * 100;\n    setPosition(initData.newPosition);\n    emitChange();\n  };\n  const getClientXY = event => {\n    let clientX;\n    let clientY;\n    if (event.type.startsWith(\"touch\")) {\n      clientY = event.touches[0].clientY;\n      clientX = event.touches[0].clientX;\n    } else {\n      clientY = event.clientY;\n      clientX = event.clientX;\n    }\n    return {\n      clientX,\n      clientY\n    };\n  };\n  const onDragStart = event => {\n    initData.dragging = true;\n    initData.isClick = true;\n    const {\n      clientX,\n      clientY\n    } = getClientXY(event);\n    if (props.vertical) {\n      initData.startY = clientY;\n    } else {\n      initData.startX = clientX;\n    }\n    initData.startPosition = parseFloat(currentPosition.value);\n    initData.newPosition = initData.startPosition;\n  };\n  const onDragging = event => {\n    if (initData.dragging) {\n      initData.isClick = false;\n      displayTooltip();\n      resetSize();\n      let diff;\n      const {\n        clientX,\n        clientY\n      } = getClientXY(event);\n      if (props.vertical) {\n        initData.currentY = clientY;\n        diff = (initData.startY - initData.currentY) / sliderSize.value * 100;\n      } else {\n        initData.currentX = clientX;\n        diff = (initData.currentX - initData.startX) / sliderSize.value * 100;\n      }\n      initData.newPosition = initData.startPosition + diff;\n      setPosition(initData.newPosition);\n    }\n  };\n  const onDragEnd = () => {\n    if (initData.dragging) {\n      setTimeout(() => {\n        initData.dragging = false;\n        if (!initData.hovering) {\n          hideTooltip();\n        }\n        if (!initData.isClick) {\n          setPosition(initData.newPosition);\n          emitChange();\n        }\n      }, 0);\n      off(window, \"mousemove\", onDragging);\n      off(window, \"touchmove\", onDragging);\n      off(window, \"mouseup\", onDragEnd);\n      off(window, \"touchend\", onDragEnd);\n      off(window, \"contextmenu\", onDragEnd);\n    }\n  };\n  const setPosition = async newPosition => {\n    if (newPosition === null || isNaN(newPosition)) return;\n    if (newPosition < 0) {\n      newPosition = 0;\n    } else if (newPosition > 100) {\n      newPosition = 100;\n    }\n    const lengthPerStep = 100 / ((max.value - min.value) / step.value);\n    const steps = Math.round(newPosition / lengthPerStep);\n    let value = steps * lengthPerStep * (max.value - min.value) * 0.01 + min.value;\n    value = parseFloat(value.toFixed(precision.value));\n    emit(UPDATE_MODEL_EVENT, value);\n    if (!initData.dragging && props.modelValue !== initData.oldValue) {\n      initData.oldValue = props.modelValue;\n    }\n    await nextTick();\n    initData.dragging && displayTooltip();\n    tooltip.value.updatePopper();\n  };\n  watch(() => initData.dragging, val => {\n    updateDragging(val);\n  });\n  return {\n    tooltip,\n    tooltipVisible,\n    showTooltip,\n    wrapperStyle,\n    formatValue,\n    handleMouseEnter,\n    handleMouseLeave,\n    onButtonDown,\n    onLeftKeyDown,\n    onRightKeyDown,\n    setPosition\n  };\n};\nexport { useSliderButton };","map":{"version":3,"names":["useTooltip","props","formatTooltip","showTooltip","tooltip","ref","tooltipVisible","enableFormat","computed","value","Function","formatValue","modelValue","displayTooltip","debounce","hideTooltip","useSliderButton","initData","emit","disabled","min","max","step","precision","sliderSize","emitChange","resetSize","updateDragging","inject","currentPosition","wrapperStyle","vertical","bottom","left","handleMouseEnter","hovering","handleMouseLeave","dragging","onButtonDown","event","preventDefault","onDragStart","on","window","onDragging","onDragEnd","onLeftKeyDown","newPosition","parseFloat","setPosition","onRightKeyDown","getClientXY","clientX","clientY","type","startsWith","touches","isClick","startY","startX","startPosition","diff","currentY","currentX","setTimeout","off","isNaN","lengthPerStep","steps","Math","round","toFixed","UPDATE_MODEL_EVENT","oldValue","nextTick","updatePopper","watch","val"],"sources":["../../../../../../packages/components/slider/src/useSliderButton.ts"],"sourcesContent":["import { computed, inject, nextTick, ref, watch } from 'vue'\nimport debounce from 'lodash/debounce'\nimport { UPDATE_MODEL_EVENT } from '@element-plus/utils/constants'\nimport { off, on } from '@element-plus/utils/dom'\n\nimport type { ComputedRef, CSSProperties } from 'vue'\nimport type {\n  ISliderButtonInitData,\n  ISliderButtonProps,\n  ISliderProvider,\n} from './slider.type'\n\nconst useTooltip = (\n  props: ISliderButtonProps,\n  formatTooltip: ComputedRef<(value: number) => number | string>,\n  showTooltip: ComputedRef<boolean>\n) => {\n  const tooltip = ref(null)\n\n  const tooltipVisible = ref(false)\n\n  const enableFormat = computed(() => {\n    return formatTooltip.value instanceof Function\n  })\n\n  const formatValue = computed(() => {\n    return (\n      (enableFormat.value && formatTooltip.value(props.modelValue)) ||\n      props.modelValue\n    )\n  })\n\n  const displayTooltip = debounce(() => {\n    showTooltip.value && (tooltipVisible.value = true)\n  }, 50)\n\n  const hideTooltip = debounce(() => {\n    showTooltip.value && (tooltipVisible.value = false)\n  }, 50)\n\n  return {\n    tooltip,\n    tooltipVisible,\n    formatValue,\n    displayTooltip,\n    hideTooltip,\n  }\n}\n\nexport const useSliderButton = (\n  props: ISliderButtonProps,\n  initData: ISliderButtonInitData,\n  emit\n) => {\n  const {\n    disabled,\n    min,\n    max,\n    step,\n    showTooltip,\n    precision,\n    sliderSize,\n    formatTooltip,\n    emitChange,\n    resetSize,\n    updateDragging,\n  } = inject<ISliderProvider>('SliderProvider')\n\n  const { tooltip, tooltipVisible, formatValue, displayTooltip, hideTooltip } =\n    useTooltip(props, formatTooltip, showTooltip)\n\n  const currentPosition = computed(() => {\n    return `${\n      ((props.modelValue - min.value) / (max.value - min.value)) * 100\n    }%`\n  })\n\n  const wrapperStyle = computed(() => {\n    return (\n      props.vertical\n        ? { bottom: currentPosition.value }\n        : { left: currentPosition.value }\n    ) as CSSProperties\n  })\n\n  const handleMouseEnter = () => {\n    initData.hovering = true\n    displayTooltip()\n  }\n\n  const handleMouseLeave = () => {\n    initData.hovering = false\n    if (!initData.dragging) {\n      hideTooltip()\n    }\n  }\n\n  const onButtonDown = (event: MouseEvent | TouchEvent) => {\n    if (disabled.value) return\n    event.preventDefault()\n    onDragStart(event)\n    on(window, 'mousemove', onDragging)\n    on(window, 'touchmove', onDragging)\n    on(window, 'mouseup', onDragEnd)\n    on(window, 'touchend', onDragEnd)\n    on(window, 'contextmenu', onDragEnd)\n  }\n\n  const onLeftKeyDown = () => {\n    if (disabled.value) return\n    initData.newPosition =\n      parseFloat(currentPosition.value) -\n      (step.value / (max.value - min.value)) * 100\n    setPosition(initData.newPosition)\n    emitChange()\n  }\n\n  const onRightKeyDown = () => {\n    if (disabled.value) return\n    initData.newPosition =\n      parseFloat(currentPosition.value) +\n      (step.value / (max.value - min.value)) * 100\n    setPosition(initData.newPosition)\n    emitChange()\n  }\n\n  const getClientXY = (event: MouseEvent | TouchEvent) => {\n    let clientX: number\n    let clientY: number\n    if (event.type.startsWith('touch')) {\n      clientY = (event as TouchEvent).touches[0].clientY\n      clientX = (event as TouchEvent).touches[0].clientX\n    } else {\n      clientY = (event as MouseEvent).clientY\n      clientX = (event as MouseEvent).clientX\n    }\n    return {\n      clientX,\n      clientY,\n    }\n  }\n\n  const onDragStart = (event: MouseEvent | TouchEvent) => {\n    initData.dragging = true\n    initData.isClick = true\n    const { clientX, clientY } = getClientXY(event)\n    if (props.vertical) {\n      initData.startY = clientY\n    } else {\n      initData.startX = clientX\n    }\n    initData.startPosition = parseFloat(currentPosition.value)\n    initData.newPosition = initData.startPosition\n  }\n\n  const onDragging = (event: MouseEvent | TouchEvent) => {\n    if (initData.dragging) {\n      initData.isClick = false\n      displayTooltip()\n      resetSize()\n      let diff: number\n      const { clientX, clientY } = getClientXY(event)\n      if (props.vertical) {\n        initData.currentY = clientY\n        diff = ((initData.startY - initData.currentY) / sliderSize.value) * 100\n      } else {\n        initData.currentX = clientX\n        diff = ((initData.currentX - initData.startX) / sliderSize.value) * 100\n      }\n      initData.newPosition = initData.startPosition + diff\n      setPosition(initData.newPosition)\n    }\n  }\n\n  const onDragEnd = () => {\n    if (initData.dragging) {\n      /*\n       * 防止在 mouseup 后立即触发 click，导致滑块有几率产生一小段位移\n       * 不使用 preventDefault 是因为 mouseup 和 click 没有注册在同一个 DOM 上\n       */\n      setTimeout(() => {\n        initData.dragging = false\n        if (!initData.hovering) {\n          hideTooltip()\n        }\n        if (!initData.isClick) {\n          setPosition(initData.newPosition)\n          emitChange()\n        }\n      }, 0)\n      off(window, 'mousemove', onDragging)\n      off(window, 'touchmove', onDragging)\n      off(window, 'mouseup', onDragEnd)\n      off(window, 'touchend', onDragEnd)\n      off(window, 'contextmenu', onDragEnd)\n    }\n  }\n\n  const setPosition = async (newPosition: number) => {\n    if (newPosition === null || isNaN(newPosition)) return\n    if (newPosition < 0) {\n      newPosition = 0\n    } else if (newPosition > 100) {\n      newPosition = 100\n    }\n    const lengthPerStep = 100 / ((max.value - min.value) / step.value)\n    const steps = Math.round(newPosition / lengthPerStep)\n    let value =\n      steps * lengthPerStep * (max.value - min.value) * 0.01 + min.value\n    value = parseFloat(value.toFixed(precision.value))\n    emit(UPDATE_MODEL_EVENT, value)\n\n    if (!initData.dragging && props.modelValue !== initData.oldValue) {\n      initData.oldValue = props.modelValue\n    }\n\n    await nextTick()\n    initData.dragging && displayTooltip()\n    tooltip.value.updatePopper()\n  }\n\n  watch(\n    () => initData.dragging,\n    (val) => {\n      updateDragging(val)\n    }\n  )\n\n  return {\n    tooltip,\n    tooltipVisible,\n    showTooltip,\n    wrapperStyle,\n    formatValue,\n    handleMouseEnter,\n    handleMouseLeave,\n    onButtonDown,\n    onLeftKeyDown,\n    onRightKeyDown,\n    setPosition,\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}