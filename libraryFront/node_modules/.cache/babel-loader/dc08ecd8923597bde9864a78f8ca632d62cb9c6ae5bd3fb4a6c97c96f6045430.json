{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { ref, isRef, nextTick } from 'vue';\nimport { hasOwn } from '@vue/shared';\nimport scrollbarWidth from '../../../utils/scrollbar-width.mjs';\nimport isServer from '../../../utils/isServer.mjs';\nimport { parseHeight } from './util.mjs';\nclass TableLayout {\n  constructor(options) {\n    this.observers = [];\n    this.table = null;\n    this.store = null;\n    this.columns = [];\n    this.fit = true;\n    this.showHeader = true;\n    this.height = ref(null);\n    this.scrollX = ref(false);\n    this.scrollY = ref(false);\n    this.bodyWidth = ref(null);\n    this.fixedWidth = ref(null);\n    this.rightFixedWidth = ref(null);\n    this.tableHeight = ref(null);\n    this.headerHeight = ref(44);\n    this.appendHeight = ref(0);\n    this.footerHeight = ref(44);\n    this.viewportHeight = ref(null);\n    this.bodyHeight = ref(null);\n    this.fixedBodyHeight = ref(null);\n    this.gutterWidth = scrollbarWidth();\n    for (const name in options) {\n      if (hasOwn(options, name)) {\n        if (isRef(this[name])) {\n          this[name].value = options[name];\n        } else {\n          this[name] = options[name];\n        }\n      }\n    }\n    if (!this.table) {\n      throw new Error(\"Table is required for Table Layout\");\n    }\n    if (!this.store) {\n      throw new Error(\"Store is required for Table Layout\");\n    }\n  }\n  updateScrollY() {\n    const height = this.height.value;\n    if (height === null) return false;\n    const bodyWrapper = this.table.refs.bodyWrapper;\n    if (this.table.vnode.el && bodyWrapper) {\n      let scrollY = true;\n      const prevScrollY = this.scrollY.value;\n      if (this.bodyHeight.value === null) {\n        scrollY = false;\n      } else {\n        const body = bodyWrapper.querySelector(\".el-table__body\");\n        scrollY = body.offsetHeight > this.bodyHeight.value;\n      }\n      this.scrollY.value = scrollY;\n      return prevScrollY !== scrollY;\n    }\n    return false;\n  }\n  setHeight(value, prop = \"height\") {\n    if (isServer) return;\n    const el = this.table.vnode.el;\n    value = parseHeight(value);\n    this.height.value = Number(value);\n    if (!el && (value || value === 0)) return nextTick(() => this.setHeight(value, prop));\n    if (typeof value === \"number\") {\n      el.style[prop] = `${value}px`;\n      this.updateElsHeight();\n    } else if (typeof value === \"string\") {\n      el.style[prop] = value;\n      this.updateElsHeight();\n    }\n  }\n  setMaxHeight(value) {\n    this.setHeight(value, \"max-height\");\n  }\n  getFlattenColumns() {\n    const flattenColumns = [];\n    const columns = this.table.store.states.columns.value;\n    columns.forEach(column => {\n      if (column.isColumnGroup) {\n        flattenColumns.push.apply(flattenColumns, column.columns);\n      } else {\n        flattenColumns.push(column);\n      }\n    });\n    return flattenColumns;\n  }\n  updateElsHeight() {\n    if (!this.table.$ready) return nextTick(() => this.updateElsHeight());\n    const {\n      headerWrapper,\n      appendWrapper,\n      footerWrapper\n    } = this.table.refs;\n    this.appendHeight.value = appendWrapper ? appendWrapper.offsetHeight : 0;\n    if (this.showHeader && !headerWrapper) return;\n    const headerTrElm = headerWrapper ? headerWrapper.querySelector(\".el-table__header tr\") : null;\n    const noneHeader = this.headerDisplayNone(headerTrElm);\n    const headerHeight = this.headerHeight.value = !this.showHeader ? 0 : headerWrapper.offsetHeight;\n    if (this.showHeader && !noneHeader && headerWrapper.offsetWidth > 0 && (this.table.store.states.columns.value || []).length > 0 && headerHeight < 2) {\n      return nextTick(() => this.updateElsHeight());\n    }\n    const tableHeight = this.tableHeight.value = this.table.vnode.el.clientHeight;\n    const footerHeight = this.footerHeight.value = footerWrapper ? footerWrapper.offsetHeight : 0;\n    if (this.height.value !== null) {\n      this.bodyHeight.value = tableHeight - headerHeight - footerHeight + (footerWrapper ? 1 : 0);\n    }\n    this.fixedBodyHeight.value = this.scrollX.value ? this.bodyHeight.value - this.gutterWidth : this.bodyHeight.value;\n    this.viewportHeight.value = this.scrollX.value ? tableHeight - this.gutterWidth : tableHeight;\n    this.updateScrollY();\n    this.notifyObservers(\"scrollable\");\n  }\n  headerDisplayNone(elm) {\n    if (!elm) return true;\n    let headerChild = elm;\n    while (headerChild.tagName !== \"DIV\") {\n      if (getComputedStyle(headerChild).display === \"none\") {\n        return true;\n      }\n      headerChild = headerChild.parentElement;\n    }\n    return false;\n  }\n  updateColumnsWidth() {\n    if (isServer) return;\n    const fit = this.fit;\n    const bodyWidth = this.table.vnode.el.clientWidth;\n    let bodyMinWidth = 0;\n    const flattenColumns = this.getFlattenColumns();\n    const flexColumns = flattenColumns.filter(column => typeof column.width !== \"number\");\n    flattenColumns.forEach(column => {\n      if (typeof column.width === \"number\" && column.realWidth) column.realWidth = null;\n    });\n    if (flexColumns.length > 0 && fit) {\n      flattenColumns.forEach(column => {\n        bodyMinWidth += Number(column.width || column.minWidth || 80);\n      });\n      const scrollYWidth = this.scrollY.value ? this.gutterWidth : 0;\n      if (bodyMinWidth <= bodyWidth - scrollYWidth) {\n        this.scrollX.value = false;\n        const totalFlexWidth = bodyWidth - scrollYWidth - bodyMinWidth;\n        if (flexColumns.length === 1) {\n          flexColumns[0].realWidth = Number(flexColumns[0].minWidth || 80) + totalFlexWidth;\n        } else {\n          const allColumnsWidth = flexColumns.reduce((prev, column) => prev + Number(column.minWidth || 80), 0);\n          const flexWidthPerPixel = totalFlexWidth / allColumnsWidth;\n          let noneFirstWidth = 0;\n          flexColumns.forEach((column, index) => {\n            if (index === 0) return;\n            const flexWidth = Math.floor(Number(column.minWidth || 80) * flexWidthPerPixel);\n            noneFirstWidth += flexWidth;\n            column.realWidth = Number(column.minWidth || 80) + flexWidth;\n          });\n          flexColumns[0].realWidth = Number(flexColumns[0].minWidth || 80) + totalFlexWidth - noneFirstWidth;\n        }\n      } else {\n        this.scrollX.value = true;\n        flexColumns.forEach(function (column) {\n          column.realWidth = Number(column.minWidth);\n        });\n      }\n      this.bodyWidth.value = Math.max(bodyMinWidth, bodyWidth);\n      this.table.state.resizeState.value.width = this.bodyWidth.value;\n    } else {\n      flattenColumns.forEach(column => {\n        if (!column.width && !column.minWidth) {\n          column.realWidth = 80;\n        } else {\n          column.realWidth = Number(column.width || column.minWidth);\n        }\n        bodyMinWidth += column.realWidth;\n      });\n      this.scrollX.value = bodyMinWidth > bodyWidth;\n      this.bodyWidth.value = bodyMinWidth;\n    }\n    const fixedColumns = this.store.states.fixedColumns.value;\n    if (fixedColumns.length > 0) {\n      let fixedWidth = 0;\n      fixedColumns.forEach(function (column) {\n        fixedWidth += Number(column.realWidth || column.width);\n      });\n      this.fixedWidth.value = fixedWidth;\n    }\n    const rightFixedColumns = this.store.states.rightFixedColumns.value;\n    if (rightFixedColumns.length > 0) {\n      let rightFixedWidth = 0;\n      rightFixedColumns.forEach(function (column) {\n        rightFixedWidth += Number(column.realWidth || column.width);\n      });\n      this.rightFixedWidth.value = rightFixedWidth;\n    }\n    this.notifyObservers(\"columns\");\n  }\n  addObserver(observer) {\n    this.observers.push(observer);\n  }\n  removeObserver(observer) {\n    const index = this.observers.indexOf(observer);\n    if (index !== -1) {\n      this.observers.splice(index, 1);\n    }\n  }\n  notifyObservers(event) {\n    const observers = this.observers;\n    observers.forEach(observer => {\n      var _a, _b;\n      switch (event) {\n        case \"columns\":\n          (_a = observer.state) == null ? void 0 : _a.onColumnsChange(this);\n          break;\n        case \"scrollable\":\n          (_b = observer.state) == null ? void 0 : _b.onScrollableChange(this);\n          break;\n        default:\n          throw new Error(`Table Layout don't have event ${event}.`);\n      }\n    });\n  }\n}\nexport { TableLayout as default };","map":{"version":3,"names":["TableLayout","constructor","options","observers","table","store","columns","fit","showHeader","height","ref","scrollX","scrollY","bodyWidth","fixedWidth","rightFixedWidth","tableHeight","headerHeight","appendHeight","footerHeight","viewportHeight","bodyHeight","fixedBodyHeight","gutterWidth","scrollbarWidth","name","hasOwn","isRef","value","Error","updateScrollY","bodyWrapper","refs","vnode","el","prevScrollY","body","querySelector","offsetHeight","setHeight","prop","isServer","parseHeight","Number","nextTick","style","updateElsHeight","setMaxHeight","getFlattenColumns","flattenColumns","states","forEach","column","isColumnGroup","push","apply","$ready","headerWrapper","appendWrapper","footerWrapper","headerTrElm","noneHeader","headerDisplayNone","offsetWidth","length","clientHeight","notifyObservers","elm","headerChild","tagName","getComputedStyle","display","parentElement","updateColumnsWidth","clientWidth","bodyMinWidth","flexColumns","filter","width","realWidth","minWidth","scrollYWidth","totalFlexWidth","allColumnsWidth","reduce","prev","flexWidthPerPixel","noneFirstWidth","index","flexWidth","Math","floor","max","state","resizeState","fixedColumns","rightFixedColumns","addObserver","observer","removeObserver","indexOf","splice","event","_a","_b","onColumnsChange","onScrollableChange"],"sources":["../../../../../../packages/components/table/src/table-layout.ts"],"sourcesContent":["import { nextTick, ref, isRef } from 'vue'\nimport { hasOwn } from '@vue/shared'\nimport scrollbarWidth from '@element-plus/utils/scrollbar-width'\nimport isServer from '@element-plus/utils/isServer'\nimport { parseHeight } from './util'\nimport type { Ref } from 'vue'\n\nimport type { TableColumnCtx } from './table-column/defaults'\nimport type { TableHeader } from './table-header'\nimport type { Table } from './table/defaults'\nimport type { Store } from './store'\nclass TableLayout<T> {\n  observers: TableHeader[]\n  table: Table<T>\n  store: Store<T>\n  columns: TableColumnCtx<T>[]\n  fit: boolean\n  showHeader: boolean\n\n  height: Ref<null | number>\n  scrollX: Ref<boolean>\n  scrollY: Ref<boolean>\n  bodyWidth: Ref<null | number>\n  fixedWidth: Ref<null | number>\n  rightFixedWidth: Ref<null | number>\n  tableHeight: Ref<null | number>\n  headerHeight: Ref<null | number> // Table Header Height\n  appendHeight: Ref<null | number> // Append Slot Height\n  footerHeight: Ref<null | number> // Table Footer Height\n  viewportHeight: Ref<null | number> // Table Height - Scroll Bar Height\n  bodyHeight: Ref<null | number> // Table Height - Table Header Height\n  fixedBodyHeight: Ref<null | number> // Table Height - Table Header Height - Scroll Bar Height\n  gutterWidth: number\n  constructor(options: Record<string, any>) {\n    this.observers = []\n    this.table = null\n    this.store = null\n    this.columns = []\n    this.fit = true\n    this.showHeader = true\n    this.height = ref(null)\n    this.scrollX = ref(false)\n    this.scrollY = ref(false)\n    this.bodyWidth = ref(null)\n    this.fixedWidth = ref(null)\n    this.rightFixedWidth = ref(null)\n    this.tableHeight = ref(null)\n    this.headerHeight = ref(44)\n    this.appendHeight = ref(0)\n    this.footerHeight = ref(44)\n    this.viewportHeight = ref(null)\n    this.bodyHeight = ref(null)\n    this.fixedBodyHeight = ref(null)\n    this.gutterWidth = scrollbarWidth()\n    for (const name in options) {\n      if (hasOwn(options, name)) {\n        if (isRef(this[name])) {\n          this[name as string].value = options[name]\n        } else {\n          this[name as string] = options[name]\n        }\n      }\n    }\n    if (!this.table) {\n      throw new Error('Table is required for Table Layout')\n    }\n    if (!this.store) {\n      throw new Error('Store is required for Table Layout')\n    }\n  }\n\n  updateScrollY() {\n    const height = this.height.value\n    /**\n     * When the height is not initialized, it is null.\n     * After the table is initialized, when the height is not configured, the height is 0.\n     */\n    if (height === null) return false\n    const bodyWrapper = this.table.refs.bodyWrapper as HTMLElement\n    if (this.table.vnode.el && bodyWrapper) {\n      let scrollY = true\n      const prevScrollY = this.scrollY.value\n      /**\n       * When bodyHeight has no value,\n       * it means that the table height is not set,\n       * and the scroll bar will never appear\n       */\n      if (this.bodyHeight.value === null) {\n        scrollY = false\n      } else {\n        const body = bodyWrapper.querySelector('.el-table__body') as HTMLElement\n        scrollY = body.offsetHeight > this.bodyHeight.value\n      }\n      this.scrollY.value = scrollY\n      return prevScrollY !== scrollY\n    }\n    return false\n  }\n\n  setHeight(value: string | number, prop = 'height') {\n    if (isServer) return\n    const el = this.table.vnode.el\n    value = parseHeight(value)\n    this.height.value = Number(value)\n\n    if (!el && (value || value === 0))\n      return nextTick(() => this.setHeight(value, prop))\n\n    if (typeof value === 'number') {\n      el.style[prop] = `${value}px`\n      this.updateElsHeight()\n    } else if (typeof value === 'string') {\n      el.style[prop] = value\n      this.updateElsHeight()\n    }\n  }\n\n  setMaxHeight(value: string | number) {\n    this.setHeight(value, 'max-height')\n  }\n\n  getFlattenColumns(): TableColumnCtx<T>[] {\n    const flattenColumns = []\n    const columns = this.table.store.states.columns.value\n    columns.forEach((column) => {\n      if (column.isColumnGroup) {\n        // eslint-disable-next-line prefer-spread\n        flattenColumns.push.apply(flattenColumns, column.columns)\n      } else {\n        flattenColumns.push(column)\n      }\n    })\n\n    return flattenColumns\n  }\n\n  updateElsHeight() {\n    if (!this.table.$ready) return nextTick(() => this.updateElsHeight())\n    const { headerWrapper, appendWrapper, footerWrapper } = this.table.refs\n    this.appendHeight.value = appendWrapper ? appendWrapper.offsetHeight : 0\n    if (this.showHeader && !headerWrapper) return\n\n    const headerTrElm: HTMLElement = headerWrapper\n      ? headerWrapper.querySelector('.el-table__header tr')\n      : null\n    const noneHeader = this.headerDisplayNone(headerTrElm)\n\n    const headerHeight = (this.headerHeight.value = !this.showHeader\n      ? 0\n      : headerWrapper.offsetHeight)\n    if (\n      this.showHeader &&\n      !noneHeader &&\n      headerWrapper.offsetWidth > 0 &&\n      (this.table.store.states.columns.value || []).length > 0 &&\n      headerHeight < 2\n    ) {\n      return nextTick(() => this.updateElsHeight())\n    }\n    const tableHeight = (this.tableHeight.value =\n      this.table.vnode.el.clientHeight)\n    const footerHeight = (this.footerHeight.value = footerWrapper\n      ? footerWrapper.offsetHeight\n      : 0)\n    if (this.height.value !== null) {\n      this.bodyHeight.value =\n        tableHeight - headerHeight - footerHeight + (footerWrapper ? 1 : 0)\n    }\n    this.fixedBodyHeight.value = this.scrollX.value\n      ? this.bodyHeight.value - this.gutterWidth\n      : this.bodyHeight.value\n\n    this.viewportHeight.value = this.scrollX.value\n      ? tableHeight - this.gutterWidth\n      : tableHeight\n\n    this.updateScrollY()\n    this.notifyObservers('scrollable')\n  }\n\n  headerDisplayNone(elm: HTMLElement) {\n    if (!elm) return true\n    let headerChild = elm\n    while (headerChild.tagName !== 'DIV') {\n      if (getComputedStyle(headerChild).display === 'none') {\n        return true\n      }\n      headerChild = headerChild.parentElement\n    }\n    return false\n  }\n\n  updateColumnsWidth() {\n    if (isServer) return\n    const fit = this.fit\n    const bodyWidth = this.table.vnode.el.clientWidth\n    let bodyMinWidth = 0\n\n    const flattenColumns = this.getFlattenColumns()\n    const flexColumns = flattenColumns.filter(\n      (column) => typeof column.width !== 'number'\n    )\n    flattenColumns.forEach((column) => {\n      // Clean those columns whose width changed from flex to unflex\n      if (typeof column.width === 'number' && column.realWidth)\n        column.realWidth = null\n    })\n    if (flexColumns.length > 0 && fit) {\n      flattenColumns.forEach((column) => {\n        bodyMinWidth += Number(column.width || column.minWidth || 80)\n      })\n\n      const scrollYWidth = this.scrollY.value ? this.gutterWidth : 0\n\n      if (bodyMinWidth <= bodyWidth - scrollYWidth) {\n        // DON'T HAVE SCROLL BAR\n        this.scrollX.value = false\n\n        const totalFlexWidth = bodyWidth - scrollYWidth - bodyMinWidth\n\n        if (flexColumns.length === 1) {\n          flexColumns[0].realWidth =\n            Number(flexColumns[0].minWidth || 80) + totalFlexWidth\n        } else {\n          const allColumnsWidth = flexColumns.reduce(\n            (prev, column) => prev + Number(column.minWidth || 80),\n            0\n          )\n          const flexWidthPerPixel = totalFlexWidth / allColumnsWidth\n          let noneFirstWidth = 0\n\n          flexColumns.forEach((column, index) => {\n            if (index === 0) return\n            const flexWidth = Math.floor(\n              Number(column.minWidth || 80) * flexWidthPerPixel\n            )\n            noneFirstWidth += flexWidth\n            column.realWidth = Number(column.minWidth || 80) + flexWidth\n          })\n\n          flexColumns[0].realWidth =\n            Number(flexColumns[0].minWidth || 80) +\n            totalFlexWidth -\n            noneFirstWidth\n        }\n      } else {\n        // HAVE HORIZONTAL SCROLL BAR\n        this.scrollX.value = true\n        flexColumns.forEach(function (column) {\n          column.realWidth = Number(column.minWidth)\n        })\n      }\n\n      this.bodyWidth.value = Math.max(bodyMinWidth, bodyWidth)\n      this.table.state.resizeState.value.width = this.bodyWidth.value\n    } else {\n      flattenColumns.forEach((column) => {\n        if (!column.width && !column.minWidth) {\n          column.realWidth = 80\n        } else {\n          column.realWidth = Number(column.width || column.minWidth)\n        }\n        bodyMinWidth += column.realWidth\n      })\n      this.scrollX.value = bodyMinWidth > bodyWidth\n\n      this.bodyWidth.value = bodyMinWidth\n    }\n\n    const fixedColumns = this.store.states.fixedColumns.value\n\n    if (fixedColumns.length > 0) {\n      let fixedWidth = 0\n      fixedColumns.forEach(function (column) {\n        fixedWidth += Number(column.realWidth || column.width)\n      })\n\n      this.fixedWidth.value = fixedWidth\n    }\n\n    const rightFixedColumns = this.store.states.rightFixedColumns.value\n    if (rightFixedColumns.length > 0) {\n      let rightFixedWidth = 0\n      rightFixedColumns.forEach(function (column) {\n        rightFixedWidth += Number(column.realWidth || column.width)\n      })\n\n      this.rightFixedWidth.value = rightFixedWidth\n    }\n    this.notifyObservers('columns')\n  }\n\n  addObserver(observer: TableHeader) {\n    this.observers.push(observer)\n  }\n\n  removeObserver(observer: TableHeader) {\n    const index = this.observers.indexOf(observer)\n    if (index !== -1) {\n      this.observers.splice(index, 1)\n    }\n  }\n\n  notifyObservers(event: string) {\n    const observers = this.observers\n    observers.forEach((observer) => {\n      switch (event) {\n        case 'columns':\n          observer.state?.onColumnsChange(this)\n          break\n        case 'scrollable':\n          observer.state?.onScrollableChange(this)\n          break\n        default:\n          throw new Error(`Table Layout don't have event ${event}.`)\n      }\n    })\n  }\n}\n\nexport default TableLayout\n"],"mappings":";;;;;;AAWA,MAAAA,WAAA,CAAqB;EAsBnBC,YAAYC,OAAA,EAA8B;IACxC,KAAKC,SAAA,GAAY;IACjB,KAAKC,KAAA,GAAQ;IACb,KAAKC,KAAA,GAAQ;IACb,KAAKC,OAAA,GAAU;IACf,KAAKC,GAAA,GAAM;IACX,KAAKC,UAAA,GAAa;IAClB,KAAKC,MAAA,GAASC,GAAA,CAAI;IAClB,KAAKC,OAAA,GAAUD,GAAA,CAAI;IACnB,KAAKE,OAAA,GAAUF,GAAA,CAAI;IACnB,KAAKG,SAAA,GAAYH,GAAA,CAAI;IACrB,KAAKI,UAAA,GAAaJ,GAAA,CAAI;IACtB,KAAKK,eAAA,GAAkBL,GAAA,CAAI;IAC3B,KAAKM,WAAA,GAAcN,GAAA,CAAI;IACvB,KAAKO,YAAA,GAAeP,GAAA,CAAI;IACxB,KAAKQ,YAAA,GAAeR,GAAA,CAAI;IACxB,KAAKS,YAAA,GAAeT,GAAA,CAAI;IACxB,KAAKU,cAAA,GAAiBV,GAAA,CAAI;IAC1B,KAAKW,UAAA,GAAaX,GAAA,CAAI;IACtB,KAAKY,eAAA,GAAkBZ,GAAA,CAAI;IAC3B,KAAKa,WAAA,GAAcC,cAAA;IACnB,WAAWC,IAAA,IAAQvB,OAAA,EAAS;MAC1B,IAAIwB,MAAA,CAAOxB,OAAA,EAASuB,IAAA,GAAO;QACzB,IAAIE,KAAA,CAAM,KAAKF,IAAA,IAAQ;UACrB,KAAKA,IAAA,EAAgBG,KAAA,GAAQ1B,OAAA,CAAQuB,IAAA;QAAA,OAChC;UACL,KAAKA,IAAA,IAAkBvB,OAAA,CAAQuB,IAAA;QAAA;MAAA;IAAA;IAIrC,IAAI,CAAC,KAAKrB,KAAA,EAAO;MACf,MAAM,IAAIyB,KAAA,CAAM;IAAA;IAElB,IAAI,CAAC,KAAKxB,KAAA,EAAO;MACf,MAAM,IAAIwB,KAAA,CAAM;IAAA;EAAA;EAIpBC,cAAA,EAAgB;IACd,MAAMrB,MAAA,GAAS,KAAKA,MAAA,CAAOmB,KAAA;IAK3B,IAAInB,MAAA,KAAW,MAAM,OAAO;IAC5B,MAAMsB,WAAA,GAAc,KAAK3B,KAAA,CAAM4B,IAAA,CAAKD,WAAA;IACpC,IAAI,KAAK3B,KAAA,CAAM6B,KAAA,CAAMC,EAAA,IAAMH,WAAA,EAAa;MACtC,IAAInB,OAAA,GAAU;MACd,MAAMuB,WAAA,GAAc,KAAKvB,OAAA,CAAQgB,KAAA;MAMjC,IAAI,KAAKP,UAAA,CAAWO,KAAA,KAAU,MAAM;QAClChB,OAAA,GAAU;MAAA,OACL;QACL,MAAMwB,IAAA,GAAOL,WAAA,CAAYM,aAAA,CAAc;QACvCzB,OAAA,GAAUwB,IAAA,CAAKE,YAAA,GAAe,KAAKjB,UAAA,CAAWO,KAAA;MAAA;MAEhD,KAAKhB,OAAA,CAAQgB,KAAA,GAAQhB,OAAA;MACrB,OAAOuB,WAAA,KAAgBvB,OAAA;IAAA;IAEzB,OAAO;EAAA;EAGT2B,UAAUX,KAAA,EAAwBY,IAAA,GAAO,UAAU;IACjD,IAAIC,QAAA,EAAU;IACd,MAAMP,EAAA,GAAK,KAAK9B,KAAA,CAAM6B,KAAA,CAAMC,EAAA;IAC5BN,KAAA,GAAQc,WAAA,CAAYd,KAAA;IACpB,KAAKnB,MAAA,CAAOmB,KAAA,GAAQe,MAAA,CAAOf,KAAA;IAE3B,IAAI,CAACM,EAAA,KAAAN,KAAA,IAAgBA,KAAA,KAAU,IAC7B,OAAOgB,QAAA,CAAS,MAAM,KAAKL,SAAA,CAAUX,KAAA,EAAOY,IAAA;IAE9C,IAAI,OAAOZ,KAAA,KAAU,UAAU;MAC7BM,EAAA,CAAGW,KAAA,CAAML,IAAA,IAAQ,GAAGZ,KAAA;MACpB,KAAKkB,eAAA;IAAA,WACI,OAAOlB,KAAA,KAAU,UAAU;MACpCM,EAAA,CAAGW,KAAA,CAAML,IAAA,IAAQZ,KAAA;MACjB,KAAKkB,eAAA;IAAA;EAAA;EAITC,aAAanB,KAAA,EAAwB;IACnC,KAAKW,SAAA,CAAUX,KAAA,EAAO;EAAA;EAGxBoB,kBAAA,EAAyC;IACvC,MAAMC,cAAA,GAAiB;IACvB,MAAM3C,OAAA,GAAU,KAAKF,KAAA,CAAMC,KAAA,CAAM6C,MAAA,CAAO5C,OAAA,CAAQsB,KAAA;IAChDtB,OAAA,CAAQ6C,OAAA,CAASC,MAAA,IAAW;MAC1B,IAAIA,MAAA,CAAOC,aAAA,EAAe;QAExBJ,cAAA,CAAeK,IAAA,CAAKC,KAAA,CAAMN,cAAA,EAAgBG,MAAA,CAAO9C,OAAA;MAAA,OAC5C;QACL2C,cAAA,CAAeK,IAAA,CAAKF,MAAA;MAAA;IAAA;IAIxB,OAAOH,cAAA;EAAA;EAGTH,gBAAA,EAAkB;IAChB,IAAI,CAAC,KAAK1C,KAAA,CAAMoD,MAAA,EAAQ,OAAOZ,QAAA,CAAS,MAAM,KAAKE,eAAA;IACnD,MAAM;MAAEW,aAAA;MAAeC,aAAA;MAAeC;IAAA,IAAkB,KAAKvD,KAAA,CAAM4B,IAAA;IACnE,KAAKd,YAAA,CAAaU,KAAA,GAAQ8B,aAAA,GAAgBA,aAAA,CAAcpB,YAAA,GAAe;IACvE,IAAI,KAAK9B,UAAA,IAAc,CAACiD,aAAA,EAAe;IAEvC,MAAMG,WAAA,GAA2BH,aAAA,GAC7BA,aAAA,CAAcpB,aAAA,CAAc,0BAC5B;IACJ,MAAMwB,UAAA,GAAa,KAAKC,iBAAA,CAAkBF,WAAA;IAE1C,MAAM3C,YAAA,GAAgB,KAAKA,YAAA,CAAaW,KAAA,GAAQ,CAAC,KAAKpB,UAAA,GAClD,IACAiD,aAAA,CAAcnB,YAAA;IAClB,IACE,KAAK9B,UAAA,IACL,CAACqD,UAAA,IACDJ,aAAA,CAAcM,WAAA,GAAc,KAC3B,MAAK3D,KAAA,CAAMC,KAAA,CAAM6C,MAAA,CAAO5C,OAAA,CAAQsB,KAAA,IAAS,IAAIoC,MAAA,GAAS,KACvD/C,YAAA,GAAe,GACf;MACA,OAAO2B,QAAA,CAAS,MAAM,KAAKE,eAAA;IAAA;IAE7B,MAAM9B,WAAA,GAAe,KAAKA,WAAA,CAAYY,KAAA,GACpC,KAAKxB,KAAA,CAAM6B,KAAA,CAAMC,EAAA,CAAG+B,YAAA;IACtB,MAAM9C,YAAA,GAAgB,KAAKA,YAAA,CAAaS,KAAA,GAAQ+B,aAAA,GAC5CA,aAAA,CAAcrB,YAAA,GACd;IACJ,IAAI,KAAK7B,MAAA,CAAOmB,KAAA,KAAU,MAAM;MAC9B,KAAKP,UAAA,CAAWO,KAAA,GACdZ,WAAA,GAAcC,YAAA,GAAeE,YAAA,IAAAwC,aAAA,GAAgC,IAAI;IAAA;IAErE,KAAKrC,eAAA,CAAgBM,KAAA,GAAQ,KAAKjB,OAAA,CAAQiB,KAAA,GACtC,KAAKP,UAAA,CAAWO,KAAA,GAAQ,KAAKL,WAAA,GAC7B,KAAKF,UAAA,CAAWO,KAAA;IAEpB,KAAKR,cAAA,CAAeQ,KAAA,GAAQ,KAAKjB,OAAA,CAAQiB,KAAA,GACrCZ,WAAA,GAAc,KAAKO,WAAA,GACnBP,WAAA;IAEJ,KAAKc,aAAA;IACL,KAAKoC,eAAA,CAAgB;EAAA;EAGvBJ,kBAAkBK,GAAA,EAAkB;IAClC,IAAI,CAACA,GAAA,EAAK,OAAO;IACjB,IAAIC,WAAA,GAAcD,GAAA;IAClB,OAAOC,WAAA,CAAYC,OAAA,KAAY,OAAO;MACpC,IAAIC,gBAAA,CAAiBF,WAAA,EAAaG,OAAA,KAAY,QAAQ;QACpD,OAAO;MAAA;MAETH,WAAA,GAAcA,WAAA,CAAYI,aAAA;IAAA;IAE5B,OAAO;EAAA;EAGTC,mBAAA,EAAqB;IACnB,IAAIhC,QAAA,EAAU;IACd,MAAMlC,GAAA,GAAM,KAAKA,GAAA;IACjB,MAAMM,SAAA,GAAY,KAAKT,KAAA,CAAM6B,KAAA,CAAMC,EAAA,CAAGwC,WAAA;IACtC,IAAIC,YAAA,GAAe;IAEnB,MAAM1B,cAAA,GAAiB,KAAKD,iBAAA;IAC5B,MAAM4B,WAAA,GAAc3B,cAAA,CAAe4B,MAAA,CAChCzB,MAAA,IAAW,OAAOA,MAAA,CAAO0B,KAAA,KAAU;IAEtC7B,cAAA,CAAeE,OAAA,CAASC,MAAA,IAAW;MAEjC,IAAI,OAAOA,MAAA,CAAO0B,KAAA,KAAU,YAAY1B,MAAA,CAAO2B,SAAA,EAC7C3B,MAAA,CAAO2B,SAAA,GAAY;IAAA;IAEvB,IAAIH,WAAA,CAAYZ,MAAA,GAAS,KAAKzD,GAAA,EAAK;MACjC0C,cAAA,CAAeE,OAAA,CAASC,MAAA,IAAW;QACjCuB,YAAA,IAAgBhC,MAAA,CAAOS,MAAA,CAAO0B,KAAA,IAAS1B,MAAA,CAAO4B,QAAA,IAAY;MAAA;MAG5D,MAAMC,YAAA,GAAe,KAAKrE,OAAA,CAAQgB,KAAA,GAAQ,KAAKL,WAAA,GAAc;MAE7D,IAAIoD,YAAA,IAAgB9D,SAAA,GAAYoE,YAAA,EAAc;QAE5C,KAAKtE,OAAA,CAAQiB,KAAA,GAAQ;QAErB,MAAMsD,cAAA,GAAiBrE,SAAA,GAAYoE,YAAA,GAAeN,YAAA;QAElD,IAAIC,WAAA,CAAYZ,MAAA,KAAW,GAAG;UAC5BY,WAAA,CAAY,GAAGG,SAAA,GACbpC,MAAA,CAAOiC,WAAA,CAAY,GAAGI,QAAA,IAAY,MAAME,cAAA;QAAA,OACrC;UACL,MAAMC,eAAA,GAAkBP,WAAA,CAAYQ,MAAA,CAClC,CAACC,IAAA,EAAMjC,MAAA,KAAWiC,IAAA,GAAO1C,MAAA,CAAOS,MAAA,CAAO4B,QAAA,IAAY,KACnD;UAEF,MAAMM,iBAAA,GAAoBJ,cAAA,GAAiBC,eAAA;UAC3C,IAAII,cAAA,GAAiB;UAErBX,WAAA,CAAYzB,OAAA,CAAQ,CAACC,MAAA,EAAQoC,KAAA,KAAU;YACrC,IAAIA,KAAA,KAAU,GAAG;YACjB,MAAMC,SAAA,GAAYC,IAAA,CAAKC,KAAA,CACrBhD,MAAA,CAAOS,MAAA,CAAO4B,QAAA,IAAY,MAAMM,iBAAA;YAElCC,cAAA,IAAkBE,SAAA;YAClBrC,MAAA,CAAO2B,SAAA,GAAYpC,MAAA,CAAOS,MAAA,CAAO4B,QAAA,IAAY,MAAMS,SAAA;UAAA;UAGrDb,WAAA,CAAY,GAAGG,SAAA,GACbpC,MAAA,CAAOiC,WAAA,CAAY,GAAGI,QAAA,IAAY,MAClCE,cAAA,GACAK,cAAA;QAAA;MAAA,OAEC;QAEL,KAAK5E,OAAA,CAAQiB,KAAA,GAAQ;QACrBgD,WAAA,CAAYzB,OAAA,CAAQ,UAAUC,MAAA,EAAQ;UACpCA,MAAA,CAAO2B,SAAA,GAAYpC,MAAA,CAAOS,MAAA,CAAO4B,QAAA;QAAA;MAAA;MAIrC,KAAKnE,SAAA,CAAUe,KAAA,GAAQ8D,IAAA,CAAKE,GAAA,CAAIjB,YAAA,EAAc9D,SAAA;MAC9C,KAAKT,KAAA,CAAMyF,KAAA,CAAMC,WAAA,CAAYlE,KAAA,CAAMkD,KAAA,GAAQ,KAAKjE,SAAA,CAAUe,KAAA;IAAA,OACrD;MACLqB,cAAA,CAAeE,OAAA,CAASC,MAAA,IAAW;QACjC,IAAI,CAACA,MAAA,CAAO0B,KAAA,IAAS,CAAC1B,MAAA,CAAO4B,QAAA,EAAU;UACrC5B,MAAA,CAAO2B,SAAA,GAAY;QAAA,OACd;UACL3B,MAAA,CAAO2B,SAAA,GAAYpC,MAAA,CAAOS,MAAA,CAAO0B,KAAA,IAAS1B,MAAA,CAAO4B,QAAA;QAAA;QAEnDL,YAAA,IAAgBvB,MAAA,CAAO2B,SAAA;MAAA;MAEzB,KAAKpE,OAAA,CAAQiB,KAAA,GAAQ+C,YAAA,GAAe9D,SAAA;MAEpC,KAAKA,SAAA,CAAUe,KAAA,GAAQ+C,YAAA;IAAA;IAGzB,MAAMoB,YAAA,GAAe,KAAK1F,KAAA,CAAM6C,MAAA,CAAO6C,YAAA,CAAanE,KAAA;IAEpD,IAAImE,YAAA,CAAa/B,MAAA,GAAS,GAAG;MAC3B,IAAIlD,UAAA,GAAa;MACjBiF,YAAA,CAAa5C,OAAA,CAAQ,UAAUC,MAAA,EAAQ;QACrCtC,UAAA,IAAc6B,MAAA,CAAOS,MAAA,CAAO2B,SAAA,IAAa3B,MAAA,CAAO0B,KAAA;MAAA;MAGlD,KAAKhE,UAAA,CAAWc,KAAA,GAAQd,UAAA;IAAA;IAG1B,MAAMkF,iBAAA,GAAoB,KAAK3F,KAAA,CAAM6C,MAAA,CAAO8C,iBAAA,CAAkBpE,KAAA;IAC9D,IAAIoE,iBAAA,CAAkBhC,MAAA,GAAS,GAAG;MAChC,IAAIjD,eAAA,GAAkB;MACtBiF,iBAAA,CAAkB7C,OAAA,CAAQ,UAAUC,MAAA,EAAQ;QAC1CrC,eAAA,IAAmB4B,MAAA,CAAOS,MAAA,CAAO2B,SAAA,IAAa3B,MAAA,CAAO0B,KAAA;MAAA;MAGvD,KAAK/D,eAAA,CAAgBa,KAAA,GAAQb,eAAA;IAAA;IAE/B,KAAKmD,eAAA,CAAgB;EAAA;EAGvB+B,YAAYC,QAAA,EAAuB;IACjC,KAAK/F,SAAA,CAAUmD,IAAA,CAAK4C,QAAA;EAAA;EAGtBC,eAAeD,QAAA,EAAuB;IACpC,MAAMV,KAAA,GAAQ,KAAKrF,SAAA,CAAUiG,OAAA,CAAQF,QAAA;IACrC,IAAIV,KAAA,KAAU,IAAI;MAChB,KAAKrF,SAAA,CAAUkG,MAAA,CAAOb,KAAA,EAAO;IAAA;EAAA;EAIjCtB,gBAAgBoC,KAAA,EAAe;IAC7B,MAAMnG,SAAA,GAAY,KAAKA,SAAA;IACvBA,SAAA,CAAUgD,OAAA,CAAS+C,QAAA,IAAa;MAjTpC,IAAAK,EAAA,EAAAC,EAAA;MAkTM,QAAQF,KAAA;QAAA,KACD;UACH,CAAAC,EAAA,GAAAL,QAAA,CAASL,KAAA,KAAT,gBAAAU,EAAA,CAAgBE,eAAA,CAAgB;UAChC;QAAA,KACG;UACH,CAAAD,EAAA,GAAAN,QAAA,CAASL,KAAA,KAAT,gBAAAW,EAAA,CAAgBE,kBAAA,CAAmB;UACnC;QAAA;UAEA,MAAM,IAAI7E,KAAA,CAAM,iCAAiCyE,KAAA;MAAA;IAAA;EAAA;AAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}