{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { getCurrentInstance, toRefs, ref, watch, unref } from 'vue';\nimport { hasOwn } from '@vue/shared';\nimport { orderBy, getKeysMap, toggleRowStatus, getRowIdentity, getColumnById, getColumnByKey } from '../util.mjs';\nimport useExpand from './expand.mjs';\nimport useCurrent from './current.mjs';\nimport useTree from './tree.mjs';\nconst sortData = (data, states) => {\n  const sortingColumn = states.sortingColumn;\n  if (!sortingColumn || typeof sortingColumn.sortable === \"string\") {\n    return data;\n  }\n  return orderBy(data, states.sortProp, states.sortOrder, sortingColumn.sortMethod, sortingColumn.sortBy);\n};\nconst doFlattenColumns = columns => {\n  const result = [];\n  columns.forEach(column => {\n    if (column.children) {\n      result.push.apply(result, doFlattenColumns(column.children));\n    } else {\n      result.push(column);\n    }\n  });\n  return result;\n};\nfunction useWatcher() {\n  var _a;\n  const instance = getCurrentInstance();\n  const {\n    size: tableSize\n  } = toRefs((_a = instance.proxy) == null ? void 0 : _a.$props);\n  const rowKey = ref(null);\n  const data = ref([]);\n  const _data = ref([]);\n  const isComplex = ref(false);\n  const _columns = ref([]);\n  const originColumns = ref([]);\n  const columns = ref([]);\n  const fixedColumns = ref([]);\n  const rightFixedColumns = ref([]);\n  const leafColumns = ref([]);\n  const fixedLeafColumns = ref([]);\n  const rightFixedLeafColumns = ref([]);\n  const leafColumnsLength = ref(0);\n  const fixedLeafColumnsLength = ref(0);\n  const rightFixedLeafColumnsLength = ref(0);\n  const isAllSelected = ref(false);\n  const selection = ref([]);\n  const reserveSelection = ref(false);\n  const selectOnIndeterminate = ref(false);\n  const selectable = ref(null);\n  const filters = ref({});\n  const filteredData = ref(null);\n  const sortingColumn = ref(null);\n  const sortProp = ref(null);\n  const sortOrder = ref(null);\n  const hoverRow = ref(null);\n  watch(data, () => instance.state && scheduleLayout(false), {\n    deep: true\n  });\n  const assertRowKey = () => {\n    if (!rowKey.value) throw new Error(\"[ElTable] prop row-key is required\");\n  };\n  const updateColumns = () => {\n    fixedColumns.value = _columns.value.filter(column => column.fixed === true || column.fixed === \"left\");\n    rightFixedColumns.value = _columns.value.filter(column => column.fixed === \"right\");\n    if (fixedColumns.value.length > 0 && _columns.value[0] && _columns.value[0].type === \"selection\" && !_columns.value[0].fixed) {\n      _columns.value[0].fixed = true;\n      fixedColumns.value.unshift(_columns.value[0]);\n    }\n    const notFixedColumns = _columns.value.filter(column => !column.fixed);\n    originColumns.value = [].concat(fixedColumns.value).concat(notFixedColumns).concat(rightFixedColumns.value);\n    const leafColumns2 = doFlattenColumns(notFixedColumns);\n    const fixedLeafColumns2 = doFlattenColumns(fixedColumns.value);\n    const rightFixedLeafColumns2 = doFlattenColumns(rightFixedColumns.value);\n    leafColumnsLength.value = leafColumns2.length;\n    fixedLeafColumnsLength.value = fixedLeafColumns2.length;\n    rightFixedLeafColumnsLength.value = rightFixedLeafColumns2.length;\n    columns.value = [].concat(fixedLeafColumns2).concat(leafColumns2).concat(rightFixedLeafColumns2);\n    isComplex.value = fixedColumns.value.length > 0 || rightFixedColumns.value.length > 0;\n  };\n  const scheduleLayout = (needUpdateColumns, immediate = false) => {\n    if (needUpdateColumns) {\n      updateColumns();\n    }\n    if (immediate) {\n      instance.state.doLayout();\n    } else {\n      instance.state.debouncedUpdateLayout();\n    }\n  };\n  const isSelected = row => {\n    return selection.value.indexOf(row) > -1;\n  };\n  const clearSelection = () => {\n    isAllSelected.value = false;\n    const oldSelection = selection.value;\n    if (oldSelection.length) {\n      selection.value = [];\n      instance.emit(\"selection-change\", []);\n    }\n  };\n  const cleanSelection = () => {\n    let deleted;\n    if (rowKey.value) {\n      deleted = [];\n      const selectedMap = getKeysMap(selection.value, rowKey.value);\n      const dataMap = getKeysMap(data.value, rowKey.value);\n      for (const key in selectedMap) {\n        if (hasOwn(selectedMap, key) && !dataMap[key]) {\n          deleted.push(selectedMap[key].row);\n        }\n      }\n    } else {\n      deleted = selection.value.filter(item => data.value.indexOf(item) === -1);\n    }\n    if (deleted.length) {\n      const newSelection = selection.value.filter(item => deleted.indexOf(item) === -1);\n      selection.value = newSelection;\n      instance.emit(\"selection-change\", newSelection.slice());\n    } else {\n      if (selection.value.length) {\n        selection.value = [];\n        instance.emit(\"selection-change\", []);\n      }\n    }\n  };\n  const toggleRowSelection = (row, selected = void 0, emitChange = true) => {\n    const changed = toggleRowStatus(selection.value, row, selected);\n    if (changed) {\n      const newSelection = (selection.value || []).slice();\n      if (emitChange) {\n        instance.emit(\"select\", newSelection, row);\n      }\n      instance.emit(\"selection-change\", newSelection);\n    }\n  };\n  const _toggleAllSelection = () => {\n    var _a2, _b;\n    const value = selectOnIndeterminate.value ? !isAllSelected.value : !(isAllSelected.value || selection.value.length);\n    isAllSelected.value = value;\n    let selectionChanged = false;\n    let childrenCount = 0;\n    const rowKey2 = (_b = (_a2 = instance == null ? void 0 : instance.store) == null ? void 0 : _a2.states) == null ? void 0 : _b.rowKey.value;\n    data.value.forEach((row, index) => {\n      const rowIndex = index + childrenCount;\n      if (selectable.value) {\n        if (selectable.value.call(null, row, rowIndex) && toggleRowStatus(selection.value, row, value)) {\n          selectionChanged = true;\n        }\n      } else {\n        if (toggleRowStatus(selection.value, row, value)) {\n          selectionChanged = true;\n        }\n      }\n      childrenCount += getChildrenCount(getRowIdentity(row, rowKey2));\n    });\n    if (selectionChanged) {\n      instance.emit(\"selection-change\", selection.value ? selection.value.slice() : []);\n    }\n    instance.emit(\"select-all\", selection.value);\n  };\n  const updateSelectionByRowKey = () => {\n    const selectedMap = getKeysMap(selection.value, rowKey.value);\n    data.value.forEach(row => {\n      const rowId = getRowIdentity(row, rowKey.value);\n      const rowInfo = selectedMap[rowId];\n      if (rowInfo) {\n        selection.value[rowInfo.index] = row;\n      }\n    });\n  };\n  const updateAllSelected = () => {\n    var _a2, _b, _c;\n    if (((_a2 = data.value) == null ? void 0 : _a2.length) === 0) {\n      isAllSelected.value = false;\n      return;\n    }\n    let selectedMap;\n    if (rowKey.value) {\n      selectedMap = getKeysMap(selection.value, rowKey.value);\n    }\n    const isSelected2 = function (row) {\n      if (selectedMap) {\n        return !!selectedMap[getRowIdentity(row, rowKey.value)];\n      } else {\n        return selection.value.indexOf(row) !== -1;\n      }\n    };\n    let isAllSelected_ = true;\n    let selectedCount = 0;\n    let childrenCount = 0;\n    for (let i = 0, j = (data.value || []).length; i < j; i++) {\n      const keyProp = (_c = (_b = instance == null ? void 0 : instance.store) == null ? void 0 : _b.states) == null ? void 0 : _c.rowKey.value;\n      const rowIndex = i + childrenCount;\n      const item = data.value[i];\n      const isRowSelectable = selectable.value && selectable.value.call(null, item, rowIndex);\n      if (!isSelected2(item)) {\n        if (!selectable.value || isRowSelectable) {\n          isAllSelected_ = false;\n          break;\n        }\n      } else {\n        selectedCount++;\n      }\n      childrenCount += getChildrenCount(getRowIdentity(item, keyProp));\n    }\n    if (selectedCount === 0) isAllSelected_ = false;\n    isAllSelected.value = isAllSelected_;\n  };\n  const getChildrenCount = rowKey2 => {\n    var _a2;\n    if (!instance || !instance.store) return 0;\n    const {\n      treeData\n    } = instance.store.states;\n    let count = 0;\n    const children = (_a2 = treeData.value[rowKey2]) == null ? void 0 : _a2.children;\n    if (children) {\n      count += children.length;\n      children.forEach(childKey => {\n        count += getChildrenCount(childKey);\n      });\n    }\n    return count;\n  };\n  const updateFilters = (columns2, values) => {\n    if (!Array.isArray(columns2)) {\n      columns2 = [columns2];\n    }\n    const filters_ = {};\n    columns2.forEach(col => {\n      filters.value[col.id] = values;\n      filters_[col.columnKey || col.id] = values;\n    });\n    return filters_;\n  };\n  const updateSort = (column, prop, order) => {\n    if (sortingColumn.value && sortingColumn.value !== column) {\n      sortingColumn.value.order = null;\n    }\n    sortingColumn.value = column;\n    sortProp.value = prop;\n    sortOrder.value = order;\n  };\n  const execFilter = () => {\n    let sourceData = unref(_data);\n    Object.keys(filters.value).forEach(columnId => {\n      const values = filters.value[columnId];\n      if (!values || values.length === 0) return;\n      const column = getColumnById({\n        columns: columns.value\n      }, columnId);\n      if (column && column.filterMethod) {\n        sourceData = sourceData.filter(row => {\n          return values.some(value => column.filterMethod.call(null, value, row, column));\n        });\n      }\n    });\n    filteredData.value = sourceData;\n  };\n  const execSort = () => {\n    data.value = sortData(filteredData.value, {\n      sortingColumn: sortingColumn.value,\n      sortProp: sortProp.value,\n      sortOrder: sortOrder.value\n    });\n  };\n  const execQuery = (ignore = void 0) => {\n    if (!(ignore && ignore.filter)) {\n      execFilter();\n    }\n    execSort();\n  };\n  const clearFilter = columnKeys => {\n    const {\n      tableHeader,\n      fixedTableHeader,\n      rightFixedTableHeader\n    } = instance.refs;\n    let panels = {};\n    if (tableHeader) panels = Object.assign(panels, tableHeader.filterPanels);\n    if (fixedTableHeader) panels = Object.assign(panels, fixedTableHeader.filterPanels);\n    if (rightFixedTableHeader) panels = Object.assign(panels, rightFixedTableHeader.filterPanels);\n    const keys = Object.keys(panels);\n    if (!keys.length) return;\n    if (typeof columnKeys === \"string\") {\n      columnKeys = [columnKeys];\n    }\n    if (Array.isArray(columnKeys)) {\n      const columns_ = columnKeys.map(key => getColumnByKey({\n        columns: columns.value\n      }, key));\n      keys.forEach(key => {\n        const column = columns_.find(col => col.id === key);\n        if (column) {\n          column.filteredValue = [];\n        }\n      });\n      instance.store.commit(\"filterChange\", {\n        column: columns_,\n        values: [],\n        silent: true,\n        multi: true\n      });\n    } else {\n      keys.forEach(key => {\n        const column = columns.value.find(col => col.id === key);\n        if (column) {\n          column.filteredValue = [];\n        }\n      });\n      filters.value = {};\n      instance.store.commit(\"filterChange\", {\n        column: {},\n        values: [],\n        silent: true\n      });\n    }\n  };\n  const clearSort = () => {\n    if (!sortingColumn.value) return;\n    updateSort(null, null, null);\n    instance.store.commit(\"changeSortCondition\", {\n      silent: true\n    });\n  };\n  const {\n    setExpandRowKeys,\n    toggleRowExpansion,\n    updateExpandRows,\n    states: expandStates,\n    isRowExpanded\n  } = useExpand({\n    data,\n    rowKey\n  });\n  const {\n    updateTreeExpandKeys,\n    toggleTreeExpansion,\n    updateTreeData,\n    loadOrToggle,\n    states: treeStates\n  } = useTree({\n    data,\n    rowKey\n  });\n  const {\n    updateCurrentRowData,\n    updateCurrentRow,\n    setCurrentRowKey,\n    states: currentData\n  } = useCurrent({\n    data,\n    rowKey\n  });\n  const setExpandRowKeysAdapter = val => {\n    setExpandRowKeys(val);\n    updateTreeExpandKeys(val);\n  };\n  const toggleRowExpansionAdapter = (row, expanded) => {\n    const hasExpandColumn = columns.value.some(({\n      type\n    }) => type === \"expand\");\n    if (hasExpandColumn) {\n      toggleRowExpansion(row, expanded);\n    } else {\n      toggleTreeExpansion(row, expanded);\n    }\n  };\n  return {\n    assertRowKey,\n    updateColumns,\n    scheduleLayout,\n    isSelected,\n    clearSelection,\n    cleanSelection,\n    toggleRowSelection,\n    _toggleAllSelection,\n    toggleAllSelection: null,\n    updateSelectionByRowKey,\n    updateAllSelected,\n    updateFilters,\n    updateCurrentRow,\n    updateSort,\n    execFilter,\n    execSort,\n    execQuery,\n    clearFilter,\n    clearSort,\n    toggleRowExpansion,\n    setExpandRowKeysAdapter,\n    setCurrentRowKey,\n    toggleRowExpansionAdapter,\n    isRowExpanded,\n    updateExpandRows,\n    updateCurrentRowData,\n    loadOrToggle,\n    updateTreeData,\n    states: {\n      tableSize,\n      rowKey,\n      data,\n      _data,\n      isComplex,\n      _columns,\n      originColumns,\n      columns,\n      fixedColumns,\n      rightFixedColumns,\n      leafColumns,\n      fixedLeafColumns,\n      rightFixedLeafColumns,\n      leafColumnsLength,\n      fixedLeafColumnsLength,\n      rightFixedLeafColumnsLength,\n      isAllSelected,\n      selection,\n      reserveSelection,\n      selectOnIndeterminate,\n      selectable,\n      filters,\n      filteredData,\n      sortingColumn,\n      sortProp,\n      sortOrder,\n      hoverRow,\n      ...expandStates,\n      ...treeStates,\n      ...currentData\n    }\n  };\n}\nexport { useWatcher as default };","map":{"version":3,"names":["sortData","data","states","sortingColumn","sortable","orderBy","sortProp","sortOrder","sortMethod","sortBy","doFlattenColumns","columns","result","forEach","column","children","push","apply","useWatcher","_a","instance","getCurrentInstance","size","tableSize","toRefs","proxy","$props","rowKey","ref","_data","isComplex","_columns","originColumns","fixedColumns","rightFixedColumns","leafColumns","fixedLeafColumns","rightFixedLeafColumns","leafColumnsLength","fixedLeafColumnsLength","rightFixedLeafColumnsLength","isAllSelected","selection","reserveSelection","selectOnIndeterminate","selectable","filters","filteredData","hoverRow","watch","state","scheduleLayout","deep","assertRowKey","value","Error","updateColumns","filter","fixed","length","type","unshift","notFixedColumns","concat","leafColumns2","fixedLeafColumns2","rightFixedLeafColumns2","needUpdateColumns","immediate","doLayout","debouncedUpdateLayout","isSelected","row","indexOf","clearSelection","oldSelection","emit","cleanSelection","deleted","selectedMap","getKeysMap","dataMap","key","hasOwn","item","newSelection","slice","toggleRowSelection","selected","emitChange","changed","toggleRowStatus","_toggleAllSelection","_a2","_b","selectionChanged","childrenCount","rowKey2","store","index","rowIndex","call","getChildrenCount","getRowIdentity","updateSelectionByRowKey","rowId","rowInfo","updateAllSelected","_c","isSelected2","isAllSelected_","selectedCount","i","j","keyProp","isRowSelectable","treeData","count","childKey","updateFilters","columns2","values","Array","isArray","filters_","col","id","columnKey","updateSort","prop","order","execFilter","sourceData","unref","Object","keys","columnId","getColumnById","filterMethod","some","execSort","execQuery","ignore","clearFilter","columnKeys","tableHeader","fixedTableHeader","rightFixedTableHeader","refs","panels","assign","filterPanels","columns_","map","getColumnByKey","find","filteredValue","commit","silent","multi","clearSort","setExpandRowKeys","toggleRowExpansion","updateExpandRows","expandStates","isRowExpanded","useExpand","updateTreeExpandKeys","toggleTreeExpansion","updateTreeData","loadOrToggle","treeStates","useTree","updateCurrentRowData","updateCurrentRow","setCurrentRowKey","currentData","useCurrent","setExpandRowKeysAdapter","val","toggleRowExpansionAdapter","expanded","hasExpandColumn","toggleAllSelection"],"sources":["../../../../../../../packages/components/table/src/store/watcher.ts"],"sourcesContent":["import { ref, getCurrentInstance, unref, watch, toRefs } from 'vue'\nimport { hasOwn } from '@vue/shared'\nimport {\n  getKeysMap,\n  getRowIdentity,\n  getColumnById,\n  getColumnByKey,\n  orderBy,\n  toggleRowStatus,\n} from '../util'\nimport useExpand from './expand'\nimport useCurrent from './current'\nimport useTree from './tree'\n\nimport type { Ref } from 'vue'\nimport type { TableColumnCtx } from '../table-column/defaults'\nimport type { Table, TableRefs } from '../table/defaults'\nimport type { StoreFilter } from './index'\n\nconst sortData = (data, states) => {\n  const sortingColumn = states.sortingColumn\n  if (!sortingColumn || typeof sortingColumn.sortable === 'string') {\n    return data\n  }\n  return orderBy(\n    data,\n    states.sortProp,\n    states.sortOrder,\n    sortingColumn.sortMethod,\n    sortingColumn.sortBy\n  )\n}\n\nconst doFlattenColumns = (columns) => {\n  const result = []\n  columns.forEach((column) => {\n    if (column.children) {\n      // eslint-disable-next-line prefer-spread\n      result.push.apply(result, doFlattenColumns(column.children))\n    } else {\n      result.push(column)\n    }\n  })\n  return result\n}\n\nfunction useWatcher<T>() {\n  const instance = getCurrentInstance() as Table<T>\n  const { size: tableSize } = toRefs(instance.proxy?.$props as any)\n  const rowKey: Ref<string> = ref(null)\n  const data: Ref<T[]> = ref([])\n  const _data: Ref<T[]> = ref([])\n  const isComplex = ref(false)\n  const _columns: Ref<TableColumnCtx<T>[]> = ref([])\n  const originColumns: Ref<TableColumnCtx<T>[]> = ref([])\n  const columns: Ref<TableColumnCtx<T>[]> = ref([])\n  const fixedColumns: Ref<TableColumnCtx<T>[]> = ref([])\n  const rightFixedColumns: Ref<TableColumnCtx<T>[]> = ref([])\n  const leafColumns: Ref<TableColumnCtx<T>[]> = ref([])\n  const fixedLeafColumns: Ref<TableColumnCtx<T>[]> = ref([])\n  const rightFixedLeafColumns: Ref<TableColumnCtx<T>[]> = ref([])\n  const leafColumnsLength = ref(0)\n  const fixedLeafColumnsLength = ref(0)\n  const rightFixedLeafColumnsLength = ref(0)\n  const isAllSelected = ref(false)\n  const selection: Ref<T[]> = ref([])\n  const reserveSelection = ref(false)\n  const selectOnIndeterminate = ref(false)\n  const selectable: Ref<(row: T, index: number) => boolean> = ref(null)\n  const filters: Ref<StoreFilter> = ref({})\n  const filteredData = ref(null)\n  const sortingColumn = ref(null)\n  const sortProp = ref(null)\n  const sortOrder = ref(null)\n  const hoverRow = ref(null)\n\n  watch(data, () => instance.state && scheduleLayout(false), {\n    deep: true,\n  })\n\n  // 检查 rowKey 是否存在\n  const assertRowKey = () => {\n    if (!rowKey.value) throw new Error('[ElTable] prop row-key is required')\n  }\n\n  // 更新列\n  const updateColumns = () => {\n    fixedColumns.value = _columns.value.filter(\n      (column) => column.fixed === true || column.fixed === 'left'\n    )\n    rightFixedColumns.value = _columns.value.filter(\n      (column) => column.fixed === 'right'\n    )\n    if (\n      fixedColumns.value.length > 0 &&\n      _columns.value[0] &&\n      _columns.value[0].type === 'selection' &&\n      !_columns.value[0].fixed\n    ) {\n      _columns.value[0].fixed = true\n      fixedColumns.value.unshift(_columns.value[0])\n    }\n\n    const notFixedColumns = _columns.value.filter((column) => !column.fixed)\n    originColumns.value = []\n      .concat(fixedColumns.value)\n      .concat(notFixedColumns)\n      .concat(rightFixedColumns.value)\n    const leafColumns = doFlattenColumns(notFixedColumns)\n    const fixedLeafColumns = doFlattenColumns(fixedColumns.value)\n    const rightFixedLeafColumns = doFlattenColumns(rightFixedColumns.value)\n\n    leafColumnsLength.value = leafColumns.length\n    fixedLeafColumnsLength.value = fixedLeafColumns.length\n    rightFixedLeafColumnsLength.value = rightFixedLeafColumns.length\n\n    columns.value = []\n      .concat(fixedLeafColumns)\n      .concat(leafColumns)\n      .concat(rightFixedLeafColumns)\n    isComplex.value =\n      fixedColumns.value.length > 0 || rightFixedColumns.value.length > 0\n  }\n\n  // 更新 DOM\n  const scheduleLayout = (needUpdateColumns?: boolean, immediate = false) => {\n    if (needUpdateColumns) {\n      updateColumns()\n    }\n    if (immediate) {\n      instance.state.doLayout()\n    } else {\n      instance.state.debouncedUpdateLayout()\n    }\n  }\n\n  // 选择\n  const isSelected = (row) => {\n    return selection.value.indexOf(row) > -1\n  }\n\n  const clearSelection = () => {\n    isAllSelected.value = false\n    const oldSelection = selection.value\n    if (oldSelection.length) {\n      selection.value = []\n      instance.emit('selection-change', [])\n    }\n  }\n\n  const cleanSelection = () => {\n    let deleted\n    if (rowKey.value) {\n      deleted = []\n      const selectedMap = getKeysMap(selection.value, rowKey.value)\n      const dataMap = getKeysMap(data.value, rowKey.value)\n      for (const key in selectedMap) {\n        if (hasOwn(selectedMap, key) && !dataMap[key]) {\n          deleted.push(selectedMap[key].row)\n        }\n      }\n    } else {\n      deleted = selection.value.filter(\n        (item) => data.value.indexOf(item) === -1\n      )\n    }\n    if (deleted.length) {\n      const newSelection = selection.value.filter(\n        (item) => deleted.indexOf(item) === -1\n      )\n      selection.value = newSelection\n      instance.emit('selection-change', newSelection.slice())\n    } else {\n      if (selection.value.length) {\n        selection.value = []\n        instance.emit('selection-change', [])\n      }\n    }\n  }\n\n  const toggleRowSelection = (\n    row: T,\n    selected = undefined,\n    emitChange = true\n  ) => {\n    const changed = toggleRowStatus(selection.value, row, selected)\n    if (changed) {\n      const newSelection = (selection.value || []).slice()\n      // 调用 API 修改选中值，不触发 select 事件\n      if (emitChange) {\n        instance.emit('select', newSelection, row)\n      }\n      instance.emit('selection-change', newSelection)\n    }\n  }\n\n  const _toggleAllSelection = () => {\n    // when only some rows are selected (but not all), select or deselect all of them\n    // depending on the value of selectOnIndeterminate\n    const value = selectOnIndeterminate.value\n      ? !isAllSelected.value\n      : !(isAllSelected.value || selection.value.length)\n    isAllSelected.value = value\n\n    let selectionChanged = false\n    let childrenCount = 0\n    const rowKey = instance?.store?.states?.rowKey.value\n    data.value.forEach((row, index) => {\n      const rowIndex = index + childrenCount\n      if (selectable.value) {\n        if (\n          selectable.value.call(null, row, rowIndex) &&\n          toggleRowStatus(selection.value, row, value)\n        ) {\n          selectionChanged = true\n        }\n      } else {\n        if (toggleRowStatus(selection.value, row, value)) {\n          selectionChanged = true\n        }\n      }\n      childrenCount += getChildrenCount(getRowIdentity(row, rowKey))\n    })\n\n    if (selectionChanged) {\n      instance.emit(\n        'selection-change',\n        selection.value ? selection.value.slice() : []\n      )\n    }\n    instance.emit('select-all', selection.value)\n  }\n\n  const updateSelectionByRowKey = () => {\n    const selectedMap = getKeysMap(selection.value, rowKey.value)\n    data.value.forEach((row) => {\n      const rowId = getRowIdentity(row, rowKey.value)\n      const rowInfo = selectedMap[rowId]\n      if (rowInfo) {\n        selection.value[rowInfo.index] = row\n      }\n    })\n  }\n\n  const updateAllSelected = () => {\n    // data 为 null 时，解构时的默认值会被忽略\n    if (data.value?.length === 0) {\n      isAllSelected.value = false\n      return\n    }\n\n    let selectedMap\n    if (rowKey.value) {\n      selectedMap = getKeysMap(selection.value, rowKey.value)\n    }\n    const isSelected = function (row) {\n      if (selectedMap) {\n        return !!selectedMap[getRowIdentity(row, rowKey.value)]\n      } else {\n        return selection.value.indexOf(row) !== -1\n      }\n    }\n    let isAllSelected_ = true\n    let selectedCount = 0\n    let childrenCount = 0\n    for (let i = 0, j = (data.value || []).length; i < j; i++) {\n      const keyProp = instance?.store?.states?.rowKey.value\n      const rowIndex = i + childrenCount\n      const item = data.value[i]\n      const isRowSelectable =\n        selectable.value && selectable.value.call(null, item, rowIndex)\n      if (!isSelected(item)) {\n        if (!selectable.value || isRowSelectable) {\n          isAllSelected_ = false\n          break\n        }\n      } else {\n        selectedCount++\n      }\n      childrenCount += getChildrenCount(getRowIdentity(item, keyProp))\n    }\n\n    if (selectedCount === 0) isAllSelected_ = false\n    isAllSelected.value = isAllSelected_\n  }\n\n  // gets the number of all child nodes by rowKey\n  const getChildrenCount = (rowKey: string) => {\n    if (!instance || !instance.store) return 0\n    const { treeData } = instance.store.states\n    let count = 0\n    const children = treeData.value[rowKey]?.children\n    if (children) {\n      count += children.length\n      children.forEach((childKey) => {\n        count += getChildrenCount(childKey)\n      })\n    }\n    return count\n  }\n\n  // 过滤与排序\n  const updateFilters = (columns, values) => {\n    if (!Array.isArray(columns)) {\n      columns = [columns]\n    }\n    const filters_ = {}\n    columns.forEach((col) => {\n      filters.value[col.id] = values\n      filters_[col.columnKey || col.id] = values\n    })\n    return filters_\n  }\n\n  const updateSort = (column, prop, order) => {\n    if (sortingColumn.value && sortingColumn.value !== column) {\n      sortingColumn.value.order = null\n    }\n    sortingColumn.value = column\n    sortProp.value = prop\n    sortOrder.value = order\n  }\n\n  const execFilter = () => {\n    let sourceData = unref(_data)\n    Object.keys(filters.value).forEach((columnId) => {\n      const values = filters.value[columnId]\n      if (!values || values.length === 0) return\n      const column = getColumnById(\n        {\n          columns: columns.value,\n        },\n        columnId\n      )\n      if (column && column.filterMethod) {\n        sourceData = sourceData.filter((row) => {\n          return values.some((value) =>\n            column.filterMethod.call(null, value, row, column)\n          )\n        })\n      }\n    })\n\n    filteredData.value = sourceData\n  }\n\n  const execSort = () => {\n    data.value = sortData(filteredData.value, {\n      sortingColumn: sortingColumn.value,\n      sortProp: sortProp.value,\n      sortOrder: sortOrder.value,\n    })\n  }\n\n  // 根据 filters 与 sort 去过滤 data\n  const execQuery = (ignore = undefined) => {\n    if (!(ignore && ignore.filter)) {\n      execFilter()\n    }\n    execSort()\n  }\n\n  const clearFilter = (columnKeys) => {\n    const { tableHeader, fixedTableHeader, rightFixedTableHeader } =\n      instance.refs as TableRefs\n    let panels = {}\n    if (tableHeader) panels = Object.assign(panels, tableHeader.filterPanels)\n    if (fixedTableHeader)\n      panels = Object.assign(panels, fixedTableHeader.filterPanels)\n    if (rightFixedTableHeader)\n      panels = Object.assign(panels, rightFixedTableHeader.filterPanels)\n\n    const keys = Object.keys(panels)\n    if (!keys.length) return\n\n    if (typeof columnKeys === 'string') {\n      columnKeys = [columnKeys]\n    }\n\n    if (Array.isArray(columnKeys)) {\n      const columns_ = columnKeys.map((key) =>\n        getColumnByKey(\n          {\n            columns: columns.value,\n          },\n          key\n        )\n      )\n      keys.forEach((key) => {\n        const column = columns_.find((col) => col.id === key)\n        if (column) {\n          column.filteredValue = []\n        }\n      })\n      instance.store.commit('filterChange', {\n        column: columns_,\n        values: [],\n        silent: true,\n        multi: true,\n      })\n    } else {\n      keys.forEach((key) => {\n        const column = columns.value.find((col) => col.id === key)\n        if (column) {\n          column.filteredValue = []\n        }\n      })\n\n      filters.value = {}\n      instance.store.commit('filterChange', {\n        column: {},\n        values: [],\n        silent: true,\n      })\n    }\n  }\n\n  const clearSort = () => {\n    if (!sortingColumn.value) return\n\n    updateSort(null, null, null)\n    instance.store.commit('changeSortCondition', {\n      silent: true,\n    })\n  }\n  const {\n    setExpandRowKeys,\n    toggleRowExpansion,\n    updateExpandRows,\n    states: expandStates,\n    isRowExpanded,\n  } = useExpand({\n    data,\n    rowKey,\n  })\n  const {\n    updateTreeExpandKeys,\n    toggleTreeExpansion,\n    updateTreeData,\n    loadOrToggle,\n    states: treeStates,\n  } = useTree({\n    data,\n    rowKey,\n  })\n  const {\n    updateCurrentRowData,\n    updateCurrentRow,\n    setCurrentRowKey,\n    states: currentData,\n  } = useCurrent({\n    data,\n    rowKey,\n  })\n  // 适配层，expand-row-keys 在 Expand 与 TreeTable 中都有使用\n  const setExpandRowKeysAdapter = (val: string[]) => {\n    // 这里会触发额外的计算，但为了兼容性，暂时这么做\n    setExpandRowKeys(val)\n    updateTreeExpandKeys(val)\n  }\n\n  // 展开行与 TreeTable 都要使用\n  const toggleRowExpansionAdapter = (row: T, expanded: boolean) => {\n    const hasExpandColumn = columns.value.some(({ type }) => type === 'expand')\n    if (hasExpandColumn) {\n      toggleRowExpansion(row, expanded)\n    } else {\n      toggleTreeExpansion(row, expanded)\n    }\n  }\n\n  return {\n    assertRowKey,\n    updateColumns,\n    scheduleLayout,\n    isSelected,\n    clearSelection,\n    cleanSelection,\n    toggleRowSelection,\n    _toggleAllSelection,\n    toggleAllSelection: null,\n    updateSelectionByRowKey,\n    updateAllSelected,\n    updateFilters,\n    updateCurrentRow,\n    updateSort,\n    execFilter,\n    execSort,\n    execQuery,\n    clearFilter,\n    clearSort,\n    toggleRowExpansion,\n    setExpandRowKeysAdapter,\n    setCurrentRowKey,\n    toggleRowExpansionAdapter,\n    isRowExpanded,\n    updateExpandRows,\n    updateCurrentRowData,\n    loadOrToggle,\n    updateTreeData,\n    states: {\n      tableSize,\n      rowKey,\n      data,\n      _data,\n      isComplex,\n      _columns,\n      originColumns,\n      columns,\n      fixedColumns,\n      rightFixedColumns,\n      leafColumns,\n      fixedLeafColumns,\n      rightFixedLeafColumns,\n      leafColumnsLength,\n      fixedLeafColumnsLength,\n      rightFixedLeafColumnsLength,\n      isAllSelected,\n      selection,\n      reserveSelection,\n      selectOnIndeterminate,\n      selectable,\n      filters,\n      filteredData,\n      sortingColumn,\n      sortProp,\n      sortOrder,\n      hoverRow,\n      ...expandStates,\n      ...treeStates,\n      ...currentData,\n    },\n  }\n}\n\nexport default useWatcher\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}