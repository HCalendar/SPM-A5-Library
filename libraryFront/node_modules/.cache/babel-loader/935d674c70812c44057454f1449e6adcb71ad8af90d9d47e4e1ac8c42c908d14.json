{"ast":null,"code":"import { ref, h, Teleport, onUnmounted } from 'vue';\nimport { NOOP } from '@vue/shared';\nimport { isClient } from '@vueuse/core';\nimport { createGlobalNode, removeGlobalNode } from '../../utils/global-nodes.mjs';\nconst useTeleport = (contentRenderer, appendToBody) => {\n  const isTeleportVisible = ref(false);\n  if (!isClient) {\n    return {\n      isTeleportVisible,\n      showTeleport: NOOP,\n      hideTeleport: NOOP,\n      renderTeleport: NOOP\n    };\n  }\n  let $el = null;\n  const showTeleport = () => {\n    isTeleportVisible.value = true;\n    if ($el !== null) return;\n    $el = createGlobalNode();\n  };\n  const hideTeleport = () => {\n    isTeleportVisible.value = false;\n    if ($el !== null) {\n      removeGlobalNode($el);\n      $el = null;\n    }\n  };\n  const renderTeleport = () => {\n    return appendToBody.value !== true ? contentRenderer() : isTeleportVisible.value ? [h(Teleport, {\n      to: $el\n    }, contentRenderer())] : void 0;\n  };\n  onUnmounted(hideTeleport);\n  return {\n    isTeleportVisible,\n    showTeleport,\n    hideTeleport,\n    renderTeleport\n  };\n};\nexport { useTeleport };","map":{"version":3,"names":["useTeleport","contentRenderer","appendToBody","isTeleportVisible","ref","isClient","showTeleport","NOOP","hideTeleport","renderTeleport","$el","value","createGlobalNode","removeGlobalNode","h","Teleport","to","onUnmounted"],"sources":["../../../../../packages/hooks/use-teleport/index.ts"],"sourcesContent":["import { h, ref, Teleport, onUnmounted } from 'vue'\nimport { NOOP } from '@vue/shared'\nimport { isClient } from '@vueuse/core'\nimport {\n  createGlobalNode,\n  removeGlobalNode,\n} from '@element-plus/utils/global-nodes'\n\nimport type { VNode, Ref } from 'vue'\n\nexport const useTeleport = (\n  contentRenderer: () => VNode,\n  appendToBody: Ref<boolean>\n) => {\n  const isTeleportVisible = ref(false)\n\n  if (!isClient) {\n    return {\n      isTeleportVisible,\n      showTeleport: NOOP,\n      hideTeleport: NOOP,\n      renderTeleport: NOOP,\n    }\n  }\n\n  let $el: HTMLElement | null = null\n\n  const showTeleport = () => {\n    isTeleportVisible.value = true\n    // this allows the delayed showing strategy since the the content itself could be enterable\n    // e.g. el-popper\n    if ($el !== null) return\n\n    $el = createGlobalNode()\n  }\n\n  const hideTeleport = () => {\n    isTeleportVisible.value = false\n    if ($el !== null) {\n      removeGlobalNode($el)\n      $el = null\n    }\n  }\n\n  const renderTeleport = () => {\n    return appendToBody.value !== true\n      ? contentRenderer()\n      : isTeleportVisible.value\n      ? [h(Teleport, { to: $el }, contentRenderer())]\n      : undefined\n  }\n\n  onUnmounted(hideTeleport)\n\n  return {\n    isTeleportVisible,\n    showTeleport,\n    hideTeleport,\n    renderTeleport,\n  }\n}\n"],"mappings":";;;;MAUaA,WAAA,GAAcA,CACzBC,eAAA,EACAC,YAAA,KACG;EACH,MAAMC,iBAAA,GAAoBC,GAAA,CAAI;EAE9B,IAAI,CAACC,QAAA,EAAU;IACb,OAAO;MACLF,iBAAA;MACAG,YAAA,EAAcC,IAAA;MACdC,YAAA,EAAcD,IAAA;MACdE,cAAA,EAAgBF;IAAA;EAAA;EAIpB,IAAIG,GAAA,GAA0B;EAE9B,MAAMJ,YAAA,GAAeA,CAAA,KAAM;IACzBH,iBAAA,CAAkBQ,KAAA,GAAQ;IAG1B,IAAID,GAAA,KAAQ,MAAM;IAElBA,GAAA,GAAME,gBAAA;EAAA;EAGR,MAAMJ,YAAA,GAAeA,CAAA,KAAM;IACzBL,iBAAA,CAAkBQ,KAAA,GAAQ;IAC1B,IAAID,GAAA,KAAQ,MAAM;MAChBG,gBAAA,CAAiBH,GAAA;MACjBA,GAAA,GAAM;IAAA;EAAA;EAIV,MAAMD,cAAA,GAAiBA,CAAA,KAAM;IAC3B,OAAOP,YAAA,CAAaS,KAAA,KAAU,OAC1BV,eAAA,KACAE,iBAAA,CAAkBQ,KAAA,GAClB,CAACG,CAAA,CAAEC,QAAA,EAAU;MAAEC,EAAA,EAAIN;IAAA,GAAOT,eAAA,OAC1B;EAAA;EAGNgB,WAAA,CAAYT,YAAA;EAEZ,OAAO;IACLL,iBAAA;IACAG,YAAA;IACAE,YAAA;IACAC;EAAA;AAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}