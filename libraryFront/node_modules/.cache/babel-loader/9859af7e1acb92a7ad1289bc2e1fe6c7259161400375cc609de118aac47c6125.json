{"ast":null,"code":"import \"core-js/modules/esnext.set.difference.v2.js\";\nimport \"core-js/modules/esnext.set.intersection.v2.js\";\nimport \"core-js/modules/esnext.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/esnext.set.is-subset-of.v2.js\";\nimport \"core-js/modules/esnext.set.is-superset-of.v2.js\";\nimport \"core-js/modules/esnext.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/esnext.set.union.v2.js\";\nimport { warn } from 'vue';\nimport { isObject } from '@vue/shared';\nimport fromPairs from 'lodash/fromPairs';\nconst wrapperKey = Symbol();\nconst propKey = Symbol();\nfunction buildProp(option, key) {\n  if (!isObject(option) || !!option[propKey]) return option;\n  const {\n    values,\n    required,\n    default: defaultValue,\n    type,\n    validator\n  } = option;\n  const _validator = values || validator ? val => {\n    let valid = false;\n    let allowedValues = [];\n    if (values) {\n      allowedValues = [...values, defaultValue];\n      valid || (valid = allowedValues.includes(val));\n    }\n    if (validator) valid || (valid = validator(val));\n    if (!valid && allowedValues.length > 0) {\n      const allowValuesText = [...new Set(allowedValues)].map(value => JSON.stringify(value)).join(\", \");\n      warn(`Invalid prop: validation failed${key ? ` for prop \"${key}\"` : \"\"}. Expected one of [${allowValuesText}], got value ${JSON.stringify(val)}.`);\n    }\n    return valid;\n  } : void 0;\n  return {\n    type: typeof type === \"object\" && Object.getOwnPropertySymbols(type).includes(wrapperKey) ? type[wrapperKey] : type,\n    required: !!required,\n    default: defaultValue,\n    validator: _validator,\n    [propKey]: true\n  };\n}\nconst buildProps = props => fromPairs(Object.entries(props).map(([key, option]) => [key, buildProp(option, key)]));\nconst definePropType = val => ({\n  [wrapperKey]: val\n});\nconst keyOf = arr => Object.keys(arr);\nconst mutable = val => val;\nconst componentSize = [\"large\", \"medium\", \"small\", \"mini\"];\nexport { buildProp, buildProps, componentSize, definePropType, keyOf, mutable, propKey };","map":{"version":3,"names":["wrapperKey","Symbol","propKey","option","key","isObject","values","required","default","defaultValue","type","validator","_validator","val","valid","allowedValues","includes","length","allowValuesText","Set","map","value","JSON","stringify","join","warn","Object","getOwnPropertySymbols","buildProps","props","fromPairs","entries","buildProp","definePropType","keyOf","arr","keys","mutable","componentSize"],"sources":["../../../../packages/utils/props.ts"],"sourcesContent":["import { warn } from 'vue'\nimport { isObject } from '@vue/shared'\nimport fromPairs from 'lodash/fromPairs'\nimport type { ExtractPropTypes, PropType } from '@vue/runtime-core'\nimport type { Mutable } from './types'\n\nconst wrapperKey = Symbol()\nexport type PropWrapper<T> = { [wrapperKey]: T }\n\nexport const propKey = Symbol()\n\ntype ResolveProp<T> = ExtractPropTypes<{\n  key: { type: T; required: true }\n}>['key']\ntype ResolvePropType<T> = ResolveProp<T> extends { type: infer V }\n  ? V\n  : ResolveProp<T>\ntype ResolvePropTypeWithReadonly<T> = Readonly<T> extends Readonly<\n  Array<infer A>\n>\n  ? ResolvePropType<A[]>\n  : ResolvePropType<T>\n\ntype IfUnknown<T, V> = [unknown] extends [T] ? V : T\n\nexport type BuildPropOption<T, D extends BuildPropType<T, V, C>, R, V, C> = {\n  type?: T\n  values?: readonly V[]\n  required?: R\n  default?: R extends true\n    ? never\n    : D extends Record<string, unknown> | Array<any>\n    ? () => D\n    : (() => D) | D\n  validator?: ((val: any) => val is C) | ((val: any) => boolean)\n}\n\ntype _BuildPropType<T, V, C> =\n  | (T extends PropWrapper<unknown>\n      ? T[typeof wrapperKey]\n      : [V] extends [never]\n      ? ResolvePropTypeWithReadonly<T>\n      : never)\n  | V\n  | C\nexport type BuildPropType<T, V, C> = _BuildPropType<\n  IfUnknown<T, never>,\n  IfUnknown<V, never>,\n  IfUnknown<C, never>\n>\n\ntype _BuildPropDefault<T, D> = [T] extends [\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  Record<string, unknown> | Array<any> | Function\n]\n  ? D\n  : D extends () => T\n  ? ReturnType<D>\n  : D\n\nexport type BuildPropDefault<T, D, R> = R extends true\n  ? { readonly default?: undefined }\n  : {\n      readonly default: Exclude<D, undefined> extends never\n        ? undefined\n        : Exclude<_BuildPropDefault<T, D>, undefined>\n    }\nexport type BuildPropReturn<T, D, R, V, C> = {\n  readonly type: PropType<BuildPropType<T, V, C>>\n  readonly required: IfUnknown<R, false>\n  readonly validator: ((val: unknown) => boolean) | undefined\n  [propKey]: true\n} & BuildPropDefault<\n  BuildPropType<T, V, C>,\n  IfUnknown<D, never>,\n  IfUnknown<R, false>\n>\n\n/**\n * @description Build prop. It can better optimize prop types\n * @description 生成 prop，能更好地优化类型\n * @example\n  // limited options\n  // the type will be PropType<'light' | 'dark'>\n  buildProp({\n    type: String,\n    values: ['light', 'dark'],\n  } as const)\n  * @example\n  // limited options and other types\n  // the type will be PropType<'small' | 'medium' | number>\n  buildProp({\n    type: [String, Number],\n    values: ['small', 'medium'],\n    validator: (val: unknown): val is number => typeof val === 'number',\n  } as const)\n  @link see more: https://github.com/element-plus/element-plus/pull/3341\n */\nexport function buildProp<\n  T = never,\n  D extends BuildPropType<T, V, C> = never,\n  R extends boolean = false,\n  V = never,\n  C = never\n>(\n  option: BuildPropOption<T, D, R, V, C>,\n  key?: string\n): BuildPropReturn<T, D, R, V, C> {\n  // filter native prop type and nested prop, e.g `null`, `undefined` (from `buildProps`)\n  if (!isObject(option) || !!option[propKey]) return option as any\n\n  const { values, required, default: defaultValue, type, validator } = option\n\n  const _validator =\n    values || validator\n      ? (val: unknown) => {\n          let valid = false\n          let allowedValues: unknown[] = []\n\n          if (values) {\n            allowedValues = [...values, defaultValue]\n            valid ||= allowedValues.includes(val)\n          }\n          if (validator) valid ||= validator(val)\n\n          if (!valid && allowedValues.length > 0) {\n            const allowValuesText = [...new Set(allowedValues)]\n              .map((value) => JSON.stringify(value))\n              .join(', ')\n            warn(\n              `Invalid prop: validation failed${\n                key ? ` for prop \"${key}\"` : ''\n              }. Expected one of [${allowValuesText}], got value ${JSON.stringify(\n                val\n              )}.`\n            )\n          }\n          return valid\n        }\n      : undefined\n\n  return {\n    type:\n      typeof type === 'object' &&\n      Object.getOwnPropertySymbols(type).includes(wrapperKey)\n        ? type[wrapperKey]\n        : type,\n    required: !!required,\n    default: defaultValue,\n    validator: _validator,\n    [propKey]: true,\n  } as unknown as BuildPropReturn<T, D, R, V, C>\n}\n\ntype NativePropType = [\n  ((...args: any) => any) | { new (...args: any): any } | undefined | null\n]\n\nexport const buildProps = <\n  O extends {\n    [K in keyof O]: O[K] extends BuildPropReturn<any, any, any, any, any>\n      ? O[K]\n      : [O[K]] extends NativePropType\n      ? O[K]\n      : O[K] extends BuildPropOption<\n          infer T,\n          infer D,\n          infer R,\n          infer V,\n          infer C\n        >\n      ? D extends BuildPropType<T, V, C>\n        ? BuildPropOption<T, D, R, V, C>\n        : never\n      : never\n  }\n>(\n  props: O\n) =>\n  fromPairs(\n    Object.entries(props).map(([key, option]) => [\n      key,\n      buildProp(option as any, key),\n    ])\n  ) as unknown as {\n    [K in keyof O]: O[K] extends { [propKey]: boolean }\n      ? O[K]\n      : [O[K]] extends NativePropType\n      ? O[K]\n      : O[K] extends BuildPropOption<\n          infer T,\n          // eslint-disable-next-line @typescript-eslint/no-unused-vars\n          infer _D,\n          infer R,\n          infer V,\n          infer C\n        >\n      ? BuildPropReturn<T, O[K]['default'], R, V, C>\n      : never\n  }\n\nexport const definePropType = <T>(val: any) =>\n  ({ [wrapperKey]: val } as PropWrapper<T>)\n\nexport const keyOf = <T>(arr: T) => Object.keys(arr) as Array<keyof T>\nexport const mutable = <T extends readonly any[] | Record<string, unknown>>(\n  val: T\n) => val as Mutable<typeof val>\n\nexport const componentSize = ['large', 'medium', 'small', 'mini'] as const\n"],"mappings":";;;;;;;;;;AAMA,MAAMA,UAAA,GAAaC,MAAA;MAGNC,OAAA,GAAUD,MAAA;mBAgGrBE,MAAA,EACAC,GAAA,EACgC;EAEhC,IAAI,CAACC,QAAA,CAASF,MAAA,KAAW,CAAC,CAACA,MAAA,CAAOD,OAAA,GAAU,OAAOC,MAAA;EAEnD,MAAM;IAAEG,MAAA;IAAQC,QAAA;IAAUC,OAAA,EAASC,YAAA;IAAcC,IAAA;IAAMC;EAAA,IAAcR,MAAA;EAErE,MAAMS,UAAA,GACJN,MAAA,IAAUK,SAAA,GACLE,GAAA,IAAiB;IAChB,IAAIC,KAAA,GAAQ;IACZ,IAAIC,aAAA,GAA2B;IAE/B,IAAIT,MAAA,EAAQ;MACVS,aAAA,GAAgB,CAAC,GAAGT,MAAA,EAAQG,YAAA;MAC5BK,KAAA,KAAAA,KAAA,GAAUC,aAAA,CAAcC,QAAA,CAASH,GAAA;IAAA;IAEnC,IAAIF,SAAA,EAAWG,KAAA,KAAAA,KAAA,GAAUH,SAAA,CAAUE,GAAA;IAEnC,IAAI,CAACC,KAAA,IAASC,aAAA,CAAcE,MAAA,GAAS,GAAG;MACtC,MAAMC,eAAA,GAAkB,CAAC,GAAG,IAAIC,GAAA,CAAIJ,aAAA,GACjCK,GAAA,CAAKC,KAAA,IAAUC,IAAA,CAAKC,SAAA,CAAUF,KAAA,GAC9BG,IAAA,CAAK;MACRC,IAAA,CACE,kCACErB,GAAA,GAAM,cAAcA,GAAA,MAAS,wBACTc,eAAA,gBAA+BI,IAAA,CAAKC,SAAA,CACxDV,GAAA;IAAA;IAIN,OAAOC,KAAA;EAAA,IAET;EAEN,OAAO;IACLJ,IAAA,EACE,OAAOA,IAAA,KAAS,YAChBgB,MAAA,CAAOC,qBAAA,CAAsBjB,IAAA,EAAMM,QAAA,CAAShB,UAAA,IACxCU,IAAA,CAAKV,UAAA,IACLU,IAAA;IACNH,QAAA,EAAU,CAAC,CAACA,QAAA;IACZC,OAAA,EAASC,YAAA;IACTE,SAAA,EAAWC,UAAA;IAAA,CACVV,OAAA,GAAU;EAAA;AAAA;MAQF0B,UAAA,GAmBXC,KAAA,IAEAC,SAAA,CACEJ,MAAA,CAAOK,OAAA,CAAQF,KAAA,EAAOT,GAAA,CAAI,CAAC,CAAChB,GAAA,EAAKD,MAAA,MAAY,CAC3CC,GAAA,EACA4B,SAAA,CAAU7B,MAAA,EAAeC,GAAA;MAmBlB6B,cAAA,GAAqBpB,GAAA;EAAA,CAC5Bb,UAAA,GAAaa;AAAA;MAENqB,KAAA,GAAYC,GAAA,IAAWT,MAAA,CAAOU,IAAA,CAAKD,GAAA;MACnCE,OAAA,GACXxB,GAAA,IACGA,GAAA;MAEQyB,aAAA,GAAgB,CAAC,SAAS,UAAU,SAAS","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}