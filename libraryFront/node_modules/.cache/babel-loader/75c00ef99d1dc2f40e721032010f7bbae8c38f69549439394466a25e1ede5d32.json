{"ast":null,"code":"import { ref, isRef } from 'vue';\nimport { isObject, isString, hyphenate } from '@vue/shared';\nimport { Loading } from './service.mjs';\nconst INSTANCE_KEY = Symbol(\"ElLoading\");\nconst createInstance = (el, binding) => {\n  var _a, _b, _c, _d;\n  const vm = binding.instance;\n  const getBindingProp = key => isObject(binding.value) ? binding.value[key] : void 0;\n  const resolveExpression = key => {\n    const data = isString(key) && (vm == null ? void 0 : vm[key]) || key;\n    if (data) return ref(data);else return data;\n  };\n  const getProp = name => resolveExpression(getBindingProp(name) || el.getAttribute(`element-loading-${hyphenate(name)}`));\n  const fullscreen = (_a = getBindingProp(\"fullscreen\")) != null ? _a : binding.modifiers.fullscreen;\n  const options = {\n    text: getProp(\"text\"),\n    svg: getProp(\"svg\"),\n    svgViewBox: getProp(\"svgViewBox\"),\n    spinner: getProp(\"spinner\"),\n    background: getProp(\"background\"),\n    customClass: getProp(\"customClass\"),\n    fullscreen,\n    target: (_b = getBindingProp(\"target\")) != null ? _b : fullscreen ? void 0 : el,\n    body: (_c = getBindingProp(\"body\")) != null ? _c : binding.modifiers.body,\n    lock: (_d = getBindingProp(\"lock\")) != null ? _d : binding.modifiers.lock\n  };\n  el[INSTANCE_KEY] = {\n    options,\n    instance: Loading(options)\n  };\n};\nconst updateOptions = (newOptions, originalOptions) => {\n  for (const key of Object.keys(originalOptions)) {\n    if (isRef(originalOptions[key])) originalOptions[key].value = newOptions[key];\n  }\n};\nconst vLoading = {\n  mounted(el, binding) {\n    if (binding.value) {\n      createInstance(el, binding);\n    }\n  },\n  updated(el, binding) {\n    const instance = el[INSTANCE_KEY];\n    if (binding.oldValue !== binding.value) {\n      if (binding.value && !binding.oldValue) {\n        createInstance(el, binding);\n      } else if (binding.value && binding.oldValue) {\n        if (isObject(binding.value)) updateOptions(binding.value, instance.options);\n      } else {\n        instance == null ? void 0 : instance.instance.close();\n      }\n    }\n  },\n  unmounted(el) {\n    var _a;\n    (_a = el[INSTANCE_KEY]) == null ? void 0 : _a.instance.close();\n  }\n};\nexport { vLoading };","map":{"version":3,"names":["INSTANCE_KEY","Symbol","createInstance","el","binding","_a","_b","_c","_d","vm","instance","getBindingProp","key","isObject","value","resolveExpression","data","isString","ref","getProp","name","getAttribute","hyphenate","fullscreen","modifiers","options","text","svg","svgViewBox","spinner","background","customClass","target","body","lock","Loading","updateOptions","newOptions","originalOptions","Object","keys","isRef","vLoading","mounted","updated","oldValue","close","unmounted"],"sources":["../../../../../../packages/components/loading/src/directive.ts"],"sourcesContent":["import { isRef, ref } from 'vue'\nimport { isObject, isString, hyphenate } from '@vue/shared'\nimport { Loading } from './service'\nimport type { Directive, DirectiveBinding, UnwrapRef } from 'vue'\nimport type { LoadingOptions } from './types'\nimport type { LoadingInstance } from './loading'\n\nconst INSTANCE_KEY = Symbol('ElLoading')\n\nexport type LoadingBinding = boolean | UnwrapRef<LoadingOptions>\nexport interface ElementLoading extends HTMLElement {\n  [INSTANCE_KEY]?: {\n    instance: LoadingInstance\n    options: LoadingOptions\n  }\n}\n\nconst createInstance = (\n  el: ElementLoading,\n  binding: DirectiveBinding<LoadingBinding>\n) => {\n  const vm = binding.instance\n\n  const getBindingProp = <K extends keyof LoadingOptions>(\n    key: K\n  ): LoadingOptions[K] =>\n    isObject(binding.value) ? binding.value[key] : undefined\n\n  const resolveExpression = (key: any) => {\n    const data = (isString(key) && vm?.[key]) || key\n    if (data) return ref(data)\n    else return data\n  }\n\n  const getProp = <K extends keyof LoadingOptions>(name: K) =>\n    resolveExpression(\n      getBindingProp(name) ||\n        el.getAttribute(`element-loading-${hyphenate(name)}`)\n    )\n\n  const fullscreen =\n    getBindingProp('fullscreen') ?? binding.modifiers.fullscreen\n\n  const options: LoadingOptions = {\n    text: getProp('text'),\n    svg: getProp('svg'),\n    svgViewBox: getProp('svgViewBox'),\n    spinner: getProp('spinner'),\n    background: getProp('background'),\n    customClass: getProp('customClass'),\n    fullscreen,\n    target: getBindingProp('target') ?? (fullscreen ? undefined : el),\n    body: getBindingProp('body') ?? binding.modifiers.body,\n    lock: getBindingProp('lock') ?? binding.modifiers.lock,\n  }\n  el[INSTANCE_KEY] = {\n    options,\n    instance: Loading(options),\n  }\n}\n\nconst updateOptions = (\n  newOptions: UnwrapRef<LoadingOptions>,\n  originalOptions: LoadingOptions\n) => {\n  for (const key of Object.keys(originalOptions)) {\n    if (isRef(originalOptions[key]))\n      originalOptions[key].value = newOptions[key]\n  }\n}\n\nexport const vLoading: Directive<ElementLoading, LoadingBinding> = {\n  mounted(el, binding) {\n    if (binding.value) {\n      createInstance(el, binding)\n    }\n  },\n  updated(el, binding) {\n    const instance = el[INSTANCE_KEY]\n    if (binding.oldValue !== binding.value) {\n      if (binding.value && !binding.oldValue) {\n        createInstance(el, binding)\n      } else if (binding.value && binding.oldValue) {\n        if (isObject(binding.value))\n          updateOptions(binding.value, instance!.options)\n      } else {\n        instance?.instance.close()\n      }\n    }\n  },\n  unmounted(el) {\n    el[INSTANCE_KEY]?.instance.close()\n  },\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}