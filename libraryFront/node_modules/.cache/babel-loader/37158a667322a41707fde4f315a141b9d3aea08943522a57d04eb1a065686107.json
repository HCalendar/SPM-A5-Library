{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { ref, computed, defineComponent, watch, reactive, toRefs, provide } from 'vue';\nimport '../../../tokens/index.mjs';\nimport { debugWarn } from '../../../utils/error.mjs';\nimport { elFormKey } from '../../../tokens/form.mjs';\nfunction useFormLabelWidth() {\n  const potentialLabelWidthArr = ref([]);\n  const autoLabelWidth = computed(() => {\n    if (!potentialLabelWidthArr.value.length) return \"0\";\n    const max = Math.max(...potentialLabelWidthArr.value);\n    return max ? `${max}px` : \"\";\n  });\n  function getLabelWidthIndex(width) {\n    const index = potentialLabelWidthArr.value.indexOf(width);\n    if (index === -1) {\n      debugWarn(\"Form\", `unexpected width ${width}`);\n    }\n    return index;\n  }\n  function registerLabelWidth(val, oldVal) {\n    if (val && oldVal) {\n      const index = getLabelWidthIndex(oldVal);\n      potentialLabelWidthArr.value.splice(index, 1, val);\n    } else if (val) {\n      potentialLabelWidthArr.value.push(val);\n    }\n  }\n  function deregisterLabelWidth(val) {\n    const index = getLabelWidthIndex(val);\n    index > -1 && potentialLabelWidthArr.value.splice(index, 1);\n  }\n  return {\n    autoLabelWidth,\n    registerLabelWidth,\n    deregisterLabelWidth\n  };\n}\nvar script = defineComponent({\n  name: \"ElForm\",\n  props: {\n    model: Object,\n    rules: Object,\n    labelPosition: String,\n    labelWidth: {\n      type: [String, Number],\n      default: \"\"\n    },\n    labelSuffix: {\n      type: String,\n      default: \"\"\n    },\n    inline: Boolean,\n    inlineMessage: Boolean,\n    statusIcon: Boolean,\n    showMessage: {\n      type: Boolean,\n      default: true\n    },\n    size: String,\n    disabled: Boolean,\n    validateOnRuleChange: {\n      type: Boolean,\n      default: true\n    },\n    hideRequiredAsterisk: {\n      type: Boolean,\n      default: false\n    },\n    scrollToError: Boolean\n  },\n  emits: [\"validate\"],\n  setup(props, {\n    emit\n  }) {\n    const fields = [];\n    watch(() => props.rules, () => {\n      fields.forEach(field => {\n        field.evaluateValidationEnabled();\n      });\n      if (props.validateOnRuleChange) {\n        validate(() => ({}));\n      }\n    });\n    const addField = field => {\n      if (field) {\n        fields.push(field);\n      }\n    };\n    const removeField = field => {\n      if (field.prop) {\n        fields.splice(fields.indexOf(field), 1);\n      }\n    };\n    const resetFields = () => {\n      if (!props.model) {\n        debugWarn(\"Form\", \"model is required for resetFields to work.\");\n        return;\n      }\n      fields.forEach(field => {\n        field.resetField();\n      });\n    };\n    const clearValidate = (props2 = []) => {\n      const fds = props2.length ? typeof props2 === \"string\" ? fields.filter(field => props2 === field.prop) : fields.filter(field => props2.indexOf(field.prop) > -1) : fields;\n      fds.forEach(field => {\n        field.clearValidate();\n      });\n    };\n    const validate = callback => {\n      if (!props.model) {\n        debugWarn(\"Form\", \"model is required for validate to work!\");\n        return;\n      }\n      let promise;\n      if (typeof callback !== \"function\") {\n        promise = new Promise((resolve, reject) => {\n          callback = function (valid2, invalidFields2) {\n            if (valid2) {\n              resolve(true);\n            } else {\n              reject(invalidFields2);\n            }\n          };\n        });\n      }\n      if (fields.length === 0) {\n        callback(true);\n      }\n      let valid = true;\n      let count = 0;\n      let invalidFields = {};\n      let firstInvalidFields;\n      for (const field of fields) {\n        field.validate(\"\", (message, field2) => {\n          if (message) {\n            valid = false;\n            firstInvalidFields || (firstInvalidFields = field2);\n          }\n          invalidFields = {\n            ...invalidFields,\n            ...field2\n          };\n          if (++count === fields.length) {\n            callback(valid, invalidFields);\n          }\n        });\n      }\n      if (!valid && props.scrollToError) {\n        scrollToField(Object.keys(firstInvalidFields)[0]);\n      }\n      return promise;\n    };\n    const validateField = (props2, cb) => {\n      props2 = [].concat(props2);\n      const fds = fields.filter(field => props2.indexOf(field.prop) !== -1);\n      if (!fields.length) {\n        debugWarn(\"Form\", \"please pass correct props!\");\n        return;\n      }\n      fds.forEach(field => {\n        field.validate(\"\", cb);\n      });\n    };\n    const scrollToField = prop => {\n      fields.forEach(item => {\n        if (item.prop === prop) {\n          item.$el.scrollIntoView();\n        }\n      });\n    };\n    const elForm = reactive({\n      ...toRefs(props),\n      resetFields,\n      clearValidate,\n      validateField,\n      emit,\n      addField,\n      removeField,\n      ...useFormLabelWidth()\n    });\n    provide(elFormKey, elForm);\n    return {\n      validate,\n      resetFields,\n      clearValidate,\n      validateField,\n      scrollToField\n    };\n  }\n});\nexport { script as default };","map":{"version":3,"names":["useFormLabelWidth","potentialLabelWidthArr","ref","autoLabelWidth","computed","value","length","max","Math","getLabelWidthIndex","width","index","indexOf","debugWarn","registerLabelWidth","val","oldVal","splice","push","deregisterLabelWidth","script","defineComponent","name","props","model","Object","rules","labelPosition","String","labelWidth","type","Number","default","labelSuffix","inline","Boolean","inlineMessage","statusIcon","showMessage","size","disabled","validateOnRuleChange","hideRequiredAsterisk","scrollToError","emits","setup","emit","fields","watch","forEach","field","evaluateValidationEnabled","validate","addField","removeField","prop","resetFields","resetField","clearValidate","props2","fds","filter","callback","promise","Promise","resolve","reject","valid2","invalidFields2","valid","count","invalidFields","firstInvalidFields","message","field2","scrollToField","keys","validateField","cb","concat","item","$el","scrollIntoView","elForm","reactive","toRefs","provide","elFormKey"],"sources":["../../../../../../packages/components/form/src/form.vue"],"sourcesContent":["<template>\n  <form\n    class=\"el-form\"\n    :class=\"[\n      labelPosition ? 'el-form--label-' + labelPosition : '',\n      { 'el-form--inline': inline },\n    ]\"\n  >\n    <slot></slot>\n  </form>\n</template>\n\n<script lang=\"ts\">\nimport {\n  computed,\n  defineComponent,\n  provide,\n  reactive,\n  ref,\n  toRefs,\n  watch,\n} from 'vue'\nimport { elFormKey } from '@element-plus/tokens'\nimport { debugWarn } from '@element-plus/utils/error'\nimport type { ValidateFieldsError } from 'async-validator'\n\nimport type { PropType } from 'vue'\nimport type { ComponentSize } from '@element-plus/utils/types'\nimport type { FormRulesMap } from './form.type'\nimport type {\n  ElFormItemContext as FormItemCtx,\n  ValidateFieldCallback,\n} from '@element-plus/tokens'\n\nfunction useFormLabelWidth() {\n  const potentialLabelWidthArr = ref([])\n  const autoLabelWidth = computed(() => {\n    if (!potentialLabelWidthArr.value.length) return '0'\n    const max = Math.max(...potentialLabelWidthArr.value)\n    return max ? `${max}px` : ''\n  })\n\n  function getLabelWidthIndex(width: number) {\n    const index = potentialLabelWidthArr.value.indexOf(width)\n    if (index === -1) {\n      debugWarn('Form', `unexpected width ${width}`)\n    }\n    return index\n  }\n\n  function registerLabelWidth(val: number, oldVal: number) {\n    if (val && oldVal) {\n      const index = getLabelWidthIndex(oldVal)\n      potentialLabelWidthArr.value.splice(index, 1, val)\n    } else if (val) {\n      potentialLabelWidthArr.value.push(val)\n    }\n  }\n\n  function deregisterLabelWidth(val: number) {\n    const index = getLabelWidthIndex(val)\n    index > -1 && potentialLabelWidthArr.value.splice(index, 1)\n  }\n\n  return {\n    autoLabelWidth,\n    registerLabelWidth,\n    deregisterLabelWidth,\n  }\n}\n\nexport interface Callback {\n  (isValid?: boolean, invalidFields?: ValidateFieldsError): void\n}\n\nexport default defineComponent({\n  name: 'ElForm',\n  props: {\n    model: Object,\n    rules: Object as PropType<FormRulesMap>,\n    labelPosition: String,\n    labelWidth: {\n      type: [String, Number],\n      default: '',\n    },\n    labelSuffix: {\n      type: String,\n      default: '',\n    },\n    inline: Boolean,\n    inlineMessage: Boolean,\n    statusIcon: Boolean,\n    showMessage: {\n      type: Boolean,\n      default: true,\n    },\n    size: String as PropType<ComponentSize>,\n    disabled: Boolean,\n    validateOnRuleChange: {\n      type: Boolean,\n      default: true,\n    },\n    hideRequiredAsterisk: {\n      type: Boolean,\n      default: false,\n    },\n    scrollToError: Boolean,\n  },\n  emits: ['validate'],\n  setup(props, { emit }) {\n    const fields: FormItemCtx[] = []\n\n    watch(\n      () => props.rules,\n      () => {\n        fields.forEach((field) => {\n          field.evaluateValidationEnabled()\n        })\n\n        if (props.validateOnRuleChange) {\n          validate(() => ({}))\n        }\n      }\n    )\n\n    const addField = (field: FormItemCtx) => {\n      if (field) {\n        fields.push(field)\n      }\n    }\n\n    const removeField = (field: FormItemCtx) => {\n      if (field.prop) {\n        fields.splice(fields.indexOf(field), 1)\n      }\n    }\n\n    const resetFields = () => {\n      if (!props.model) {\n        debugWarn('Form', 'model is required for resetFields to work.')\n        return\n      }\n      fields.forEach((field) => {\n        field.resetField()\n      })\n    }\n\n    const clearValidate = (props: string | string[] = []) => {\n      const fds = props.length\n        ? typeof props === 'string'\n          ? fields.filter((field) => props === field.prop)\n          : fields.filter((field) => props.indexOf(field.prop) > -1)\n        : fields\n      fds.forEach((field) => {\n        field.clearValidate()\n      })\n    }\n\n    const validate = (callback?: Callback) => {\n      if (!props.model) {\n        debugWarn('Form', 'model is required for validate to work!')\n        return\n      }\n\n      let promise: Promise<boolean> | undefined\n      // if no callback, return promise\n      if (typeof callback !== 'function') {\n        promise = new Promise((resolve, reject) => {\n          callback = function (valid, invalidFields) {\n            if (valid) {\n              resolve(true)\n            } else {\n              reject(invalidFields)\n            }\n          }\n        })\n      }\n\n      if (fields.length === 0) {\n        callback(true)\n      }\n      let valid = true\n      let count = 0\n      let invalidFields = {}\n      let firstInvalidFields\n      for (const field of fields) {\n        field.validate('', (message, field) => {\n          if (message) {\n            valid = false\n            firstInvalidFields || (firstInvalidFields = field)\n          }\n          invalidFields = { ...invalidFields, ...field }\n          if (++count === fields.length) {\n            callback(valid, invalidFields)\n          }\n        })\n      }\n      if (!valid && props.scrollToError) {\n        scrollToField(Object.keys(firstInvalidFields)[0])\n      }\n      return promise\n    }\n\n    const validateField = (\n      props: string | string[],\n      cb: ValidateFieldCallback\n    ) => {\n      props = [].concat(props)\n      const fds = fields.filter((field) => props.indexOf(field.prop) !== -1)\n      if (!fields.length) {\n        debugWarn('Form', 'please pass correct props!')\n        return\n      }\n\n      fds.forEach((field) => {\n        field.validate('', cb)\n      })\n    }\n\n    const scrollToField = (prop: string) => {\n      fields.forEach((item) => {\n        if (item.prop === prop) {\n          item.$el.scrollIntoView()\n        }\n      })\n    }\n\n    const elForm = reactive({\n      ...toRefs(props),\n      resetFields,\n      clearValidate,\n      validateField,\n      emit,\n      addField,\n      removeField,\n      ...useFormLabelWidth(),\n    })\n\n    provide(elFormKey, elForm)\n\n    return {\n      validate, // export\n      resetFields,\n      clearValidate,\n      validateField,\n      scrollToField,\n    }\n  },\n})\n</script>\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}