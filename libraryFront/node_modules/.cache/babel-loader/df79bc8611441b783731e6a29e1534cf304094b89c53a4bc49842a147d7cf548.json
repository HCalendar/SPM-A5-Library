{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { isVNode, createVNode, render } from 'vue';\nimport isServer from '../../../utils/isServer.mjs';\nimport PopupManager from '../../../utils/popup-manager.mjs';\nimport '../../../utils/util.mjs';\nimport { debugWarn } from '../../../utils/error.mjs';\nimport './notification2.mjs';\nimport { notificationTypes } from './notification.mjs';\nimport script from './notification.vue_vue_type_script_lang.mjs';\nconst notifications = {\n  \"top-left\": [],\n  \"top-right\": [],\n  \"bottom-left\": [],\n  \"bottom-right\": []\n};\nconst GAP_SIZE = 16;\nlet seed = 1;\nconst notify = function (options = {}) {\n  if (isServer) return {\n    close: () => void 0\n  };\n  if (typeof options === \"string\" || isVNode(options)) {\n    options = {\n      message: options\n    };\n  }\n  const position = options.position || \"top-right\";\n  let verticalOffset = options.offset || 0;\n  notifications[position].forEach(({\n    vm: vm2\n  }) => {\n    var _a;\n    verticalOffset += (((_a = vm2.el) == null ? void 0 : _a.offsetHeight) || 0) + GAP_SIZE;\n  });\n  verticalOffset += GAP_SIZE;\n  const id = `notification_${seed++}`;\n  const userOnClose = options.onClose;\n  const props = {\n    zIndex: PopupManager.nextZIndex(),\n    offset: verticalOffset,\n    ...options,\n    id,\n    onClose: () => {\n      close(id, position, userOnClose);\n    }\n  };\n  let appendTo = document.body;\n  if (options.appendTo instanceof HTMLElement) {\n    appendTo = options.appendTo;\n  } else if (typeof options.appendTo === \"string\") {\n    appendTo = document.querySelector(options.appendTo);\n  }\n  if (!(appendTo instanceof HTMLElement)) {\n    debugWarn(\"ElNotification\", \"the appendTo option is not an HTMLElement. Falling back to document.body.\");\n    appendTo = document.body;\n  }\n  const container = document.createElement(\"div\");\n  const vm = createVNode(script, props, isVNode(props.message) ? {\n    default: () => props.message\n  } : null);\n  vm.props.onDestroy = () => {\n    render(null, container);\n  };\n  render(vm, container);\n  notifications[position].push({\n    vm\n  });\n  appendTo.appendChild(container.firstElementChild);\n  return {\n    close: () => {\n      ;\n      vm.component.proxy.visible = false;\n    }\n  };\n};\nnotificationTypes.forEach(type => {\n  notify[type] = (options = {}) => {\n    if (typeof options === \"string\" || isVNode(options)) {\n      options = {\n        message: options\n      };\n    }\n    return notify({\n      ...options,\n      type\n    });\n  };\n});\nfunction close(id, position, userOnClose) {\n  const orientedNotifications = notifications[position];\n  const idx = orientedNotifications.findIndex(({\n    vm: vm2\n  }) => {\n    var _a;\n    return ((_a = vm2.component) == null ? void 0 : _a.props.id) === id;\n  });\n  if (idx === -1) return;\n  const {\n    vm\n  } = orientedNotifications[idx];\n  if (!vm) return;\n  userOnClose == null ? void 0 : userOnClose(vm);\n  const removedHeight = vm.el.offsetHeight;\n  const verticalPos = position.split(\"-\")[0];\n  orientedNotifications.splice(idx, 1);\n  const len = orientedNotifications.length;\n  if (len < 1) return;\n  for (let i = idx; i < len; i++) {\n    const {\n      el,\n      component\n    } = orientedNotifications[i].vm;\n    const pos = parseInt(el.style[verticalPos], 10) - removedHeight - GAP_SIZE;\n    component.props.offset = pos;\n  }\n}\nfunction closeAll() {\n  for (const orientedNotifications of Object.values(notifications)) {\n    orientedNotifications.forEach(({\n      vm\n    }) => {\n      ;\n      vm.component.proxy.visible = false;\n    });\n  }\n}\nnotify.closeAll = closeAll;\nexport { close, closeAll, notify as default };","map":{"version":3,"names":["notifications","GAP_SIZE","seed","notify","options","isServer","close","isVNode","message","position","verticalOffset","offset","forEach","vm","vm2","_a","el","offsetHeight","id","userOnClose","onClose","props","zIndex","PopupManager","nextZIndex","appendTo","document","body","HTMLElement","querySelector","debugWarn","container","createElement","createVNode","script","default","onDestroy","render","push","appendChild","firstElementChild","component","proxy","visible","notificationTypes","type","orientedNotifications","idx","findIndex","removedHeight","verticalPos","split","splice","len","length","i","pos","parseInt","style","Object","values","closeAll"],"sources":["../../../../../../packages/components/notification/src/notify.ts"],"sourcesContent":["import { createVNode, render } from 'vue'\nimport isServer from '@element-plus/utils/isServer'\nimport PopupManager from '@element-plus/utils/popup-manager'\nimport { isVNode } from '@element-plus/utils/util'\nimport { debugWarn } from '@element-plus/utils/error'\nimport NotificationConstructor from './notification.vue'\nimport { notificationTypes } from './notification'\n\nimport type { ComponentPublicInstance, VNode } from 'vue'\nimport type {\n  NotificationOptions,\n  Notify,\n  NotifyFn,\n  NotificationQueue,\n  NotificationProps,\n} from './notification'\n\n// This should be a queue but considering there were `non-autoclosable` notifications.\nconst notifications: Record<\n  NotificationOptions['position'],\n  NotificationQueue\n> = {\n  'top-left': [],\n  'top-right': [],\n  'bottom-left': [],\n  'bottom-right': [],\n}\n\n// the gap size between each notification\nconst GAP_SIZE = 16\nlet seed = 1\n\nconst notify: NotifyFn & Partial<Notify> = function (options = {}) {\n  if (isServer) return { close: () => undefined }\n\n  if (typeof options === 'string' || isVNode(options)) {\n    options = { message: options }\n  }\n\n  const position = options.position || 'top-right'\n\n  let verticalOffset = options.offset || 0\n  notifications[position].forEach(({ vm }) => {\n    verticalOffset += (vm.el?.offsetHeight || 0) + GAP_SIZE\n  })\n  verticalOffset += GAP_SIZE\n\n  const id = `notification_${seed++}`\n  const userOnClose = options.onClose\n  const props: Partial<NotificationProps> = {\n    // default options end\n    zIndex: PopupManager.nextZIndex(),\n    offset: verticalOffset,\n    ...options,\n    id,\n    onClose: () => {\n      close(id, position, userOnClose)\n    },\n  }\n\n  let appendTo: HTMLElement | null = document.body\n  if (options.appendTo instanceof HTMLElement) {\n    appendTo = options.appendTo\n  } else if (typeof options.appendTo === 'string') {\n    appendTo = document.querySelector(options.appendTo)\n  }\n\n  // should fallback to default value with a warning\n  if (!(appendTo instanceof HTMLElement)) {\n    debugWarn(\n      'ElNotification',\n      'the appendTo option is not an HTMLElement. Falling back to document.body.'\n    )\n    appendTo = document.body\n  }\n\n  const container = document.createElement('div')\n\n  const vm = createVNode(\n    NotificationConstructor,\n    props,\n    isVNode(props.message)\n      ? {\n          default: () => props.message,\n        }\n      : null\n  )\n\n  // clean notification element preventing mem leak\n  vm.props!.onDestroy = () => {\n    render(null, container)\n  }\n\n  // instances will remove this item when close function gets called. So we do not need to worry about it.\n  render(vm, container)\n  notifications[position].push({ vm })\n  appendTo.appendChild(container.firstElementChild!)\n\n  return {\n    // instead of calling the onClose function directly, setting this value so that we can have the full lifecycle\n    // for out component, so that all closing steps will not be skipped.\n    close: () => {\n      ;(\n        vm.component!.proxy as ComponentPublicInstance<{ visible: boolean }>\n      ).visible = false\n    },\n  }\n}\nnotificationTypes.forEach((type) => {\n  notify[type] = (options = {}) => {\n    if (typeof options === 'string' || isVNode(options)) {\n      options = {\n        message: options,\n      }\n    }\n    return notify({\n      ...options,\n      type,\n    })\n  }\n})\n\n/**\n * This function gets called when user click `x` button or press `esc` or the time reached its limitation.\n * Emitted by transition@before-leave event so that we can fetch the current notification.offsetHeight, if this was called\n * by @after-leave the DOM element will be removed from the page thus we can no longer fetch the offsetHeight.\n * @param {String} id notification id to be closed\n * @param {Position} position the positioning strategy\n * @param {Function} userOnClose the callback called when close passed by user\n */\nexport function close(\n  id: string,\n  position: NotificationOptions['position'],\n  userOnClose?: (vm: VNode) => void\n): void {\n  // maybe we can store the index when inserting the vm to notification list.\n  const orientedNotifications = notifications[position]\n  const idx = orientedNotifications.findIndex(\n    ({ vm }) => vm.component?.props.id === id\n  )\n  if (idx === -1) return\n  const { vm } = orientedNotifications[idx]\n  if (!vm) return\n  // calling user's on close function before notification gets removed from DOM.\n  userOnClose?.(vm)\n\n  // note that this is called @before-leave, that's why we were able to fetch this property.\n  const removedHeight = vm.el!.offsetHeight\n  const verticalPos = position.split('-')[0]\n  orientedNotifications.splice(idx, 1)\n  const len = orientedNotifications.length\n  if (len < 1) return\n  // starting from the removing item.\n  for (let i = idx; i < len; i++) {\n    // new position equals the current offsetTop minus removed height plus 16px(the gap size between each item)\n    const { el, component } = orientedNotifications[i].vm\n    const pos = parseInt(el!.style[verticalPos], 10) - removedHeight - GAP_SIZE\n    component!.props.offset = pos\n  }\n}\n\nexport function closeAll(): void {\n  // loop through all directions, close them at once.\n  for (const orientedNotifications of Object.values(notifications)) {\n    orientedNotifications.forEach(({ vm }) => {\n      // same as the previous close method, we'd like to make sure lifecycle gets handle properly.\n      ;(\n        vm.component!.proxy as ComponentPublicInstance<{ visible: boolean }>\n      ).visible = false\n    })\n  }\n}\n\nnotify.closeAll = closeAll\n\nexport default notify as Notify\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}