{"ast":null,"code":"import { ref, provide } from 'vue';\nimport { removeClass, addClass } from '../../../../utils/dom.mjs';\nconst dragEventsKey = Symbol(\"dragEvents\");\nfunction useDragNodeHandler({\n  props,\n  ctx,\n  el$,\n  dropIndicator$,\n  store\n}) {\n  const dragState = ref({\n    showDropIndicator: false,\n    draggingNode: null,\n    dropNode: null,\n    allowDrop: true,\n    dropType: null\n  });\n  const treeNodeDragStart = ({\n    event,\n    treeNode\n  }) => {\n    if (typeof props.allowDrag === \"function\" && !props.allowDrag(treeNode.node)) {\n      event.preventDefault();\n      return false;\n    }\n    event.dataTransfer.effectAllowed = \"move\";\n    try {\n      event.dataTransfer.setData(\"text/plain\", \"\");\n    } catch (e) {}\n    dragState.value.draggingNode = treeNode;\n    ctx.emit(\"node-drag-start\", treeNode.node, event);\n  };\n  const treeNodeDragOver = ({\n    event,\n    treeNode\n  }) => {\n    const dropNode = treeNode;\n    const oldDropNode = dragState.value.dropNode;\n    if (oldDropNode && oldDropNode !== dropNode) {\n      removeClass(oldDropNode.$el, \"is-drop-inner\");\n    }\n    const draggingNode = dragState.value.draggingNode;\n    if (!draggingNode || !dropNode) return;\n    let dropPrev = true;\n    let dropInner = true;\n    let dropNext = true;\n    let userAllowDropInner = true;\n    if (typeof props.allowDrop === \"function\") {\n      dropPrev = props.allowDrop(draggingNode.node, dropNode.node, \"prev\");\n      userAllowDropInner = dropInner = props.allowDrop(draggingNode.node, dropNode.node, \"inner\");\n      dropNext = props.allowDrop(draggingNode.node, dropNode.node, \"next\");\n    }\n    event.dataTransfer.dropEffect = dropInner ? \"move\" : \"none\";\n    if ((dropPrev || dropInner || dropNext) && oldDropNode !== dropNode) {\n      if (oldDropNode) {\n        ctx.emit(\"node-drag-leave\", draggingNode.node, oldDropNode.node, event);\n      }\n      ctx.emit(\"node-drag-enter\", draggingNode.node, dropNode.node, event);\n    }\n    if (dropPrev || dropInner || dropNext) {\n      dragState.value.dropNode = dropNode;\n    }\n    if (dropNode.node.nextSibling === draggingNode.node) {\n      dropNext = false;\n    }\n    if (dropNode.node.previousSibling === draggingNode.node) {\n      dropPrev = false;\n    }\n    if (dropNode.node.contains(draggingNode.node, false)) {\n      dropInner = false;\n    }\n    if (draggingNode.node === dropNode.node || draggingNode.node.contains(dropNode.node)) {\n      dropPrev = false;\n      dropInner = false;\n      dropNext = false;\n    }\n    const targetPosition = dropNode.$el.getBoundingClientRect();\n    const treePosition = el$.value.getBoundingClientRect();\n    let dropType;\n    const prevPercent = dropPrev ? dropInner ? 0.25 : dropNext ? 0.45 : 1 : -1;\n    const nextPercent = dropNext ? dropInner ? 0.75 : dropPrev ? 0.55 : 0 : 1;\n    let indicatorTop = -9999;\n    const distance = event.clientY - targetPosition.top;\n    if (distance < targetPosition.height * prevPercent) {\n      dropType = \"before\";\n    } else if (distance > targetPosition.height * nextPercent) {\n      dropType = \"after\";\n    } else if (dropInner) {\n      dropType = \"inner\";\n    } else {\n      dropType = \"none\";\n    }\n    const iconPosition = dropNode.$el.querySelector(\".el-tree-node__expand-icon\").getBoundingClientRect();\n    const dropIndicator = dropIndicator$.value;\n    if (dropType === \"before\") {\n      indicatorTop = iconPosition.top - treePosition.top;\n    } else if (dropType === \"after\") {\n      indicatorTop = iconPosition.bottom - treePosition.top;\n    }\n    dropIndicator.style.top = `${indicatorTop}px`;\n    dropIndicator.style.left = `${iconPosition.right - treePosition.left}px`;\n    if (dropType === \"inner\") {\n      addClass(dropNode.$el, \"is-drop-inner\");\n    } else {\n      removeClass(dropNode.$el, \"is-drop-inner\");\n    }\n    dragState.value.showDropIndicator = dropType === \"before\" || dropType === \"after\";\n    dragState.value.allowDrop = dragState.value.showDropIndicator || userAllowDropInner;\n    dragState.value.dropType = dropType;\n    ctx.emit(\"node-drag-over\", draggingNode.node, dropNode.node, event);\n  };\n  const treeNodeDragEnd = event => {\n    const {\n      draggingNode,\n      dropType,\n      dropNode\n    } = dragState.value;\n    event.preventDefault();\n    event.dataTransfer.dropEffect = \"move\";\n    if (draggingNode && dropNode) {\n      const draggingNodeCopy = {\n        data: draggingNode.node.data\n      };\n      if (dropType !== \"none\") {\n        draggingNode.node.remove();\n      }\n      if (dropType === \"before\") {\n        dropNode.node.parent.insertBefore(draggingNodeCopy, dropNode.node);\n      } else if (dropType === \"after\") {\n        dropNode.node.parent.insertAfter(draggingNodeCopy, dropNode.node);\n      } else if (dropType === \"inner\") {\n        dropNode.node.insertChild(draggingNodeCopy);\n      }\n      if (dropType !== \"none\") {\n        store.value.registerNode(draggingNodeCopy);\n      }\n      removeClass(dropNode.$el, \"is-drop-inner\");\n      ctx.emit(\"node-drag-end\", draggingNode.node, dropNode.node, dropType, event);\n      if (dropType !== \"none\") {\n        ctx.emit(\"node-drop\", draggingNode.node, dropNode.node, dropType, event);\n      }\n    }\n    if (draggingNode && !dropNode) {\n      ctx.emit(\"node-drag-end\", draggingNode.node, null, dropType, event);\n    }\n    dragState.value.showDropIndicator = false;\n    dragState.value.draggingNode = null;\n    dragState.value.dropNode = null;\n    dragState.value.allowDrop = true;\n  };\n  provide(dragEventsKey, {\n    treeNodeDragStart,\n    treeNodeDragOver,\n    treeNodeDragEnd\n  });\n  return {\n    dragState\n  };\n}\nexport { dragEventsKey, useDragNodeHandler };","map":{"version":3,"names":["dragEventsKey","Symbol","props","ctx","el$","dropIndicator$","store","dragState","ref","showDropIndicator","draggingNode","dropNode","allowDrop","dropType","treeNodeDragStart","event","treeNode","allowDrag","node","preventDefault","dataTransfer","effectAllowed","setData","e","value","emit","treeNodeDragOver","oldDropNode","removeClass","$el","dropPrev","dropInner","dropNext","userAllowDropInner","dropEffect","nextSibling","previousSibling","contains","targetPosition","getBoundingClientRect","treePosition","prevPercent","nextPercent","indicatorTop","distance","clientY","top","height","iconPosition","querySelector","dropIndicator","bottom","style","left","right","addClass","treeNodeDragEnd","draggingNodeCopy","data","remove","parent","insertBefore","insertAfter","insertChild","registerNode","provide"],"sources":["../../../../../../../packages/components/tree/src/model/useDragNode.ts"],"sourcesContent":["import { provide, ref } from 'vue'\nimport { addClass, removeClass } from '@element-plus/utils/dom'\nimport type { InjectionKey } from 'vue'\nimport type Node from './node'\n\ninterface TreeNode {\n  node: Node\n  $el?: HTMLElement\n}\n\ninterface DragOptions {\n  event: DragEvent\n  treeNode: TreeNode\n}\n\nexport interface DragEvents {\n  treeNodeDragStart: (options: DragOptions) => void\n  treeNodeDragOver: (options: DragOptions) => void\n  treeNodeDragEnd: (event: DragEvent) => void\n}\n\nexport const dragEventsKey: InjectionKey<DragEvents> = Symbol('dragEvents')\n\nexport function useDragNodeHandler({ props, ctx, el$, dropIndicator$, store }) {\n  const dragState = ref({\n    showDropIndicator: false,\n    draggingNode: null,\n    dropNode: null,\n    allowDrop: true,\n    dropType: null,\n  })\n\n  const treeNodeDragStart = ({ event, treeNode }: DragOptions) => {\n    if (\n      typeof props.allowDrag === 'function' &&\n      !props.allowDrag(treeNode.node)\n    ) {\n      event.preventDefault()\n      return false\n    }\n    event.dataTransfer.effectAllowed = 'move'\n\n    // wrap in try catch to address IE's error when first param is 'text/plain'\n    try {\n      // setData is required for draggable to work in FireFox\n      // the content has to be '' so dragging a node out of the tree won't open a new tab in FireFox\n      event.dataTransfer.setData('text/plain', '')\n    } catch (e) {}\n    dragState.value.draggingNode = treeNode\n    ctx.emit('node-drag-start', treeNode.node, event)\n  }\n\n  const treeNodeDragOver = ({ event, treeNode }: DragOptions) => {\n    const dropNode = treeNode\n    const oldDropNode = dragState.value.dropNode\n    if (oldDropNode && oldDropNode !== dropNode) {\n      removeClass(oldDropNode.$el, 'is-drop-inner')\n    }\n    const draggingNode = dragState.value.draggingNode\n    if (!draggingNode || !dropNode) return\n\n    let dropPrev = true\n    let dropInner = true\n    let dropNext = true\n    let userAllowDropInner = true\n    if (typeof props.allowDrop === 'function') {\n      dropPrev = props.allowDrop(draggingNode.node, dropNode.node, 'prev')\n      userAllowDropInner = dropInner = props.allowDrop(\n        draggingNode.node,\n        dropNode.node,\n        'inner'\n      )\n      dropNext = props.allowDrop(draggingNode.node, dropNode.node, 'next')\n    }\n    event.dataTransfer.dropEffect = dropInner ? 'move' : 'none'\n    if ((dropPrev || dropInner || dropNext) && oldDropNode !== dropNode) {\n      if (oldDropNode) {\n        ctx.emit('node-drag-leave', draggingNode.node, oldDropNode.node, event)\n      }\n      ctx.emit('node-drag-enter', draggingNode.node, dropNode.node, event)\n    }\n\n    if (dropPrev || dropInner || dropNext) {\n      dragState.value.dropNode = dropNode\n    }\n\n    if (dropNode.node.nextSibling === draggingNode.node) {\n      dropNext = false\n    }\n    if (dropNode.node.previousSibling === draggingNode.node) {\n      dropPrev = false\n    }\n    if (dropNode.node.contains(draggingNode.node, false)) {\n      dropInner = false\n    }\n    if (\n      draggingNode.node === dropNode.node ||\n      draggingNode.node.contains(dropNode.node)\n    ) {\n      dropPrev = false\n      dropInner = false\n      dropNext = false\n    }\n\n    const targetPosition = dropNode.$el.getBoundingClientRect()\n    const treePosition = el$.value.getBoundingClientRect()\n\n    let dropType\n    const prevPercent = dropPrev ? (dropInner ? 0.25 : dropNext ? 0.45 : 1) : -1\n    const nextPercent = dropNext ? (dropInner ? 0.75 : dropPrev ? 0.55 : 0) : 1\n\n    let indicatorTop = -9999\n    const distance = event.clientY - targetPosition.top\n    if (distance < targetPosition.height * prevPercent) {\n      dropType = 'before'\n    } else if (distance > targetPosition.height * nextPercent) {\n      dropType = 'after'\n    } else if (dropInner) {\n      dropType = 'inner'\n    } else {\n      dropType = 'none'\n    }\n\n    const iconPosition = dropNode.$el\n      .querySelector('.el-tree-node__expand-icon')\n      .getBoundingClientRect()\n    const dropIndicator = dropIndicator$.value\n    if (dropType === 'before') {\n      indicatorTop = iconPosition.top - treePosition.top\n    } else if (dropType === 'after') {\n      indicatorTop = iconPosition.bottom - treePosition.top\n    }\n    dropIndicator.style.top = `${indicatorTop}px`\n    dropIndicator.style.left = `${iconPosition.right - treePosition.left}px`\n\n    if (dropType === 'inner') {\n      addClass(dropNode.$el, 'is-drop-inner')\n    } else {\n      removeClass(dropNode.$el, 'is-drop-inner')\n    }\n\n    dragState.value.showDropIndicator =\n      dropType === 'before' || dropType === 'after'\n    dragState.value.allowDrop =\n      dragState.value.showDropIndicator || userAllowDropInner\n    dragState.value.dropType = dropType\n    ctx.emit('node-drag-over', draggingNode.node, dropNode.node, event)\n  }\n\n  const treeNodeDragEnd = (event: DragEvent) => {\n    const { draggingNode, dropType, dropNode } = dragState.value\n    event.preventDefault()\n    event.dataTransfer.dropEffect = 'move'\n\n    if (draggingNode && dropNode) {\n      const draggingNodeCopy = { data: draggingNode.node.data }\n      if (dropType !== 'none') {\n        draggingNode.node.remove()\n      }\n      if (dropType === 'before') {\n        dropNode.node.parent.insertBefore(draggingNodeCopy, dropNode.node)\n      } else if (dropType === 'after') {\n        dropNode.node.parent.insertAfter(draggingNodeCopy, dropNode.node)\n      } else if (dropType === 'inner') {\n        dropNode.node.insertChild(draggingNodeCopy)\n      }\n      if (dropType !== 'none') {\n        store.value.registerNode(draggingNodeCopy)\n      }\n\n      removeClass(dropNode.$el, 'is-drop-inner')\n\n      ctx.emit(\n        'node-drag-end',\n        draggingNode.node,\n        dropNode.node,\n        dropType,\n        event\n      )\n      if (dropType !== 'none') {\n        ctx.emit('node-drop', draggingNode.node, dropNode.node, dropType, event)\n      }\n    }\n    if (draggingNode && !dropNode) {\n      ctx.emit('node-drag-end', draggingNode.node, null, dropType, event)\n    }\n\n    dragState.value.showDropIndicator = false\n    dragState.value.draggingNode = null\n    dragState.value.dropNode = null\n    dragState.value.allowDrop = true\n  }\n\n  provide(dragEventsKey, {\n    treeNodeDragStart,\n    treeNodeDragOver,\n    treeNodeDragEnd,\n  })\n\n  return {\n    dragState,\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}