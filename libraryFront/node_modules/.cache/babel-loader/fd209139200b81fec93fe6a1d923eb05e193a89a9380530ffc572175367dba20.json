{"ast":null,"code":"import { computed } from 'vue';\nconst useMarks = props => {\n  return computed(() => {\n    if (!props.marks) {\n      return [];\n    }\n    const marksKeys = Object.keys(props.marks);\n    return marksKeys.map(parseFloat).sort((a, b) => a - b).filter(point => point <= props.max && point >= props.min).map(point => ({\n      point,\n      position: (point - props.min) * 100 / (props.max - props.min),\n      mark: props.marks[point]\n    }));\n  });\n};\nexport { useMarks };","map":{"version":3,"names":["useMarks","props","computed","marks","marksKeys","Object","keys","map","parseFloat","sort","a","b","filter","point","max","min","position","mark"],"sources":["../../../../../../packages/components/slider/src/useMarks.ts"],"sourcesContent":["import { computed } from 'vue'\nimport type { ISliderProps, Mark } from './slider.type'\n\nexport const useMarks = (props: ISliderProps) => {\n  return computed(() => {\n    if (!props.marks) {\n      return []\n    }\n\n    const marksKeys = Object.keys(props.marks)\n    return marksKeys\n      .map(parseFloat)\n      .sort((a, b) => a - b)\n      .filter((point) => point <= props.max && point >= props.min)\n      .map(\n        (point): Mark => ({\n          point,\n          position: ((point - props.min) * 100) / (props.max - props.min),\n          mark: props.marks[point],\n        })\n      )\n  })\n}\n"],"mappings":";MAGaA,QAAA,GAAYC,KAAA,IAAwB;EAC/C,OAAOC,QAAA,CAAS,MAAM;IACpB,IAAI,CAACD,KAAA,CAAME,KAAA,EAAO;MAChB,OAAO;IAAA;IAGT,MAAMC,SAAA,GAAYC,MAAA,CAAOC,IAAA,CAAKL,KAAA,CAAME,KAAA;IACpC,OAAOC,SAAA,CACJG,GAAA,CAAIC,UAAA,EACJC,IAAA,CAAK,CAACC,CAAA,EAAGC,CAAA,KAAMD,CAAA,GAAIC,CAAA,EACnBC,MAAA,CAAQC,KAAA,IAAUA,KAAA,IAASZ,KAAA,CAAMa,GAAA,IAAOD,KAAA,IAASZ,KAAA,CAAMc,GAAA,EACvDR,GAAA,CACEM,KAAA;MACCA,KAAA;MACAG,QAAA,EAAY,CAAAH,KAAA,GAAQZ,KAAA,CAAMc,GAAA,IAAO,OAAAd,KAAA,CAAca,GAAA,GAAMb,KAAA,CAAMc,GAAA;MAC3DE,IAAA,EAAMhB,KAAA,CAAME,KAAA,CAAMU,KAAA;IAAA;EAAA;AAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}