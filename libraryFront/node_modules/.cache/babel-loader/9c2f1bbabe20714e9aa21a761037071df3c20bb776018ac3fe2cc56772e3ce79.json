{"ast":null,"code":"import { getCurrentInstance, computed } from 'vue';\nimport '../../utils/util.mjs';\nimport { isArray } from '@vue/shared';\nconst DEFAULT_TRIGGER = \"hover\";\nconst useTargetEvents = (onShow, onHide, onToggle) => {\n  const {\n    props\n  } = getCurrentInstance();\n  let triggerFocused = false;\n  const popperEventsHandler = e => {\n    e.stopPropagation();\n    switch (e.type) {\n      case \"click\":\n        {\n          if (triggerFocused) {\n            triggerFocused = false;\n          } else {\n            onToggle();\n          }\n          break;\n        }\n      case \"mouseenter\":\n        {\n          onShow();\n          break;\n        }\n      case \"mouseleave\":\n        {\n          onHide();\n          break;\n        }\n      case \"focus\":\n        {\n          triggerFocused = true;\n          onShow();\n          break;\n        }\n      case \"blur\":\n        {\n          triggerFocused = false;\n          onHide();\n          break;\n        }\n    }\n  };\n  const triggerEventsMap = {\n    click: [\"onClick\"],\n    hover: [\"onMouseenter\", \"onMouseleave\"],\n    focus: [\"onFocus\", \"onBlur\"]\n  };\n  const mapEvents = t => {\n    var _a;\n    const events = {};\n    (_a = triggerEventsMap[t]) == null ? void 0 : _a.forEach(event => {\n      events[event] = popperEventsHandler;\n    });\n    return events;\n  };\n  return computed(() => {\n    if (isArray(props.trigger)) {\n      return Object.values(props.trigger).reduce((pre, t) => {\n        return {\n          ...pre,\n          ...mapEvents(t)\n        };\n      }, {});\n    } else {\n      return mapEvents(props.trigger);\n    }\n  });\n};\nexport { DEFAULT_TRIGGER, useTargetEvents };","map":{"version":3,"names":["DEFAULT_TRIGGER","useTargetEvents","onShow","onHide","onToggle","props","getCurrentInstance","triggerFocused","popperEventsHandler","e","stopPropagation","type","triggerEventsMap","click","hover","focus","mapEvents","t","_a","events","forEach","event","computed","isArray","trigger","Object","values","reduce","pre"],"sources":["../../../../../packages/hooks/use-popper/use-target-events.ts"],"sourcesContent":["import { computed, getCurrentInstance } from 'vue'\nimport { isArray } from '@element-plus/utils/util'\n\nexport type TriggerType = 'click' | 'hover' | 'focus' | 'manual'\nexport type Trigger = TriggerType | TriggerType[]\n\nexport interface PopperEvents {\n  onClick?: (e: Event) => void\n  onMouseenter?: (e: Event) => void\n  onMouseleave?: (e: Event) => void\n  onFocus?: (e: Event) => void\n  onBlur?: (e: Event) => void\n}\n\nexport const DEFAULT_TRIGGER = 'hover'\n\ntype Handler = () => void\n\nexport const useTargetEvents = (\n  onShow: Handler,\n  onHide: Handler,\n  onToggle: Handler\n) => {\n  const { props } = getCurrentInstance()!\n\n  let triggerFocused = false\n\n  const popperEventsHandler = (e: Event) => {\n    e.stopPropagation()\n    switch (e.type) {\n      case 'click': {\n        if (triggerFocused) {\n          // reset previous focus event\n          triggerFocused = false\n        } else {\n          onToggle()\n        }\n        break\n      }\n      case 'mouseenter': {\n        onShow()\n        break\n      }\n      case 'mouseleave': {\n        onHide()\n        break\n      }\n      case 'focus': {\n        triggerFocused = true\n        onShow()\n        break\n      }\n      case 'blur': {\n        triggerFocused = false\n        onHide()\n        break\n      }\n    }\n  }\n\n  const triggerEventsMap: Partial<Record<TriggerType, (keyof PopperEvents)[]>> =\n    {\n      click: ['onClick'],\n      hover: ['onMouseenter', 'onMouseleave'],\n      focus: ['onFocus', 'onBlur'],\n    }\n\n  const mapEvents = (t: TriggerType) => {\n    const events = {} as PopperEvents\n    triggerEventsMap[t]?.forEach((event) => {\n      events[event] = popperEventsHandler\n    })\n\n    return events\n  }\n\n  return computed(() => {\n    if (isArray(props.trigger)) {\n      return Object.values(props.trigger).reduce((pre, t) => {\n        return {\n          ...pre,\n          ...mapEvents(t),\n        }\n      }, {})\n    } else {\n      return mapEvents(props.trigger as TriggerType)\n    }\n  })\n}\n"],"mappings":";;;MAcaA,eAAA,GAAkB;MAIlBC,eAAA,GAAkBA,CAC7BC,MAAA,EACAC,MAAA,EACAC,QAAA,KACG;EACH,MAAM;IAAEC;EAAA,IAAUC,kBAAA;EAElB,IAAIC,cAAA,GAAiB;EAErB,MAAMC,mBAAA,GAAuBC,CAAA,IAAa;IACxCA,CAAA,CAAEC,eAAA;IACF,QAAQD,CAAA,CAAEE,IAAA;MAAA,KACH;QAAS;UACZ,IAAIJ,cAAA,EAAgB;YAElBA,cAAA,GAAiB;UAAA,OACZ;YACLH,QAAA;UAAA;UAEF;QAAA;MAAA,KAEG;QAAc;UACjBF,MAAA;UACA;QAAA;MAAA,KAEG;QAAc;UACjBC,MAAA;UACA;QAAA;MAAA,KAEG;QAAS;UACZI,cAAA,GAAiB;UACjBL,MAAA;UACA;QAAA;MAAA,KAEG;QAAQ;UACXK,cAAA,GAAiB;UACjBJ,MAAA;UACA;QAAA;IAAA;EAAA;EAKN,MAAMS,gBAAA,GACJ;IACEC,KAAA,EAAO,CAAC;IACRC,KAAA,EAAO,CAAC,gBAAgB;IACxBC,KAAA,EAAO,CAAC,WAAW;EAAA;EAGvB,MAAMC,SAAA,GAAaC,CAAA,IAAmB;IAnExC,IAAAC,EAAA;IAoEI,MAAMC,MAAA,GAAS;IACf,CAAAD,EAAA,GAAAN,gBAAA,CAAiBK,CAAA,MAAjB,gBAAAC,EAAA,CAAqBE,OAAA,CAASC,KAAA,IAAU;MACtCF,MAAA,CAAOE,KAAA,IAASb,mBAAA;IAAA;IAGlB,OAAOW,MAAA;EAAA;EAGT,OAAOG,QAAA,CAAS,MAAM;IACpB,IAAIC,OAAA,CAAQlB,KAAA,CAAMmB,OAAA,GAAU;MAC1B,OAAOC,MAAA,CAAOC,MAAA,CAAOrB,KAAA,CAAMmB,OAAA,EAASG,MAAA,CAAO,CAACC,GAAA,EAAKX,CAAA,KAAM;QACrD,OAAO;UAAA,GACFW,GAAA;UAAA,GACAZ,SAAA,CAAUC,CAAA;QAAA;MAAA,GAEd;IAAA,OACE;MACL,OAAOD,SAAA,CAAUX,KAAA,CAAMmB,OAAA;IAAA;EAAA;AAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}