{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { hasOwn } from '@vue/shared';\nimport Node from './node.mjs';\nimport { getNodeKey } from './util.mjs';\nclass TreeStore {\n  constructor(options) {\n    this.currentNode = null;\n    this.currentNodeKey = null;\n    for (const option in options) {\n      if (hasOwn(options, option)) {\n        this[option] = options[option];\n      }\n    }\n    this.nodesMap = {};\n  }\n  initialize() {\n    this.root = new Node({\n      data: this.data,\n      store: this\n    });\n    this.root.initialize();\n    if (this.lazy && this.load) {\n      const loadFn = this.load;\n      loadFn(this.root, data => {\n        this.root.doCreateChildren(data);\n        this._initDefaultCheckedNodes();\n      });\n    } else {\n      this._initDefaultCheckedNodes();\n    }\n  }\n  filter(value) {\n    const filterNodeMethod = this.filterNodeMethod;\n    const lazy = this.lazy;\n    const traverse = function (node) {\n      const childNodes = node.root ? node.root.childNodes : node.childNodes;\n      childNodes.forEach(child => {\n        child.visible = filterNodeMethod.call(child, value, child.data, child);\n        traverse(child);\n      });\n      if (!node.visible && childNodes.length) {\n        let allHidden = true;\n        allHidden = !childNodes.some(child => child.visible);\n        if (node.root) {\n          ;\n          node.root.visible = allHidden === false;\n        } else {\n          ;\n          node.visible = allHidden === false;\n        }\n      }\n      if (!value) return;\n      if (node.visible && !node.isLeaf && !lazy) node.expand();\n    };\n    traverse(this);\n  }\n  setData(newVal) {\n    const instanceChanged = newVal !== this.root.data;\n    if (instanceChanged) {\n      this.root.setData(newVal);\n      this._initDefaultCheckedNodes();\n    } else {\n      this.root.updateChildren();\n    }\n  }\n  getNode(data) {\n    if (data instanceof Node) return data;\n    const key = typeof data !== \"object\" ? data : getNodeKey(this.key, data);\n    return this.nodesMap[key] || null;\n  }\n  insertBefore(data, refData) {\n    const refNode = this.getNode(refData);\n    refNode.parent.insertBefore({\n      data\n    }, refNode);\n  }\n  insertAfter(data, refData) {\n    const refNode = this.getNode(refData);\n    refNode.parent.insertAfter({\n      data\n    }, refNode);\n  }\n  remove(data) {\n    const node = this.getNode(data);\n    if (node && node.parent) {\n      if (node === this.currentNode) {\n        this.currentNode = null;\n      }\n      node.parent.removeChild(node);\n    }\n  }\n  append(data, parentData) {\n    const parentNode = parentData ? this.getNode(parentData) : this.root;\n    if (parentNode) {\n      parentNode.insertChild({\n        data\n      });\n    }\n  }\n  _initDefaultCheckedNodes() {\n    const defaultCheckedKeys = this.defaultCheckedKeys || [];\n    const nodesMap = this.nodesMap;\n    defaultCheckedKeys.forEach(checkedKey => {\n      const node = nodesMap[checkedKey];\n      if (node) {\n        node.setChecked(true, !this.checkStrictly);\n      }\n    });\n  }\n  _initDefaultCheckedNode(node) {\n    const defaultCheckedKeys = this.defaultCheckedKeys || [];\n    if (defaultCheckedKeys.indexOf(node.key) !== -1) {\n      node.setChecked(true, !this.checkStrictly);\n    }\n  }\n  setDefaultCheckedKey(newVal) {\n    if (newVal !== this.defaultCheckedKeys) {\n      this.defaultCheckedKeys = newVal;\n      this._initDefaultCheckedNodes();\n    }\n  }\n  registerNode(node) {\n    const key = this.key;\n    if (!node || !node.data) return;\n    if (!key) {\n      this.nodesMap[node.id] = node;\n    } else {\n      const nodeKey = node.key;\n      if (nodeKey !== void 0) this.nodesMap[node.key] = node;\n    }\n  }\n  deregisterNode(node) {\n    const key = this.key;\n    if (!key || !node || !node.data) return;\n    node.childNodes.forEach(child => {\n      this.deregisterNode(child);\n    });\n    delete this.nodesMap[node.key];\n  }\n  getCheckedNodes(leafOnly = false, includeHalfChecked = false) {\n    const checkedNodes = [];\n    const traverse = function (node) {\n      const childNodes = node.root ? node.root.childNodes : node.childNodes;\n      childNodes.forEach(child => {\n        if ((child.checked || includeHalfChecked && child.indeterminate) && (!leafOnly || leafOnly && child.isLeaf)) {\n          checkedNodes.push(child.data);\n        }\n        traverse(child);\n      });\n    };\n    traverse(this);\n    return checkedNodes;\n  }\n  getCheckedKeys(leafOnly = false) {\n    return this.getCheckedNodes(leafOnly).map(data => (data || {})[this.key]);\n  }\n  getHalfCheckedNodes() {\n    const nodes = [];\n    const traverse = function (node) {\n      const childNodes = node.root ? node.root.childNodes : node.childNodes;\n      childNodes.forEach(child => {\n        if (child.indeterminate) {\n          nodes.push(child.data);\n        }\n        traverse(child);\n      });\n    };\n    traverse(this);\n    return nodes;\n  }\n  getHalfCheckedKeys() {\n    return this.getHalfCheckedNodes().map(data => (data || {})[this.key]);\n  }\n  _getAllNodes() {\n    const allNodes = [];\n    const nodesMap = this.nodesMap;\n    for (const nodeKey in nodesMap) {\n      if (hasOwn(nodesMap, nodeKey)) {\n        allNodes.push(nodesMap[nodeKey]);\n      }\n    }\n    return allNodes;\n  }\n  updateChildren(key, data) {\n    const node = this.nodesMap[key];\n    if (!node) return;\n    const childNodes = node.childNodes;\n    for (let i = childNodes.length - 1; i >= 0; i--) {\n      const child = childNodes[i];\n      this.remove(child.data);\n    }\n    for (let i = 0, j = data.length; i < j; i++) {\n      const child = data[i];\n      this.append(child, node.data);\n    }\n  }\n  _setCheckedKeys(key, leafOnly = false, checkedKeys) {\n    const allNodes = this._getAllNodes().sort((a, b) => b.level - a.level);\n    const cache = Object.create(null);\n    const keys = Object.keys(checkedKeys);\n    allNodes.forEach(node => node.setChecked(false, false));\n    for (let i = 0, j = allNodes.length; i < j; i++) {\n      const node = allNodes[i];\n      const nodeKey = node.data[key].toString();\n      const checked = keys.indexOf(nodeKey) > -1;\n      if (!checked) {\n        if (node.checked && !cache[nodeKey]) {\n          node.setChecked(false, false);\n        }\n        continue;\n      }\n      let parent = node.parent;\n      while (parent && parent.level > 0) {\n        cache[parent.data[key]] = true;\n        parent = parent.parent;\n      }\n      if (node.isLeaf || this.checkStrictly) {\n        node.setChecked(true, false);\n        continue;\n      }\n      node.setChecked(true, true);\n      if (leafOnly) {\n        node.setChecked(false, false);\n        const traverse = function (node2) {\n          const childNodes = node2.childNodes;\n          childNodes.forEach(child => {\n            if (!child.isLeaf) {\n              child.setChecked(false, false);\n            }\n            traverse(child);\n          });\n        };\n        traverse(node);\n      }\n    }\n  }\n  setCheckedNodes(array, leafOnly = false) {\n    const key = this.key;\n    const checkedKeys = {};\n    array.forEach(item => {\n      checkedKeys[(item || {})[key]] = true;\n    });\n    this._setCheckedKeys(key, leafOnly, checkedKeys);\n  }\n  setCheckedKeys(keys, leafOnly = false) {\n    this.defaultCheckedKeys = keys;\n    const key = this.key;\n    const checkedKeys = {};\n    keys.forEach(key2 => {\n      checkedKeys[key2] = true;\n    });\n    this._setCheckedKeys(key, leafOnly, checkedKeys);\n  }\n  setDefaultExpandedKeys(keys) {\n    keys = keys || [];\n    this.defaultExpandedKeys = keys;\n    keys.forEach(key => {\n      const node = this.getNode(key);\n      if (node) node.expand(null, this.autoExpandParent);\n    });\n  }\n  setChecked(data, checked, deep) {\n    const node = this.getNode(data);\n    if (node) {\n      node.setChecked(!!checked, deep);\n    }\n  }\n  getCurrentNode() {\n    return this.currentNode;\n  }\n  setCurrentNode(currentNode) {\n    const prevCurrentNode = this.currentNode;\n    if (prevCurrentNode) {\n      prevCurrentNode.isCurrent = false;\n    }\n    this.currentNode = currentNode;\n    this.currentNode.isCurrent = true;\n  }\n  setUserCurrentNode(node, shouldAutoExpandParent = true) {\n    const key = node[this.key];\n    const currNode = this.nodesMap[key];\n    this.setCurrentNode(currNode);\n    if (shouldAutoExpandParent && this.currentNode.level > 1) {\n      this.currentNode.parent.expand(null, true);\n    }\n  }\n  setCurrentNodeKey(key, shouldAutoExpandParent = true) {\n    if (key === null || key === void 0) {\n      this.currentNode && (this.currentNode.isCurrent = false);\n      this.currentNode = null;\n      return;\n    }\n    const node = this.getNode(key);\n    if (node) {\n      this.setCurrentNode(node);\n      if (shouldAutoExpandParent && this.currentNode.level > 1) {\n        this.currentNode.parent.expand(null, true);\n      }\n    }\n  }\n}\nexport { TreeStore as default };","map":{"version":3,"names":["constructor","options","currentNode","currentNodeKey","option","hasOwn","nodesMap","initialize","root","Node","data","store","lazy","load","loadFn","doCreateChildren","_initDefaultCheckedNodes","filter","value","filterNodeMethod","traverse","node","childNodes","forEach","child","visible","call","length","allHidden","some","isLeaf","expand","setData","newVal","instanceChanged","updateChildren","getNode","key","getNodeKey","insertBefore","refData","refNode","parent","insertAfter","remove","removeChild","append","parentData","parentNode","insertChild","defaultCheckedKeys","checkedKey","setChecked","checkStrictly","_initDefaultCheckedNode","indexOf","setDefaultCheckedKey","registerNode","id","nodeKey","deregisterNode","getCheckedNodes","leafOnly","includeHalfChecked","checkedNodes","checked","indeterminate","push","getCheckedKeys","map","getHalfCheckedNodes","nodes","getHalfCheckedKeys","_getAllNodes","allNodes","i","j","_setCheckedKeys","checkedKeys","sort","a","b","level","cache","Object","create","keys","toString","node2","setCheckedNodes","array","item","setCheckedKeys","key2","setDefaultExpandedKeys","defaultExpandedKeys","autoExpandParent","deep","getCurrentNode","setCurrentNode","prevCurrentNode","isCurrent","setUserCurrentNode","shouldAutoExpandParent","currNode","setCurrentNodeKey"],"sources":["../../../../../../../packages/components/tree/src/model/tree-store.ts"],"sourcesContent":["import { hasOwn } from '@vue/shared'\nimport Node from './node'\nimport { getNodeKey } from './util'\n\nimport type {\n  TreeKey,\n  TreeData,\n  TreeStoreNodesMap,\n  LoadFunction,\n  FilterNodeMethodFunction,\n  TreeOptionProps,\n  TreeStoreOptions,\n  FilterValue,\n  TreeNodeData,\n} from '../tree.type'\n\nexport default class TreeStore {\n  currentNode: Node\n  currentNodeKey: TreeKey\n  nodesMap: TreeStoreNodesMap\n  root: Node\n  data: TreeData\n  lazy: boolean\n  load: LoadFunction\n  filterNodeMethod: FilterNodeMethodFunction\n  key: TreeKey\n  defaultCheckedKeys: TreeKey[]\n  checkStrictly: boolean\n  defaultExpandedKeys: TreeKey[]\n  autoExpandParent: boolean\n  defaultExpandAll: boolean\n  checkDescendants: boolean\n  props: TreeOptionProps\n\n  constructor(options: TreeStoreOptions) {\n    this.currentNode = null\n    this.currentNodeKey = null\n\n    for (const option in options) {\n      if (hasOwn(options, option)) {\n        this[option] = options[option]\n      }\n    }\n\n    this.nodesMap = {}\n  }\n\n  initialize() {\n    this.root = new Node({\n      data: this.data,\n      store: this,\n    })\n    this.root.initialize()\n\n    if (this.lazy && this.load) {\n      const loadFn = this.load\n      loadFn(this.root, (data) => {\n        this.root.doCreateChildren(data)\n        this._initDefaultCheckedNodes()\n      })\n    } else {\n      this._initDefaultCheckedNodes()\n    }\n  }\n\n  filter(value: FilterValue): void {\n    const filterNodeMethod = this.filterNodeMethod\n    const lazy = this.lazy\n    const traverse = function (node: TreeStore | Node) {\n      const childNodes = (node as TreeStore).root\n        ? (node as TreeStore).root.childNodes\n        : (node as Node).childNodes\n\n      childNodes.forEach((child) => {\n        child.visible = filterNodeMethod.call(child, value, child.data, child)\n\n        traverse(child)\n      })\n\n      if (!(node as Node).visible && childNodes.length) {\n        let allHidden = true\n        allHidden = !childNodes.some((child) => child.visible)\n\n        if ((node as TreeStore).root) {\n          ;(node as TreeStore).root.visible = allHidden === false\n        } else {\n          ;(node as Node).visible = allHidden === false\n        }\n      }\n      if (!value) return\n\n      if ((node as Node).visible && !(node as Node).isLeaf && !lazy)\n        (node as Node).expand()\n    }\n\n    traverse(this)\n  }\n\n  setData(newVal: TreeData): void {\n    const instanceChanged = newVal !== this.root.data\n    if (instanceChanged) {\n      this.root.setData(newVal)\n      this._initDefaultCheckedNodes()\n    } else {\n      this.root.updateChildren()\n    }\n  }\n\n  getNode(data: TreeKey | TreeNodeData): Node {\n    if (data instanceof Node) return data\n    const key = typeof data !== 'object' ? data : getNodeKey(this.key, data)\n    return this.nodesMap[key] || null\n  }\n\n  insertBefore(data: TreeNodeData, refData: TreeKey | TreeNodeData): void {\n    const refNode = this.getNode(refData)\n    refNode.parent.insertBefore({ data }, refNode)\n  }\n\n  insertAfter(data: TreeNodeData, refData: TreeKey | TreeNodeData): void {\n    const refNode = this.getNode(refData)\n    refNode.parent.insertAfter({ data }, refNode)\n  }\n\n  remove(data: TreeNodeData | Node): void {\n    const node = this.getNode(data)\n\n    if (node && node.parent) {\n      if (node === this.currentNode) {\n        this.currentNode = null\n      }\n      node.parent.removeChild(node)\n    }\n  }\n\n  append(data: TreeNodeData, parentData: TreeNodeData | TreeKey | Node): void {\n    const parentNode = parentData ? this.getNode(parentData) : this.root\n\n    if (parentNode) {\n      parentNode.insertChild({ data })\n    }\n  }\n\n  _initDefaultCheckedNodes(): void {\n    const defaultCheckedKeys = this.defaultCheckedKeys || []\n    const nodesMap = this.nodesMap\n\n    defaultCheckedKeys.forEach((checkedKey) => {\n      const node = nodesMap[checkedKey]\n\n      if (node) {\n        node.setChecked(true, !this.checkStrictly)\n      }\n    })\n  }\n\n  _initDefaultCheckedNode(node: Node): void {\n    const defaultCheckedKeys = this.defaultCheckedKeys || []\n\n    if (defaultCheckedKeys.indexOf(node.key) !== -1) {\n      node.setChecked(true, !this.checkStrictly)\n    }\n  }\n\n  setDefaultCheckedKey(newVal: TreeKey[]): void {\n    if (newVal !== this.defaultCheckedKeys) {\n      this.defaultCheckedKeys = newVal\n      this._initDefaultCheckedNodes()\n    }\n  }\n\n  registerNode(node: Node): void {\n    const key = this.key\n    if (!node || !node.data) return\n\n    if (!key) {\n      this.nodesMap[node.id] = node\n    } else {\n      const nodeKey = node.key\n      if (nodeKey !== undefined) this.nodesMap[node.key] = node\n    }\n  }\n\n  deregisterNode(node: Node): void {\n    const key = this.key\n    if (!key || !node || !node.data) return\n\n    node.childNodes.forEach((child) => {\n      this.deregisterNode(child)\n    })\n\n    delete this.nodesMap[node.key]\n  }\n\n  getCheckedNodes(\n    leafOnly = false,\n    includeHalfChecked = false\n  ): TreeNodeData[] {\n    const checkedNodes: TreeNodeData[] = []\n    const traverse = function (node: TreeStore | Node) {\n      const childNodes = (node as TreeStore).root\n        ? (node as TreeStore).root.childNodes\n        : (node as Node).childNodes\n\n      childNodes.forEach((child) => {\n        if (\n          (child.checked || (includeHalfChecked && child.indeterminate)) &&\n          (!leafOnly || (leafOnly && child.isLeaf))\n        ) {\n          checkedNodes.push(child.data)\n        }\n\n        traverse(child)\n      })\n    }\n\n    traverse(this)\n\n    return checkedNodes\n  }\n\n  getCheckedKeys(leafOnly = false): TreeKey[] {\n    return this.getCheckedNodes(leafOnly).map((data) => (data || {})[this.key])\n  }\n\n  getHalfCheckedNodes(): TreeNodeData[] {\n    const nodes: TreeNodeData[] = []\n    const traverse = function (node: TreeStore | Node) {\n      const childNodes = (node as TreeStore).root\n        ? (node as TreeStore).root.childNodes\n        : (node as Node).childNodes\n\n      childNodes.forEach((child) => {\n        if (child.indeterminate) {\n          nodes.push(child.data)\n        }\n\n        traverse(child)\n      })\n    }\n\n    traverse(this)\n\n    return nodes\n  }\n\n  getHalfCheckedKeys(): TreeKey[] {\n    return this.getHalfCheckedNodes().map((data) => (data || {})[this.key])\n  }\n\n  _getAllNodes(): Node[] {\n    const allNodes: Node[] = []\n    const nodesMap = this.nodesMap\n    for (const nodeKey in nodesMap) {\n      if (hasOwn(nodesMap, nodeKey)) {\n        allNodes.push(nodesMap[nodeKey])\n      }\n    }\n\n    return allNodes\n  }\n\n  updateChildren(key: TreeKey, data: TreeData): void {\n    const node = this.nodesMap[key]\n    if (!node) return\n    const childNodes = node.childNodes\n    for (let i = childNodes.length - 1; i >= 0; i--) {\n      const child = childNodes[i]\n      this.remove(child.data)\n    }\n    for (let i = 0, j = data.length; i < j; i++) {\n      const child = data[i]\n      this.append(child, node.data)\n    }\n  }\n\n  _setCheckedKeys(\n    key: TreeKey,\n    leafOnly = false,\n    checkedKeys: { [key: string]: boolean }\n  ): void {\n    const allNodes = this._getAllNodes().sort((a, b) => b.level - a.level)\n    const cache = Object.create(null)\n    const keys = Object.keys(checkedKeys)\n    allNodes.forEach((node) => node.setChecked(false, false))\n    for (let i = 0, j = allNodes.length; i < j; i++) {\n      const node = allNodes[i]\n      const nodeKey = node.data[key].toString()\n      const checked = keys.indexOf(nodeKey) > -1\n      if (!checked) {\n        if (node.checked && !cache[nodeKey]) {\n          node.setChecked(false, false)\n        }\n        continue\n      }\n\n      let parent = node.parent\n      while (parent && parent.level > 0) {\n        cache[parent.data[key]] = true\n        parent = parent.parent\n      }\n\n      if (node.isLeaf || this.checkStrictly) {\n        node.setChecked(true, false)\n        continue\n      }\n      node.setChecked(true, true)\n\n      if (leafOnly) {\n        node.setChecked(false, false)\n        const traverse = function (node: Node): void {\n          const childNodes = node.childNodes\n          childNodes.forEach((child) => {\n            if (!child.isLeaf) {\n              child.setChecked(false, false)\n            }\n            traverse(child)\n          })\n        }\n        traverse(node)\n      }\n    }\n  }\n\n  setCheckedNodes(array: Node[], leafOnly = false): void {\n    const key = this.key\n    const checkedKeys = {}\n    array.forEach((item) => {\n      checkedKeys[(item || {})[key]] = true\n    })\n\n    this._setCheckedKeys(key, leafOnly, checkedKeys)\n  }\n\n  setCheckedKeys(keys: TreeKey[], leafOnly = false): void {\n    this.defaultCheckedKeys = keys\n    const key = this.key\n    const checkedKeys = {}\n    keys.forEach((key) => {\n      checkedKeys[key] = true\n    })\n\n    this._setCheckedKeys(key, leafOnly, checkedKeys)\n  }\n\n  setDefaultExpandedKeys(keys: TreeKey[]) {\n    keys = keys || []\n    this.defaultExpandedKeys = keys\n    keys.forEach((key) => {\n      const node = this.getNode(key)\n      if (node) node.expand(null, this.autoExpandParent)\n    })\n  }\n\n  setChecked(\n    data: TreeKey | TreeNodeData,\n    checked: boolean,\n    deep: boolean\n  ): void {\n    const node = this.getNode(data)\n\n    if (node) {\n      node.setChecked(!!checked, deep)\n    }\n  }\n\n  getCurrentNode(): Node {\n    return this.currentNode\n  }\n\n  setCurrentNode(currentNode: Node): void {\n    const prevCurrentNode = this.currentNode\n    if (prevCurrentNode) {\n      prevCurrentNode.isCurrent = false\n    }\n    this.currentNode = currentNode\n    this.currentNode.isCurrent = true\n  }\n\n  setUserCurrentNode(node: Node, shouldAutoExpandParent = true): void {\n    const key = node[this.key]\n    const currNode = this.nodesMap[key]\n    this.setCurrentNode(currNode)\n    if (shouldAutoExpandParent && this.currentNode.level > 1) {\n      this.currentNode.parent.expand(null, true)\n    }\n  }\n\n  setCurrentNodeKey(key: TreeKey, shouldAutoExpandParent = true): void {\n    if (key === null || key === undefined) {\n      this.currentNode && (this.currentNode.isCurrent = false)\n      this.currentNode = null\n      return\n    }\n    const node = this.getNode(key)\n    if (node) {\n      this.setCurrentNode(node)\n      if (shouldAutoExpandParent && this.currentNode.level > 1) {\n        this.currentNode.parent.expand(null, true)\n      }\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}