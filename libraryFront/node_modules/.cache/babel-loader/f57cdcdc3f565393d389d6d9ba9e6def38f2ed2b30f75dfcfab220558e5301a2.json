{"ast":null,"code":"import { defineComponent, inject, ref, computed, watch, onMounted, onUpdated, h } from 'vue';\nimport { NOOP, capitalize } from '@vue/shared';\nimport { useDocumentVisibility, useWindowFocus, useResizeObserver } from '@vueuse/core';\nimport { buildProps, definePropType, mutable } from '../../../utils/props.mjs';\nimport { EVENT_CODE } from '../../../utils/aria.mjs';\nimport { throwError } from '../../../utils/error.mjs';\nimport { ElIcon } from '../../icon/index.mjs';\nimport { ArrowLeft, ArrowRight, Close } from '@element-plus/icons-vue';\nimport '../../../tokens/index.mjs';\nimport './tab-bar2.mjs';\nimport { tabsRootContextKey } from '../../../tokens/tabs.mjs';\nimport script from './tab-bar.vue_vue_type_script_lang.mjs';\nconst tabNavProps = buildProps({\n  panes: {\n    type: definePropType(Array),\n    default: () => mutable([])\n  },\n  currentName: {\n    type: String,\n    default: \"\"\n  },\n  editable: Boolean,\n  onTabClick: {\n    type: definePropType(Function),\n    default: NOOP\n  },\n  onTabRemove: {\n    type: definePropType(Function),\n    default: NOOP\n  },\n  type: {\n    type: String,\n    values: [\"card\", \"border-card\", \"\"],\n    default: \"\"\n  },\n  stretch: Boolean\n});\nconst COMPONENT_NAME = \"ElTabNav\";\nvar TabNav = defineComponent({\n  name: COMPONENT_NAME,\n  props: tabNavProps,\n  setup(props, {\n    expose\n  }) {\n    const visibility = useDocumentVisibility();\n    const focused = useWindowFocus();\n    const rootTabs = inject(tabsRootContextKey);\n    if (!rootTabs) throwError(COMPONENT_NAME, `ElTabNav must be nested inside ElTabs`);\n    const scrollable = ref(false);\n    const navOffset = ref(0);\n    const isFocus = ref(false);\n    const focusable = ref(true);\n    const navScroll$ = ref();\n    const nav$ = ref();\n    const el$ = ref();\n    const sizeName = computed(() => [\"top\", \"bottom\"].includes(rootTabs.props.tabPosition) ? \"width\" : \"height\");\n    const navStyle = computed(() => {\n      const dir = sizeName.value === \"width\" ? \"X\" : \"Y\";\n      return {\n        transform: `translate${dir}(-${navOffset.value}px)`\n      };\n    });\n    const scrollPrev = () => {\n      if (!navScroll$.value) return;\n      const containerSize = navScroll$.value[`offset${capitalize(sizeName.value)}`];\n      const currentOffset = navOffset.value;\n      if (!currentOffset) return;\n      const newOffset = currentOffset > containerSize ? currentOffset - containerSize : 0;\n      navOffset.value = newOffset;\n    };\n    const scrollNext = () => {\n      if (!navScroll$.value || !nav$.value) return;\n      const navSize = nav$.value[`offset${capitalize(sizeName.value)}`];\n      const containerSize = navScroll$.value[`offset${capitalize(sizeName.value)}`];\n      const currentOffset = navOffset.value;\n      if (navSize - currentOffset <= containerSize) return;\n      const newOffset = navSize - currentOffset > containerSize * 2 ? currentOffset + containerSize : navSize - containerSize;\n      navOffset.value = newOffset;\n    };\n    const scrollToActiveTab = () => {\n      const nav = nav$.value;\n      if (!scrollable.value || !el$.value || !navScroll$.value || !nav) return;\n      const activeTab = el$.value.querySelector(\".is-active\");\n      if (!activeTab) return;\n      const navScroll = navScroll$.value;\n      const isHorizontal = [\"top\", \"bottom\"].includes(rootTabs.props.tabPosition);\n      const activeTabBounding = activeTab.getBoundingClientRect();\n      const navScrollBounding = navScroll.getBoundingClientRect();\n      const maxOffset = isHorizontal ? nav.offsetWidth - navScrollBounding.width : nav.offsetHeight - navScrollBounding.height;\n      const currentOffset = navOffset.value;\n      let newOffset = currentOffset;\n      if (isHorizontal) {\n        if (activeTabBounding.left < navScrollBounding.left) {\n          newOffset = currentOffset - (navScrollBounding.left - activeTabBounding.left);\n        }\n        if (activeTabBounding.right > navScrollBounding.right) {\n          newOffset = currentOffset + activeTabBounding.right - navScrollBounding.right;\n        }\n      } else {\n        if (activeTabBounding.top < navScrollBounding.top) {\n          newOffset = currentOffset - (navScrollBounding.top - activeTabBounding.top);\n        }\n        if (activeTabBounding.bottom > navScrollBounding.bottom) {\n          newOffset = currentOffset + (activeTabBounding.bottom - navScrollBounding.bottom);\n        }\n      }\n      newOffset = Math.max(newOffset, 0);\n      navOffset.value = Math.min(newOffset, maxOffset);\n    };\n    const update = () => {\n      if (!nav$.value || !navScroll$.value) return;\n      const navSize = nav$.value[`offset${capitalize(sizeName.value)}`];\n      const containerSize = navScroll$.value[`offset${capitalize(sizeName.value)}`];\n      const currentOffset = navOffset.value;\n      if (containerSize < navSize) {\n        const currentOffset2 = navOffset.value;\n        scrollable.value = scrollable.value || {};\n        scrollable.value.prev = currentOffset2;\n        scrollable.value.next = currentOffset2 + containerSize < navSize;\n        if (navSize - currentOffset2 < containerSize) {\n          navOffset.value = navSize - containerSize;\n        }\n      } else {\n        scrollable.value = false;\n        if (currentOffset > 0) {\n          navOffset.value = 0;\n        }\n      }\n    };\n    const changeTab = e => {\n      const code = e.code;\n      const {\n        up,\n        down,\n        left,\n        right\n      } = EVENT_CODE;\n      if (![up, down, left, right].includes(code)) return;\n      const tabList = Array.from(e.currentTarget.querySelectorAll(\"[role=tab]\"));\n      const currentIndex = tabList.indexOf(e.target);\n      let nextIndex;\n      if (code === left || code === up) {\n        if (currentIndex === 0) {\n          nextIndex = tabList.length - 1;\n        } else {\n          nextIndex = currentIndex - 1;\n        }\n      } else {\n        if (currentIndex < tabList.length - 1) {\n          nextIndex = currentIndex + 1;\n        } else {\n          nextIndex = 0;\n        }\n      }\n      tabList[nextIndex].focus();\n      tabList[nextIndex].click();\n      setFocus();\n    };\n    const setFocus = () => {\n      if (focusable.value) isFocus.value = true;\n    };\n    const removeFocus = () => isFocus.value = false;\n    watch(visibility, visibility2 => {\n      if (visibility2 === \"hidden\") {\n        focusable.value = false;\n      } else if (visibility2 === \"visible\") {\n        setTimeout(() => focusable.value = true, 50);\n      }\n    });\n    watch(focused, focused2 => {\n      if (focused2) {\n        setTimeout(() => focusable.value = true, 50);\n      } else {\n        focusable.value = false;\n      }\n    });\n    useResizeObserver(el$, update);\n    onMounted(() => setTimeout(() => scrollToActiveTab(), 0));\n    onUpdated(() => update());\n    expose({\n      scrollToActiveTab,\n      removeFocus\n    });\n    return () => {\n      const scrollBtn = scrollable.value ? [h(\"span\", {\n        class: [\"el-tabs__nav-prev\", scrollable.value.prev ? \"\" : \"is-disabled\"],\n        onClick: scrollPrev\n      }, [h(ElIcon, {}, {\n        default: () => h(ArrowLeft)\n      })]), h(\"span\", {\n        class: [\"el-tabs__nav-next\", scrollable.value.next ? \"\" : \"is-disabled\"],\n        onClick: scrollNext\n      }, [h(ElIcon, {}, {\n        default: () => h(ArrowRight)\n      })])] : null;\n      const tabs = props.panes.map((pane, index) => {\n        var _a, _b;\n        const tabName = pane.props.name || pane.index || `${index}`;\n        const closable = pane.isClosable || props.editable;\n        pane.index = `${index}`;\n        const btnClose = closable ? h(ElIcon, {\n          class: \"is-icon-close\",\n          onClick: ev => props.onTabRemove(pane, ev)\n        }, {\n          default: () => h(Close)\n        }) : null;\n        const tabLabelContent = ((_b = (_a = pane.instance.slots).label) == null ? void 0 : _b.call(_a)) || pane.props.label;\n        const tabindex = pane.active ? 0 : -1;\n        return h(\"div\", {\n          class: {\n            \"el-tabs__item\": true,\n            [`is-${rootTabs.props.tabPosition}`]: true,\n            \"is-active\": pane.active,\n            \"is-disabled\": pane.props.disabled,\n            \"is-closable\": closable,\n            \"is-focus\": isFocus\n          },\n          id: `tab-${tabName}`,\n          key: `tab-${tabName}`,\n          \"aria-controls\": `pane-${tabName}`,\n          role: \"tab\",\n          \"aria-selected\": pane.active,\n          ref: `tab-${tabName}`,\n          tabindex,\n          onFocus: () => setFocus(),\n          onBlur: () => removeFocus(),\n          onClick: ev => {\n            removeFocus();\n            props.onTabClick(pane, tabName, ev);\n          },\n          onKeydown: ev => {\n            if (closable && (ev.code === EVENT_CODE.delete || ev.code === EVENT_CODE.backspace)) {\n              props.onTabRemove(pane, ev);\n            }\n          }\n        }, [tabLabelContent, btnClose]);\n      });\n      return h(\"div\", {\n        ref: el$,\n        class: [\"el-tabs__nav-wrap\", scrollable.value ? \"is-scrollable\" : \"\", `is-${rootTabs.props.tabPosition}`]\n      }, [scrollBtn, h(\"div\", {\n        class: \"el-tabs__nav-scroll\",\n        ref: navScroll$\n      }, [h(\"div\", {\n        class: [\"el-tabs__nav\", `is-${rootTabs.props.tabPosition}`, props.stretch && [\"top\", \"bottom\"].includes(rootTabs.props.tabPosition) ? \"is-stretch\" : \"\"],\n        ref: nav$,\n        style: navStyle.value,\n        role: \"tablist\",\n        onKeydown: changeTab\n      }, [!props.type ? h(script, {\n        tabs: [...props.panes]\n      }) : null, tabs])])]);\n    };\n  }\n});\nexport { TabNav as default, tabNavProps };","map":{"version":3,"names":["tabNavProps","buildProps","panes","type","definePropType","Array","default","mutable","currentName","String","editable","Boolean","onTabClick","Function","NOOP","onTabRemove","values","stretch","COMPONENT_NAME","TabNav","defineComponent","name","props","setup","expose","visibility","useDocumentVisibility","focused","useWindowFocus","rootTabs","inject","tabsRootContextKey","throwError","scrollable","ref","navOffset","isFocus","focusable","navScroll$","nav$","el$","sizeName","computed","includes","tabPosition","navStyle","dir","value","transform","scrollPrev","containerSize","capitalize","currentOffset","newOffset","scrollNext","navSize","scrollToActiveTab","nav","activeTab","querySelector","navScroll","isHorizontal","activeTabBounding","getBoundingClientRect","navScrollBounding","maxOffset","offsetWidth","width","offsetHeight","height","left","right","top","bottom","Math","max","min","update","currentOffset2","prev","next","changeTab","e","code","up","down","EVENT_CODE","tabList","from","currentTarget","querySelectorAll","currentIndex","indexOf","target","nextIndex","length","focus","click","setFocus","removeFocus","watch","visibility2","setTimeout","focused2","useResizeObserver","onMounted","onUpdated","scrollBtn","h","class","onClick","ElIcon","ArrowLeft","ArrowRight","tabs","map","pane","index","_a","_b","tabName","closable","isClosable","btnClose","ev","Close","tabLabelContent","instance","slots","label","call","tabindex","active","disabled","id","key","role","onFocus","onBlur","onKeydown","delete","backspace","style","script"],"sources":["../../../../../../packages/components/tabs/src/tab-nav.ts"],"sourcesContent":["import {\n  h,\n  defineComponent,\n  ref,\n  inject,\n  computed,\n  onUpdated,\n  onMounted,\n  watch,\n} from 'vue'\nimport { NOOP, capitalize } from '@vue/shared'\nimport {\n  useResizeObserver,\n  useDocumentVisibility,\n  useWindowFocus,\n} from '@vueuse/core'\nimport { buildProps, definePropType, mutable } from '@element-plus/utils/props'\nimport { EVENT_CODE } from '@element-plus/utils/aria'\nimport { throwError } from '@element-plus/utils/error'\nimport { ElIcon } from '@element-plus/components/icon'\nimport { ArrowLeft, ArrowRight, Close } from '@element-plus/icons-vue'\nimport { tabsRootContextKey } from '@element-plus/tokens'\nimport TabBar from './tab-bar.vue'\nimport type { ExtractPropTypes, CSSProperties } from 'vue'\nimport type { TabsPaneContext } from '@element-plus/tokens'\nexport interface Scrollable {\n  next?: boolean\n  prev?: number\n}\n\nexport const tabNavProps = buildProps({\n  panes: {\n    type: definePropType<TabsPaneContext[]>(Array),\n    default: () => mutable([] as const),\n  },\n  currentName: {\n    type: String,\n    default: '',\n  },\n  editable: Boolean,\n  onTabClick: {\n    type: definePropType<\n      (tab: TabsPaneContext, tabName: string, ev: Event) => void\n    >(Function),\n    default: NOOP,\n  },\n  onTabRemove: {\n    type: definePropType<(tab: TabsPaneContext, ev: Event) => void>(Function),\n    default: NOOP,\n  },\n  type: {\n    type: String,\n    values: ['card', 'border-card', ''],\n    default: '',\n  },\n  stretch: Boolean,\n} as const)\n\nexport type TabNavProps = ExtractPropTypes<typeof tabNavProps>\n\nconst COMPONENT_NAME = 'ElTabNav'\nexport default defineComponent({\n  name: COMPONENT_NAME,\n  props: tabNavProps,\n\n  setup(props, { expose }) {\n    const visibility = useDocumentVisibility()\n    const focused = useWindowFocus()\n\n    const rootTabs = inject(tabsRootContextKey)\n    if (!rootTabs)\n      throwError(COMPONENT_NAME, `ElTabNav must be nested inside ElTabs`)\n\n    const scrollable = ref<false | Scrollable>(false)\n    const navOffset = ref(0)\n    const isFocus = ref(false)\n    const focusable = ref(true)\n\n    const navScroll$ = ref<HTMLDivElement>()\n    const nav$ = ref<HTMLDivElement>()\n    const el$ = ref<HTMLDivElement>()\n\n    const sizeName = computed(() =>\n      ['top', 'bottom'].includes(rootTabs.props.tabPosition)\n        ? 'width'\n        : 'height'\n    )\n    const navStyle = computed<CSSProperties>(() => {\n      const dir = sizeName.value === 'width' ? 'X' : 'Y'\n      return {\n        transform: `translate${dir}(-${navOffset.value}px)`,\n      }\n    })\n\n    const scrollPrev = () => {\n      if (!navScroll$.value) return\n\n      const containerSize =\n        navScroll$.value[`offset${capitalize(sizeName.value)}`]\n      const currentOffset = navOffset.value\n\n      if (!currentOffset) return\n\n      const newOffset =\n        currentOffset > containerSize ? currentOffset - containerSize : 0\n\n      navOffset.value = newOffset\n    }\n\n    const scrollNext = () => {\n      if (!navScroll$.value || !nav$.value) return\n\n      const navSize = nav$.value[`offset${capitalize(sizeName.value)}`]\n      const containerSize =\n        navScroll$.value[`offset${capitalize(sizeName.value)}`]\n      const currentOffset = navOffset.value\n\n      if (navSize - currentOffset <= containerSize) return\n\n      const newOffset =\n        navSize - currentOffset > containerSize * 2\n          ? currentOffset + containerSize\n          : navSize - containerSize\n\n      navOffset.value = newOffset\n    }\n\n    const scrollToActiveTab = () => {\n      const nav = nav$.value\n      if (!scrollable.value || !el$.value || !navScroll$.value || !nav) return\n\n      const activeTab = el$.value.querySelector('.is-active')\n      if (!activeTab) return\n\n      const navScroll = navScroll$.value\n      const isHorizontal = ['top', 'bottom'].includes(\n        rootTabs.props.tabPosition\n      )\n      const activeTabBounding = activeTab.getBoundingClientRect()\n      const navScrollBounding = navScroll.getBoundingClientRect()\n      const maxOffset = isHorizontal\n        ? nav.offsetWidth - navScrollBounding.width\n        : nav.offsetHeight - navScrollBounding.height\n      const currentOffset = navOffset.value\n      let newOffset = currentOffset\n\n      if (isHorizontal) {\n        if (activeTabBounding.left < navScrollBounding.left) {\n          newOffset =\n            currentOffset - (navScrollBounding.left - activeTabBounding.left)\n        }\n        if (activeTabBounding.right > navScrollBounding.right) {\n          newOffset =\n            currentOffset + activeTabBounding.right - navScrollBounding.right\n        }\n      } else {\n        if (activeTabBounding.top < navScrollBounding.top) {\n          newOffset =\n            currentOffset - (navScrollBounding.top - activeTabBounding.top)\n        }\n        if (activeTabBounding.bottom > navScrollBounding.bottom) {\n          newOffset =\n            currentOffset +\n            (activeTabBounding.bottom - navScrollBounding.bottom)\n        }\n      }\n      newOffset = Math.max(newOffset, 0)\n      navOffset.value = Math.min(newOffset, maxOffset)\n    }\n\n    const update = () => {\n      if (!nav$.value || !navScroll$.value) return\n\n      const navSize = nav$.value[`offset${capitalize(sizeName.value)}`]\n      const containerSize =\n        navScroll$.value[`offset${capitalize(sizeName.value)}`]\n      const currentOffset = navOffset.value\n\n      if (containerSize < navSize) {\n        const currentOffset = navOffset.value\n        scrollable.value = scrollable.value || {}\n        scrollable.value.prev = currentOffset\n        scrollable.value.next = currentOffset + containerSize < navSize\n        if (navSize - currentOffset < containerSize) {\n          navOffset.value = navSize - containerSize\n        }\n      } else {\n        scrollable.value = false\n        if (currentOffset > 0) {\n          navOffset.value = 0\n        }\n      }\n    }\n\n    const changeTab = (e: KeyboardEvent) => {\n      const code = e.code\n\n      const { up, down, left, right } = EVENT_CODE\n      if (![up, down, left, right].includes(code)) return\n\n      // 左右上下键更换tab\n      const tabList = Array.from(\n        (e.currentTarget as HTMLDivElement).querySelectorAll<HTMLDivElement>(\n          '[role=tab]'\n        )\n      )\n      const currentIndex = tabList.indexOf(e.target as HTMLDivElement)\n\n      let nextIndex: number\n      if (code === left || code === up) {\n        // left\n        if (currentIndex === 0) {\n          // first\n          nextIndex = tabList.length - 1\n        } else {\n          nextIndex = currentIndex - 1\n        }\n      } else {\n        // right\n        if (currentIndex < tabList.length - 1) {\n          // not last\n          nextIndex = currentIndex + 1\n        } else {\n          nextIndex = 0\n        }\n      }\n      tabList[nextIndex].focus() // 改变焦点元素\n      tabList[nextIndex].click() // 选中下一个tab\n      setFocus()\n    }\n\n    const setFocus = () => {\n      if (focusable.value) isFocus.value = true\n    }\n    const removeFocus = () => (isFocus.value = false)\n\n    watch(visibility, (visibility) => {\n      if (visibility === 'hidden') {\n        focusable.value = false\n      } else if (visibility === 'visible') {\n        setTimeout(() => (focusable.value = true), 50)\n      }\n    })\n    watch(focused, (focused) => {\n      if (focused) {\n        setTimeout(() => (focusable.value = true), 50)\n      } else {\n        focusable.value = false\n      }\n    })\n\n    useResizeObserver(el$, update)\n\n    onMounted(() => setTimeout(() => scrollToActiveTab(), 0))\n    onUpdated(() => update())\n\n    expose({\n      scrollToActiveTab,\n      removeFocus,\n    })\n\n    return () => {\n      const scrollBtn = scrollable.value\n        ? [\n            h(\n              'span',\n              {\n                class: [\n                  'el-tabs__nav-prev',\n                  scrollable.value.prev ? '' : 'is-disabled',\n                ],\n                onClick: scrollPrev,\n              },\n              [h(ElIcon, {}, { default: () => h(ArrowLeft) })]\n            ),\n            h(\n              'span',\n              {\n                class: [\n                  'el-tabs__nav-next',\n                  scrollable.value.next ? '' : 'is-disabled',\n                ],\n                onClick: scrollNext,\n              },\n              [h(ElIcon, {}, { default: () => h(ArrowRight) })]\n            ),\n          ]\n        : null\n\n      const tabs = props.panes.map((pane, index) => {\n        const tabName = pane.props.name || pane.index || `${index}`\n        const closable = pane.isClosable || props.editable\n        pane.index = `${index}`\n\n        const btnClose = closable\n          ? h(\n              ElIcon,\n              {\n                class: 'is-icon-close',\n                onClick: (ev: MouseEvent) => props.onTabRemove(pane, ev),\n              },\n              { default: () => h(Close) }\n            )\n          : null\n\n        const tabLabelContent =\n          pane.instance.slots.label?.() || pane.props.label\n        const tabindex = pane.active ? 0 : -1\n\n        return h(\n          'div',\n          {\n            class: {\n              'el-tabs__item': true,\n              [`is-${rootTabs.props.tabPosition}`]: true,\n              'is-active': pane.active,\n              'is-disabled': pane.props.disabled,\n              'is-closable': closable,\n              'is-focus': isFocus,\n            },\n            id: `tab-${tabName}`,\n            key: `tab-${tabName}`,\n            'aria-controls': `pane-${tabName}`,\n            role: 'tab',\n            'aria-selected': pane.active,\n            ref: `tab-${tabName}`,\n            tabindex,\n            onFocus: () => setFocus(),\n            onBlur: () => removeFocus(),\n            onClick: (ev: MouseEvent) => {\n              removeFocus()\n              props.onTabClick(pane, tabName, ev)\n            },\n            onKeydown: (ev: KeyboardEvent) => {\n              if (\n                closable &&\n                (ev.code === EVENT_CODE.delete ||\n                  ev.code === EVENT_CODE.backspace)\n              ) {\n                props.onTabRemove(pane, ev)\n              }\n            },\n          },\n          [tabLabelContent, btnClose]\n        )\n      })\n\n      return h(\n        'div',\n        {\n          ref: el$,\n          class: [\n            'el-tabs__nav-wrap',\n            scrollable.value ? 'is-scrollable' : '',\n            `is-${rootTabs.props.tabPosition}`,\n          ],\n        },\n        [\n          scrollBtn,\n          h(\n            'div',\n            {\n              class: 'el-tabs__nav-scroll',\n              ref: navScroll$,\n            },\n            [\n              h(\n                'div',\n                {\n                  class: [\n                    'el-tabs__nav',\n                    `is-${rootTabs.props.tabPosition}`,\n                    props.stretch &&\n                    ['top', 'bottom'].includes(rootTabs.props.tabPosition)\n                      ? 'is-stretch'\n                      : '',\n                  ],\n                  ref: nav$,\n                  style: navStyle.value,\n                  role: 'tablist',\n                  onKeydown: changeTab,\n                },\n                [\n                  !props.type\n                    ? h(TabBar, {\n                        tabs: [...props.panes],\n                      })\n                    : null,\n                  tabs,\n                ]\n              ),\n            ]\n          ),\n        ]\n      )\n    }\n  },\n})\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}