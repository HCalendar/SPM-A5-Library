{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/esnext.set.difference.v2.js\";\nimport \"core-js/modules/esnext.set.intersection.v2.js\";\nimport \"core-js/modules/esnext.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/esnext.set.is-subset-of.v2.js\";\nimport \"core-js/modules/esnext.set.is-superset-of.v2.js\";\nimport \"core-js/modules/esnext.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/esnext.set.union.v2.js\";\nimport { ref, getCurrentInstance, watch, nextTick } from 'vue';\nimport { SetOperationEnum, NODE_CHECK, NODE_CHECK_CHANGE } from '../virtual-tree.mjs';\nfunction useCheck(props, tree) {\n  const checkedKeys = ref( /* @__PURE__ */new Set());\n  const indeterminateKeys = ref( /* @__PURE__ */new Set());\n  const {\n    emit\n  } = getCurrentInstance();\n  watch(() => tree.value, () => {\n    return nextTick(() => {\n      _setCheckedKeys(props.defaultCheckedKeys);\n    });\n  }, {\n    immediate: true\n  });\n  const updateCheckedKeys = () => {\n    if (!tree.value || !props.showCheckbox || props.checkStrictly) {\n      return;\n    }\n    const {\n      levelTreeNodeMap,\n      maxLevel\n    } = tree.value;\n    const checkedKeySet = checkedKeys.value;\n    const indeterminateKeySet = /* @__PURE__ */new Set();\n    for (let level = maxLevel - 1; level >= 1; --level) {\n      const nodes = levelTreeNodeMap.get(level);\n      if (!nodes) continue;\n      nodes.forEach(node => {\n        const children = node.children;\n        if (children) {\n          let allChecked = true;\n          let hasChecked = false;\n          for (let i = 0; i < children.length; ++i) {\n            const childNode = children[i];\n            const key = childNode.key;\n            if (checkedKeySet.has(key)) {\n              hasChecked = true;\n            } else if (indeterminateKeySet.has(key)) {\n              allChecked = false;\n              hasChecked = true;\n              break;\n            } else {\n              allChecked = false;\n            }\n          }\n          if (allChecked) {\n            checkedKeySet.add(node.key);\n          } else if (hasChecked) {\n            indeterminateKeySet.add(node.key);\n            checkedKeySet.delete(node.key);\n          } else {\n            checkedKeySet.delete(node.key);\n            indeterminateKeySet.delete(node.key);\n          }\n        }\n      });\n    }\n    indeterminateKeys.value = indeterminateKeySet;\n  };\n  const isChecked = node => checkedKeys.value.has(node.key);\n  const isIndeterminate = node => indeterminateKeys.value.has(node.key);\n  const toggleCheckbox = (node, isChecked2, nodeClick = true) => {\n    const checkedKeySet = checkedKeys.value;\n    const toggle = (node2, checked) => {\n      checkedKeySet[checked ? SetOperationEnum.ADD : SetOperationEnum.DELETE](node2.key);\n      const children = node2.children;\n      if (!props.checkStrictly && children) {\n        children.forEach(childNode => {\n          if (!childNode.disabled) {\n            toggle(childNode, checked);\n          }\n        });\n      }\n    };\n    toggle(node, isChecked2);\n    updateCheckedKeys();\n    if (nodeClick) {\n      afterNodeCheck(node, isChecked2);\n    }\n  };\n  const afterNodeCheck = (node, checked) => {\n    const {\n      checkedNodes,\n      checkedKeys: checkedKeys2\n    } = getChecked();\n    const {\n      halfCheckedNodes,\n      halfCheckedKeys\n    } = getHalfChecked();\n    emit(NODE_CHECK, node.data, {\n      checkedKeys: checkedKeys2,\n      checkedNodes,\n      halfCheckedKeys,\n      halfCheckedNodes\n    });\n    emit(NODE_CHECK_CHANGE, node.data, checked);\n  };\n  function getCheckedKeys(leafOnly = false) {\n    return getChecked(leafOnly).checkedKeys;\n  }\n  function getCheckedNodes(leafOnly = false) {\n    return getChecked(leafOnly).checkedNodes;\n  }\n  function getHalfCheckedKeys() {\n    return getHalfChecked().halfCheckedKeys;\n  }\n  function getHalfCheckedNodes() {\n    return getHalfChecked().halfCheckedNodes;\n  }\n  function getChecked(leafOnly = false) {\n    const checkedNodes = [];\n    const keys = [];\n    if ((tree == null ? void 0 : tree.value) && props.showCheckbox) {\n      const {\n        treeNodeMap\n      } = tree.value;\n      checkedKeys.value.forEach(key => {\n        const node = treeNodeMap.get(key);\n        if (node && (!leafOnly || leafOnly && node.isLeaf)) {\n          keys.push(key);\n          checkedNodes.push(node.data);\n        }\n      });\n    }\n    return {\n      checkedKeys: keys,\n      checkedNodes\n    };\n  }\n  function getHalfChecked() {\n    const halfCheckedNodes = [];\n    const halfCheckedKeys = [];\n    if ((tree == null ? void 0 : tree.value) && props.showCheckbox) {\n      const {\n        treeNodeMap\n      } = tree.value;\n      indeterminateKeys.value.forEach(key => {\n        const node = treeNodeMap.get(key);\n        if (node) {\n          halfCheckedKeys.push(key);\n          halfCheckedNodes.push(node.data);\n        }\n      });\n    }\n    return {\n      halfCheckedNodes,\n      halfCheckedKeys\n    };\n  }\n  function setCheckedKeys(keys) {\n    checkedKeys.value.clear();\n    _setCheckedKeys(keys);\n  }\n  function setChecked(key, isChecked2) {\n    if ((tree == null ? void 0 : tree.value) && props.showCheckbox) {\n      const node = tree.value.treeNodeMap.get(key);\n      if (node) {\n        toggleCheckbox(node, isChecked2, false);\n      }\n    }\n  }\n  function _setCheckedKeys(keys) {\n    if (tree == null ? void 0 : tree.value) {\n      const {\n        treeNodeMap\n      } = tree.value;\n      if (props.showCheckbox && treeNodeMap && keys) {\n        for (let i = 0; i < keys.length; ++i) {\n          const key = keys[i];\n          const node = treeNodeMap.get(key);\n          if (node && !isChecked(node)) {\n            toggleCheckbox(node, true, false);\n          }\n        }\n      }\n    }\n  }\n  return {\n    updateCheckedKeys,\n    toggleCheckbox,\n    isChecked,\n    isIndeterminate,\n    getCheckedKeys,\n    getCheckedNodes,\n    getHalfCheckedKeys,\n    getHalfCheckedNodes,\n    setChecked,\n    setCheckedKeys\n  };\n}\nexport { useCheck };","map":{"version":3,"names":["props","tree","checkedKeys","ref","Set","indeterminateKeys","emit","getCurrentInstance","watch","value","nextTick","_setCheckedKeys","defaultCheckedKeys","immediate","updateCheckedKeys","showCheckbox","checkStrictly","levelTreeNodeMap","maxLevel","checkedKeySet","indeterminateKeySet","level","nodes","get","forEach","node","children","allChecked","hasChecked","i","length","childNode","key","has","add","delete","isChecked","isIndeterminate","toggleCheckbox","isChecked2","nodeClick","toggle","node2","checked","SetOperationEnum","ADD","DELETE","disabled","afterNodeCheck","checkedNodes","checkedKeys2","getChecked","halfCheckedNodes","halfCheckedKeys","getHalfChecked","NODE_CHECK","data","NODE_CHECK_CHANGE","getCheckedKeys","leafOnly","getCheckedNodes","getHalfCheckedKeys","getHalfCheckedNodes","keys","treeNodeMap","isLeaf","push","setCheckedKeys","clear","setChecked"],"sources":["../../../../../../../packages/components/tree-v2/src/composables/useCheck.ts"],"sourcesContent":["import { nextTick, ref, watch, getCurrentInstance } from 'vue'\nimport {\n  NODE_CHECK_CHANGE,\n  NODE_CHECK,\n  SetOperationEnum,\n} from '../virtual-tree'\nimport type { Ref } from 'vue'\nimport type { TreeProps, TreeKey, TreeNode, Tree, TreeNodeData } from '../types'\n\nexport function useCheck(props: TreeProps, tree: Ref<Tree | undefined>) {\n  const checkedKeys = ref<Set<TreeKey>>(new Set())\n  const indeterminateKeys = ref<Set<TreeKey>>(new Set())\n  const { emit } = getCurrentInstance()!\n\n  watch(\n    () => tree.value,\n    () => {\n      return nextTick(() => {\n        _setCheckedKeys(props.defaultCheckedKeys)\n      })\n    },\n    {\n      immediate: true,\n    }\n  )\n\n  const updateCheckedKeys = () => {\n    if (!tree.value || !props.showCheckbox || props.checkStrictly) {\n      return\n    }\n    const { levelTreeNodeMap, maxLevel } = tree.value\n    const checkedKeySet = checkedKeys.value\n    const indeterminateKeySet = new Set<TreeKey>()\n    // It is easier to determine the indeterminate state by\n    // traversing from bottom to top\n    // leaf nodes not have indeterminate status and can be skipped\n    for (let level = maxLevel - 1; level >= 1; --level) {\n      const nodes = levelTreeNodeMap.get(level)\n      if (!nodes) continue\n      nodes.forEach((node) => {\n        const children = node.children\n        if (children) {\n          // Whether all child nodes are selected\n          let allChecked = true\n          // Whether a child node is selected\n          let hasChecked = false\n          for (let i = 0; i < children.length; ++i) {\n            const childNode = children[i]\n            const key = childNode.key\n            if (checkedKeySet.has(key)) {\n              hasChecked = true\n            } else if (indeterminateKeySet.has(key)) {\n              allChecked = false\n              hasChecked = true\n              break\n            } else {\n              allChecked = false\n            }\n          }\n          if (allChecked) {\n            checkedKeySet.add(node.key)\n          } else if (hasChecked) {\n            indeterminateKeySet.add(node.key)\n            checkedKeySet.delete(node.key)\n          } else {\n            checkedKeySet.delete(node.key)\n            indeterminateKeySet.delete(node.key)\n          }\n        }\n      })\n    }\n    indeterminateKeys.value = indeterminateKeySet\n  }\n\n  const isChecked = (node: TreeNode) => checkedKeys.value.has(node.key)\n\n  const isIndeterminate = (node: TreeNode) =>\n    indeterminateKeys.value.has(node.key)\n\n  const toggleCheckbox = (\n    node: TreeNode,\n    isChecked: boolean,\n    nodeClick = true\n  ) => {\n    const checkedKeySet = checkedKeys.value\n    const toggle = (node: TreeNode, checked: boolean) => {\n      checkedKeySet[checked ? SetOperationEnum.ADD : SetOperationEnum.DELETE](\n        node.key\n      )\n      const children = node.children\n      if (!props.checkStrictly && children) {\n        children.forEach((childNode) => {\n          if (!childNode.disabled) {\n            toggle(childNode, checked)\n          }\n        })\n      }\n    }\n    toggle(node, isChecked)\n    updateCheckedKeys()\n    if (nodeClick) {\n      afterNodeCheck(node, isChecked)\n    }\n  }\n\n  const afterNodeCheck = (node: TreeNode, checked: boolean) => {\n    const { checkedNodes, checkedKeys } = getChecked()\n    const { halfCheckedNodes, halfCheckedKeys } = getHalfChecked()\n    emit(NODE_CHECK, node.data, {\n      checkedKeys,\n      checkedNodes,\n      halfCheckedKeys,\n      halfCheckedNodes,\n    })\n    emit(NODE_CHECK_CHANGE, node.data, checked)\n  }\n\n  // expose\n  function getCheckedKeys(leafOnly = false): TreeKey[] {\n    return getChecked(leafOnly).checkedKeys\n  }\n\n  function getCheckedNodes(leafOnly = false): TreeNodeData[] {\n    return getChecked(leafOnly).checkedNodes\n  }\n\n  function getHalfCheckedKeys(): TreeKey[] {\n    return getHalfChecked().halfCheckedKeys\n  }\n\n  function getHalfCheckedNodes(): TreeNodeData[] {\n    return getHalfChecked().halfCheckedNodes\n  }\n\n  function getChecked(leafOnly = false): {\n    checkedKeys: TreeKey[]\n    checkedNodes: TreeNodeData[]\n  } {\n    const checkedNodes: TreeNodeData[] = []\n    const keys: TreeKey[] = []\n    if (tree?.value && props.showCheckbox) {\n      const { treeNodeMap } = tree.value\n      checkedKeys.value.forEach((key) => {\n        const node = treeNodeMap.get(key)\n        if (node && (!leafOnly || (leafOnly && node.isLeaf))) {\n          keys.push(key)\n          checkedNodes.push(node.data)\n        }\n      })\n    }\n    return {\n      checkedKeys: keys,\n      checkedNodes,\n    }\n  }\n\n  function getHalfChecked(): {\n    halfCheckedKeys: TreeKey[]\n    halfCheckedNodes: TreeNodeData[]\n  } {\n    const halfCheckedNodes: TreeNodeData[] = []\n    const halfCheckedKeys: TreeKey[] = []\n    if (tree?.value && props.showCheckbox) {\n      const { treeNodeMap } = tree.value\n      indeterminateKeys.value.forEach((key) => {\n        const node = treeNodeMap.get(key)\n        if (node) {\n          halfCheckedKeys.push(key)\n          halfCheckedNodes.push(node.data)\n        }\n      })\n    }\n    return {\n      halfCheckedNodes,\n      halfCheckedKeys,\n    }\n  }\n\n  function setCheckedKeys(keys: TreeKey[]) {\n    checkedKeys.value.clear()\n    _setCheckedKeys(keys)\n  }\n\n  function setChecked(key: TreeKey, isChecked: boolean) {\n    if (tree?.value && props.showCheckbox) {\n      const node = tree.value.treeNodeMap.get(key)\n      if (node) {\n        toggleCheckbox(node, isChecked, false)\n      }\n    }\n  }\n\n  function _setCheckedKeys(keys: TreeKey[]) {\n    if (tree?.value) {\n      const { treeNodeMap } = tree.value\n      if (props.showCheckbox && treeNodeMap && keys) {\n        for (let i = 0; i < keys.length; ++i) {\n          const key = keys[i]\n          const node = treeNodeMap.get(key)\n          if (node && !isChecked(node)) {\n            toggleCheckbox(node, true, false)\n          }\n        }\n      }\n    }\n  }\n\n  return {\n    updateCheckedKeys,\n    toggleCheckbox,\n    isChecked,\n    isIndeterminate,\n    // expose\n    getCheckedKeys,\n    getCheckedNodes,\n    getHalfCheckedKeys,\n    getHalfCheckedNodes,\n    setChecked,\n    setCheckedKeys,\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}