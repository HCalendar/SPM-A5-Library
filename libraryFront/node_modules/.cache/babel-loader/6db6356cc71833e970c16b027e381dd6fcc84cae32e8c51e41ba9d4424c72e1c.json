{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { defineComponent, getCurrentInstance, ref, computed, unref, nextTick, onMounted, onUpdated, resolveDynamicComponent, h } from 'vue';\nimport { hasOwn, isString } from '@vue/shared';\nimport { isNumber } from '../../../../utils/util.mjs';\nimport isServer from '../../../../utils/isServer.mjs';\nimport { useCache } from '../hooks/use-cache.mjs';\nimport useWheel from '../hooks/use-wheel.mjs';\nimport ScrollBar from '../components/scrollbar.mjs';\nimport { isHorizontal, getScrollDir, getRTLOffsetType } from '../utils.mjs';\nimport { virtualizedListProps } from '../props.mjs';\nimport { ITEM_RENDER_EVT, SCROLL_EVT, BACKWARD, FORWARD, RTL, RTL_OFFSET_POS_DESC, RTL_OFFSET_NAG, AUTO_ALIGNMENT, HORIZONTAL } from '../defaults.mjs';\nconst createList = ({\n  name,\n  getOffset,\n  getItemSize,\n  getItemOffset,\n  getEstimatedTotalSize,\n  getStartIndexForOffset,\n  getStopIndexForStartIndex,\n  initCache,\n  clearCache,\n  validateProps\n}) => {\n  return defineComponent({\n    name: name != null ? name : \"ElVirtualList\",\n    props: virtualizedListProps,\n    emits: [ITEM_RENDER_EVT, SCROLL_EVT],\n    setup(props, {\n      emit,\n      expose\n    }) {\n      validateProps(props);\n      const instance = getCurrentInstance();\n      const dynamicSizeCache = ref(initCache(props, instance));\n      const getItemStyleCache = useCache();\n      const windowRef = ref();\n      const innerRef = ref();\n      const scrollbarRef = ref();\n      const states = ref({\n        isScrolling: false,\n        scrollDir: \"forward\",\n        scrollOffset: isNumber(props.initScrollOffset) ? props.initScrollOffset : 0,\n        updateRequested: false,\n        isScrollbarDragging: false,\n        scrollbarAlwaysOn: props.scrollbarAlwaysOn\n      });\n      const itemsToRender = computed(() => {\n        const {\n          total,\n          cache\n        } = props;\n        const {\n          isScrolling,\n          scrollDir,\n          scrollOffset\n        } = unref(states);\n        if (total === 0) {\n          return [0, 0, 0, 0];\n        }\n        const startIndex = getStartIndexForOffset(props, scrollOffset, unref(dynamicSizeCache));\n        const stopIndex = getStopIndexForStartIndex(props, startIndex, scrollOffset, unref(dynamicSizeCache));\n        const cacheBackward = !isScrolling || scrollDir === BACKWARD ? Math.max(1, cache) : 1;\n        const cacheForward = !isScrolling || scrollDir === FORWARD ? Math.max(1, cache) : 1;\n        return [Math.max(0, startIndex - cacheBackward), Math.max(0, Math.min(total - 1, stopIndex + cacheForward)), startIndex, stopIndex];\n      });\n      const estimatedTotalSize = computed(() => getEstimatedTotalSize(props, unref(dynamicSizeCache)));\n      const _isHorizontal = computed(() => isHorizontal(props.layout));\n      const windowStyle = computed(() => [{\n        position: \"relative\",\n        overflow: \"hidden\",\n        WebkitOverflowScrolling: \"touch\",\n        willChange: \"transform\"\n      }, {\n        direction: props.direction,\n        height: isNumber(props.height) ? `${props.height}px` : props.height,\n        width: isNumber(props.width) ? `${props.width}px` : props.width\n      }, props.style]);\n      const innerStyle = computed(() => {\n        const size = unref(estimatedTotalSize);\n        const horizontal = unref(_isHorizontal);\n        return {\n          height: horizontal ? \"100%\" : `${size}px`,\n          pointerEvents: unref(states).isScrolling ? \"none\" : void 0,\n          width: horizontal ? `${size}px` : \"100%\"\n        };\n      });\n      const clientSize = computed(() => _isHorizontal.value ? props.width : props.height);\n      const {\n        onWheel\n      } = useWheel({\n        atStartEdge: computed(() => states.value.scrollOffset <= 0),\n        atEndEdge: computed(() => states.value.scrollOffset >= estimatedTotalSize.value),\n        layout: computed(() => props.layout)\n      }, offset => {\n        var _a, _b;\n        ;\n        (_b = (_a = scrollbarRef.value).onMouseUp) == null ? void 0 : _b.call(_a);\n        scrollTo(Math.min(states.value.scrollOffset + offset, estimatedTotalSize.value - clientSize.value));\n      });\n      const emitEvents = () => {\n        const {\n          total\n        } = props;\n        if (total > 0) {\n          const [cacheStart, cacheEnd, visibleStart, visibleEnd] = unref(itemsToRender);\n          emit(ITEM_RENDER_EVT, cacheStart, cacheEnd, visibleStart, visibleEnd);\n        }\n        const {\n          scrollDir,\n          scrollOffset,\n          updateRequested\n        } = unref(states);\n        emit(SCROLL_EVT, scrollDir, scrollOffset, updateRequested);\n      };\n      const scrollVertically = e => {\n        const {\n          clientHeight,\n          scrollHeight,\n          scrollTop\n        } = e.currentTarget;\n        const _states = unref(states);\n        if (_states.scrollOffset === scrollTop) {\n          return;\n        }\n        const scrollOffset = Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight));\n        states.value = {\n          ..._states,\n          isScrolling: true,\n          scrollDir: getScrollDir(_states.scrollOffset, scrollOffset),\n          scrollOffset,\n          updateRequested: false\n        };\n        nextTick(resetIsScrolling);\n      };\n      const scrollHorizontally = e => {\n        const {\n          clientWidth,\n          scrollLeft,\n          scrollWidth\n        } = e.currentTarget;\n        const _states = unref(states);\n        if (_states.scrollOffset === scrollLeft) {\n          return;\n        }\n        const {\n          direction\n        } = props;\n        let scrollOffset = scrollLeft;\n        if (direction === RTL) {\n          switch (getRTLOffsetType()) {\n            case RTL_OFFSET_NAG:\n              {\n                scrollOffset = -scrollLeft;\n                break;\n              }\n            case RTL_OFFSET_POS_DESC:\n              {\n                scrollOffset = scrollWidth - clientWidth - scrollLeft;\n                break;\n              }\n          }\n        }\n        scrollOffset = Math.max(0, Math.min(scrollOffset, scrollWidth - clientWidth));\n        states.value = {\n          ..._states,\n          isScrolling: true,\n          scrollDir: getScrollDir(_states.scrollOffset, scrollOffset),\n          scrollOffset,\n          updateRequested: false\n        };\n        nextTick(resetIsScrolling);\n      };\n      const onScroll = e => {\n        unref(_isHorizontal) ? scrollHorizontally(e) : scrollVertically(e);\n        emitEvents();\n      };\n      const onScrollbarScroll = (distanceToGo, totalSteps) => {\n        const offset = (estimatedTotalSize.value - clientSize.value) / totalSteps * distanceToGo;\n        scrollTo(Math.min(estimatedTotalSize.value - clientSize.value, offset));\n      };\n      const scrollTo = offset => {\n        offset = Math.max(offset, 0);\n        if (offset === unref(states).scrollOffset) {\n          return;\n        }\n        states.value = {\n          ...unref(states),\n          scrollOffset: offset,\n          scrollDir: getScrollDir(unref(states).scrollOffset, offset),\n          updateRequested: true\n        };\n        nextTick(resetIsScrolling);\n      };\n      const scrollToItem = (idx, alignment = AUTO_ALIGNMENT) => {\n        const {\n          scrollOffset\n        } = unref(states);\n        idx = Math.max(0, Math.min(idx, props.total - 1));\n        scrollTo(getOffset(props, idx, alignment, scrollOffset, unref(dynamicSizeCache)));\n      };\n      const getItemStyle = idx => {\n        const {\n          direction,\n          itemSize,\n          layout\n        } = props;\n        const itemStyleCache = getItemStyleCache.value(clearCache && itemSize, clearCache && layout, clearCache && direction);\n        let style;\n        if (hasOwn(itemStyleCache, String(idx))) {\n          style = itemStyleCache[idx];\n        } else {\n          const offset = getItemOffset(props, idx, unref(dynamicSizeCache));\n          const size = getItemSize(props, idx, unref(dynamicSizeCache));\n          const horizontal = unref(_isHorizontal);\n          const isRtl = direction === RTL;\n          const offsetHorizontal = horizontal ? offset : 0;\n          itemStyleCache[idx] = style = {\n            position: \"absolute\",\n            left: isRtl ? void 0 : `${offsetHorizontal}px`,\n            right: isRtl ? `${offsetHorizontal}px` : void 0,\n            top: !horizontal ? `${offset}px` : 0,\n            height: !horizontal ? `${size}px` : \"100%\",\n            width: horizontal ? `${size}px` : \"100%\"\n          };\n        }\n        return style;\n      };\n      const resetIsScrolling = () => {\n        states.value.isScrolling = false;\n        nextTick(() => {\n          getItemStyleCache.value(-1, null, null);\n        });\n      };\n      const resetScrollTop = () => {\n        const window = windowRef.value;\n        if (window) {\n          window.scrollTop = 0;\n        }\n      };\n      onMounted(() => {\n        if (isServer) return;\n        const {\n          initScrollOffset\n        } = props;\n        const windowElement = unref(windowRef);\n        if (isNumber(initScrollOffset) && windowElement) {\n          if (unref(_isHorizontal)) {\n            windowElement.scrollLeft = initScrollOffset;\n          } else {\n            windowElement.scrollTop = initScrollOffset;\n          }\n        }\n        emitEvents();\n      });\n      onUpdated(() => {\n        const {\n          direction,\n          layout\n        } = props;\n        const {\n          scrollOffset,\n          updateRequested\n        } = unref(states);\n        const windowElement = unref(windowRef);\n        if (updateRequested && windowElement) {\n          if (layout === HORIZONTAL) {\n            if (direction === RTL) {\n              switch (getRTLOffsetType()) {\n                case \"negative\":\n                  {\n                    windowElement.scrollLeft = -scrollOffset;\n                    break;\n                  }\n                case \"positive-ascending\":\n                  {\n                    windowElement.scrollLeft = scrollOffset;\n                    break;\n                  }\n                default:\n                  {\n                    const {\n                      clientWidth,\n                      scrollWidth\n                    } = windowElement;\n                    windowElement.scrollLeft = scrollWidth - clientWidth - scrollOffset;\n                    break;\n                  }\n              }\n            } else {\n              windowElement.scrollLeft = scrollOffset;\n            }\n          } else {\n            windowElement.scrollTop = scrollOffset;\n          }\n        }\n      });\n      const api = {\n        clientSize,\n        estimatedTotalSize,\n        windowStyle,\n        windowRef,\n        innerRef,\n        innerStyle,\n        itemsToRender,\n        scrollbarRef,\n        states,\n        getItemStyle,\n        onScroll,\n        onScrollbarScroll,\n        onWheel,\n        scrollTo,\n        scrollToItem,\n        resetScrollTop\n      };\n      expose({\n        windowRef,\n        innerRef,\n        getItemStyleCache,\n        scrollTo,\n        scrollToItem,\n        resetScrollTop,\n        states\n      });\n      return api;\n    },\n    render(ctx) {\n      var _a;\n      const {\n        $slots,\n        className,\n        clientSize,\n        containerElement,\n        data,\n        getItemStyle,\n        innerElement,\n        itemsToRender,\n        innerStyle,\n        layout,\n        total,\n        onScroll,\n        onScrollbarScroll,\n        onWheel,\n        states,\n        useIsScrolling,\n        windowStyle\n      } = ctx;\n      const [start, end] = itemsToRender;\n      const Container = resolveDynamicComponent(containerElement);\n      const Inner = resolveDynamicComponent(innerElement);\n      const children = [];\n      if (total > 0) {\n        for (let i = start; i <= end; i++) {\n          children.push((_a = $slots.default) == null ? void 0 : _a.call($slots, {\n            data,\n            key: i,\n            index: i,\n            isScrolling: useIsScrolling ? states.isScrolling : void 0,\n            style: getItemStyle(i)\n          }));\n        }\n      }\n      const InnerNode = [h(Inner, {\n        style: innerStyle,\n        ref: \"innerRef\"\n      }, !isString(Inner) ? {\n        default: () => children\n      } : children)];\n      const scrollbar = h(ScrollBar, {\n        ref: \"scrollbarRef\",\n        clientSize,\n        layout,\n        onScroll: onScrollbarScroll,\n        ratio: clientSize * 100 / this.estimatedTotalSize,\n        scrollFrom: states.scrollOffset / (this.estimatedTotalSize - clientSize),\n        total\n      });\n      const listContainer = h(Container, {\n        class: className,\n        style: windowStyle,\n        onScroll,\n        onWheel,\n        ref: \"windowRef\",\n        key: 0\n      }, !isString(Container) ? {\n        default: () => [InnerNode]\n      } : [InnerNode]);\n      return h(\"div\", {\n        key: 0,\n        class: [\"el-vl__wrapper\", states.scrollbarAlwaysOn ? \"always-on\" : \"\"]\n      }, [listContainer, scrollbar]);\n    }\n  });\n};\nexport { createList as default };","map":{"version":3,"names":["createList","name","getOffset","getItemSize","getItemOffset","getEstimatedTotalSize","getStartIndexForOffset","getStopIndexForStartIndex","initCache","clearCache","validateProps","defineComponent","props","virtualizedListProps","emits","ITEM_RENDER_EVT","SCROLL_EVT","setup","emit","expose","instance","getCurrentInstance","dynamicSizeCache","ref","getItemStyleCache","useCache","windowRef","innerRef","scrollbarRef","states","isScrolling","scrollDir","scrollOffset","isNumber","initScrollOffset","updateRequested","isScrollbarDragging","scrollbarAlwaysOn","itemsToRender","computed","total","cache","unref","startIndex","stopIndex","cacheBackward","BACKWARD","Math","max","cacheForward","FORWARD","min","estimatedTotalSize","_isHorizontal","isHorizontal","layout","windowStyle","position","overflow","WebkitOverflowScrolling","willChange","direction","height","width","style","innerStyle","size","horizontal","pointerEvents","clientSize","value","onWheel","useWheel","atStartEdge","atEndEdge","offset","_a","_b","onMouseUp","call","scrollTo","emitEvents","cacheStart","cacheEnd","visibleStart","visibleEnd","scrollVertically","e","clientHeight","scrollHeight","scrollTop","currentTarget","_states","getScrollDir","nextTick","resetIsScrolling","scrollHorizontally","clientWidth","scrollLeft","scrollWidth","RTL","getRTLOffsetType","RTL_OFFSET_NAG","RTL_OFFSET_POS_DESC","onScroll","onScrollbarScroll","distanceToGo","totalSteps","scrollToItem","idx","alignment","AUTO_ALIGNMENT","getItemStyle","itemSize","itemStyleCache","hasOwn","String","isRtl","offsetHorizontal","left","right","top","resetScrollTop","window","onMounted","isServer","windowElement","onUpdated","HORIZONTAL","api","render","ctx","$slots","className","containerElement","data","innerElement","useIsScrolling","start","end","Container","resolveDynamicComponent","Inner","children","i","push","default","key","index","InnerNode","h","isString","scrollbar","ScrollBar","ratio","scrollFrom","listContainer","class"],"sources":["../../../../../../../packages/components/virtual-list/src/builders/build-list.ts"],"sourcesContent":["import {\n  computed,\n  defineComponent,\n  getCurrentInstance,\n  ref,\n  nextTick,\n  onMounted,\n  onUpdated,\n  resolveDynamicComponent,\n  h,\n  unref,\n} from 'vue'\nimport { hasOwn } from '@vue/shared'\n\nimport { isNumber, isString } from '@element-plus/utils/util'\nimport isServer from '@element-plus/utils/isServer'\n\nimport { useCache } from '../hooks/use-cache'\nimport useWheel from '../hooks/use-wheel'\nimport Scrollbar from '../components/scrollbar'\nimport { getScrollDir, isHorizontal, getRTLOffsetType } from '../utils'\nimport { virtualizedListProps } from '../props'\nimport {\n  AUTO_ALIGNMENT,\n  BACKWARD,\n  FORWARD,\n  RTL,\n  HORIZONTAL,\n  ITEM_RENDER_EVT,\n  SCROLL_EVT,\n  RTL_OFFSET_NAG,\n  RTL_OFFSET_POS_DESC,\n} from '../defaults'\n\nimport type { VNode, CSSProperties, Slot, VNodeChild } from 'vue'\nimport type { ListConstructorProps, Alignment } from '../types'\nimport type { VirtualizedListProps } from '../props'\n\nconst createList = ({\n  name,\n  getOffset,\n  getItemSize,\n  getItemOffset,\n  getEstimatedTotalSize,\n  getStartIndexForOffset,\n  getStopIndexForStartIndex,\n  initCache,\n  clearCache,\n  validateProps,\n}: ListConstructorProps<VirtualizedListProps>) => {\n  return defineComponent({\n    name: name ?? 'ElVirtualList',\n    props: virtualizedListProps,\n    emits: [ITEM_RENDER_EVT, SCROLL_EVT],\n    setup(props, { emit, expose }) {\n      validateProps(props)\n      const instance = getCurrentInstance()!\n      const dynamicSizeCache = ref(initCache(props, instance))\n\n      const getItemStyleCache = useCache()\n      // refs\n      // here windowRef and innerRef can be type of HTMLElement\n      // or user defined component type, depends on the type passed\n      // by user\n      const windowRef = ref<HTMLElement>()\n      const innerRef = ref<HTMLElement>()\n      const scrollbarRef = ref()\n      const states = ref({\n        isScrolling: false,\n        scrollDir: 'forward',\n        scrollOffset: isNumber(props.initScrollOffset)\n          ? props.initScrollOffset\n          : 0,\n        updateRequested: false,\n        isScrollbarDragging: false,\n        scrollbarAlwaysOn: props.scrollbarAlwaysOn,\n      })\n\n      // computed\n      const itemsToRender = computed(() => {\n        const { total, cache } = props\n        const { isScrolling, scrollDir, scrollOffset } = unref(states)\n\n        if (total === 0) {\n          return [0, 0, 0, 0]\n        }\n\n        const startIndex = getStartIndexForOffset(\n          props,\n          scrollOffset,\n          unref(dynamicSizeCache)\n        )\n        const stopIndex = getStopIndexForStartIndex(\n          props,\n          startIndex,\n          scrollOffset,\n          unref(dynamicSizeCache)\n        )\n\n        const cacheBackward =\n          !isScrolling || scrollDir === BACKWARD ? Math.max(1, cache) : 1\n        const cacheForward =\n          !isScrolling || scrollDir === FORWARD ? Math.max(1, cache) : 1\n\n        return [\n          Math.max(0, startIndex - cacheBackward),\n          Math.max(0, Math.min(total! - 1, stopIndex + cacheForward)),\n          startIndex,\n          stopIndex,\n        ]\n      })\n\n      const estimatedTotalSize = computed(() =>\n        getEstimatedTotalSize(props, unref(dynamicSizeCache))\n      )\n\n      const _isHorizontal = computed(() => isHorizontal(props.layout))\n\n      const windowStyle = computed(() => [\n        {\n          position: 'relative',\n          overflow: 'hidden',\n          WebkitOverflowScrolling: 'touch',\n          willChange: 'transform',\n        },\n        {\n          direction: props.direction,\n          height: isNumber(props.height) ? `${props.height}px` : props.height,\n          width: isNumber(props.width) ? `${props.width}px` : props.width,\n        },\n        props.style,\n      ])\n\n      const innerStyle = computed(() => {\n        const size = unref(estimatedTotalSize)\n        const horizontal = unref(_isHorizontal)\n        return {\n          height: horizontal ? '100%' : `${size}px`,\n          pointerEvents: unref(states).isScrolling ? 'none' : undefined,\n          width: horizontal ? `${size}px` : '100%',\n        }\n      })\n\n      const clientSize = computed(() =>\n        _isHorizontal.value ? props.width : props.height\n      )\n\n      // methods\n      const { onWheel } = useWheel(\n        {\n          atStartEdge: computed(() => states.value.scrollOffset <= 0),\n          atEndEdge: computed(\n            () => states.value.scrollOffset >= estimatedTotalSize.value\n          ),\n          layout: computed(() => props.layout),\n        },\n        (offset) => {\n          ;(\n            scrollbarRef.value as any as {\n              onMouseUp: () => void\n            }\n          ).onMouseUp?.()\n          scrollTo(\n            Math.min(\n              states.value.scrollOffset + offset,\n              estimatedTotalSize.value - (clientSize.value as number)\n            )\n          )\n        }\n      )\n\n      const emitEvents = () => {\n        const { total } = props\n\n        if (total! > 0) {\n          const [cacheStart, cacheEnd, visibleStart, visibleEnd] =\n            unref(itemsToRender)\n          emit(ITEM_RENDER_EVT, cacheStart, cacheEnd, visibleStart, visibleEnd)\n        }\n\n        const { scrollDir, scrollOffset, updateRequested } = unref(states)\n        emit(SCROLL_EVT, scrollDir, scrollOffset, updateRequested)\n      }\n\n      const scrollVertically = (e: Event) => {\n        const { clientHeight, scrollHeight, scrollTop } =\n          e.currentTarget as HTMLElement\n        const _states = unref(states)\n        if (_states.scrollOffset === scrollTop) {\n          return\n        }\n\n        const scrollOffset = Math.max(\n          0,\n          Math.min(scrollTop, scrollHeight - clientHeight)\n        )\n\n        states.value = {\n          ..._states,\n          isScrolling: true,\n          scrollDir: getScrollDir(_states.scrollOffset, scrollOffset),\n          scrollOffset,\n          updateRequested: false,\n        }\n\n        nextTick(resetIsScrolling)\n      }\n\n      const scrollHorizontally = (e: Event) => {\n        const { clientWidth, scrollLeft, scrollWidth } =\n          e.currentTarget as HTMLElement\n        const _states = unref(states)\n\n        if (_states.scrollOffset === scrollLeft) {\n          return\n        }\n\n        const { direction } = props\n\n        let scrollOffset = scrollLeft\n\n        if (direction === RTL) {\n          // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n          // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n          // It's also easier for this component if we convert offsets to the same format as they would be in for ltr.\n          // So the simplest solution is to determine which browser behavior we're dealing with, and convert based on it.\n          switch (getRTLOffsetType()) {\n            case RTL_OFFSET_NAG: {\n              scrollOffset = -scrollLeft\n              break\n            }\n            case RTL_OFFSET_POS_DESC: {\n              scrollOffset = scrollWidth - clientWidth - scrollLeft\n              break\n            }\n          }\n        }\n\n        scrollOffset = Math.max(\n          0,\n          Math.min(scrollOffset, scrollWidth - clientWidth)\n        )\n\n        states.value = {\n          ..._states,\n          isScrolling: true,\n          scrollDir: getScrollDir(_states.scrollOffset, scrollOffset),\n          scrollOffset,\n          updateRequested: false,\n        }\n\n        nextTick(resetIsScrolling)\n      }\n\n      const onScroll = (e: Event) => {\n        unref(_isHorizontal) ? scrollHorizontally(e) : scrollVertically(e)\n        emitEvents()\n      }\n\n      const onScrollbarScroll = (distanceToGo: number, totalSteps: number) => {\n        const offset =\n          ((estimatedTotalSize.value - (clientSize.value as number)) /\n            totalSteps) *\n          distanceToGo\n        scrollTo(\n          Math.min(\n            estimatedTotalSize.value - (clientSize.value as number),\n            offset\n          )\n        )\n      }\n\n      const scrollTo = (offset: number) => {\n        offset = Math.max(offset, 0)\n\n        if (offset === unref(states).scrollOffset) {\n          return\n        }\n\n        states.value = {\n          ...unref(states),\n          scrollOffset: offset,\n          scrollDir: getScrollDir(unref(states).scrollOffset, offset),\n          updateRequested: true,\n        }\n\n        nextTick(resetIsScrolling)\n      }\n\n      const scrollToItem = (\n        idx: number,\n        alignment: Alignment = AUTO_ALIGNMENT\n      ) => {\n        const { scrollOffset } = unref(states)\n\n        idx = Math.max(0, Math.min(idx, props.total! - 1))\n        scrollTo(\n          getOffset(\n            props,\n            idx,\n            alignment,\n            scrollOffset,\n            unref(dynamicSizeCache)\n          )\n        )\n      }\n\n      const getItemStyle = (idx: number) => {\n        const { direction, itemSize, layout } = props\n\n        const itemStyleCache = getItemStyleCache.value(\n          clearCache && itemSize,\n          clearCache && layout,\n          clearCache && direction\n        )\n\n        let style: CSSProperties\n        if (hasOwn(itemStyleCache, String(idx))) {\n          style = itemStyleCache[idx]\n        } else {\n          const offset = getItemOffset(props, idx, unref(dynamicSizeCache))\n          const size = getItemSize(props, idx, unref(dynamicSizeCache))\n          const horizontal = unref(_isHorizontal)\n\n          const isRtl = direction === RTL\n          const offsetHorizontal = horizontal ? offset : 0\n          itemStyleCache[idx] = style = {\n            position: 'absolute',\n            left: isRtl ? undefined : `${offsetHorizontal}px`,\n            right: isRtl ? `${offsetHorizontal}px` : undefined,\n            top: !horizontal ? `${offset}px` : 0,\n            height: !horizontal ? `${size}px` : '100%',\n            width: horizontal ? `${size}px` : '100%',\n          }\n        }\n\n        return style\n      }\n\n      // TODO:\n      // perf optimization here, reset isScrolling with debounce.\n\n      const resetIsScrolling = () => {\n        // timer = null\n\n        states.value.isScrolling = false\n        nextTick(() => {\n          getItemStyleCache.value(-1, null, null)\n        })\n      }\n\n      const resetScrollTop = () => {\n        const window = windowRef.value\n        if (window) {\n          window.scrollTop = 0\n        }\n      }\n\n      // life cycles\n      onMounted(() => {\n        if (isServer) return\n        const { initScrollOffset } = props\n        const windowElement = unref(windowRef)\n        if (isNumber(initScrollOffset) && windowElement) {\n          if (unref(_isHorizontal)) {\n            windowElement.scrollLeft = initScrollOffset\n          } else {\n            windowElement.scrollTop = initScrollOffset\n          }\n        }\n\n        emitEvents()\n      })\n\n      onUpdated(() => {\n        const { direction, layout } = props\n        const { scrollOffset, updateRequested } = unref(states)\n        const windowElement = unref(windowRef)\n\n        if (updateRequested && windowElement) {\n          if (layout === HORIZONTAL) {\n            if (direction === RTL) {\n              // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n              // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n              // So we need to determine which browser behavior we're dealing with, and mimic it.\n              switch (getRTLOffsetType()) {\n                case 'negative': {\n                  windowElement.scrollLeft = -scrollOffset\n                  break\n                }\n                case 'positive-ascending': {\n                  windowElement.scrollLeft = scrollOffset\n                  break\n                }\n                default: {\n                  const { clientWidth, scrollWidth } = windowElement\n                  windowElement.scrollLeft =\n                    scrollWidth - clientWidth - scrollOffset\n                  break\n                }\n              }\n            } else {\n              windowElement.scrollLeft = scrollOffset\n            }\n          } else {\n            windowElement.scrollTop = scrollOffset\n          }\n        }\n      })\n\n      const api = {\n        clientSize,\n        estimatedTotalSize,\n        windowStyle,\n        windowRef,\n        innerRef,\n        innerStyle,\n        itemsToRender,\n        scrollbarRef,\n        states,\n        getItemStyle,\n        onScroll,\n        onScrollbarScroll,\n        onWheel,\n        scrollTo,\n        scrollToItem,\n        resetScrollTop,\n      }\n\n      expose({\n        windowRef,\n        innerRef,\n        getItemStyleCache,\n        scrollTo,\n        scrollToItem,\n        resetScrollTop,\n        states,\n      })\n\n      return api\n    },\n\n    render(ctx: any) {\n      const {\n        $slots,\n        className,\n        clientSize,\n        containerElement,\n        data,\n        getItemStyle,\n        innerElement,\n        itemsToRender,\n        innerStyle,\n        layout,\n        total,\n        onScroll,\n        onScrollbarScroll,\n        onWheel,\n        states,\n        useIsScrolling,\n        windowStyle,\n      } = ctx\n\n      const [start, end] = itemsToRender\n\n      const Container = resolveDynamicComponent(containerElement)\n      const Inner = resolveDynamicComponent(innerElement)\n\n      const children = [] as VNodeChild[]\n\n      if (total > 0) {\n        for (let i = start; i <= end; i++) {\n          children.push(\n            ($slots.default as Slot)?.({\n              data,\n              key: i,\n              index: i,\n              isScrolling: useIsScrolling ? states.isScrolling : undefined,\n              style: getItemStyle(i),\n            })\n          )\n        }\n      }\n\n      const InnerNode = [\n        h(\n          Inner as VNode,\n          {\n            style: innerStyle,\n            ref: 'innerRef',\n          },\n          !isString(Inner)\n            ? {\n                default: () => children,\n              }\n            : children\n        ),\n      ]\n\n      const scrollbar = h(Scrollbar, {\n        ref: 'scrollbarRef',\n        clientSize,\n        layout,\n        onScroll: onScrollbarScroll,\n        ratio: (clientSize * 100) / this.estimatedTotalSize,\n        scrollFrom:\n          states.scrollOffset / (this.estimatedTotalSize - clientSize),\n        total,\n      })\n\n      const listContainer = h(\n        Container as VNode,\n        {\n          class: className,\n          style: windowStyle,\n          onScroll,\n          onWheel,\n          ref: 'windowRef',\n          key: 0,\n        },\n        !isString(Container) ? { default: () => [InnerNode] } : [InnerNode]\n      )\n\n      return h(\n        'div',\n        {\n          key: 0,\n          class: [\n            'el-vl__wrapper',\n            states.scrollbarAlwaysOn ? 'always-on' : '',\n          ],\n        },\n        [listContainer, scrollbar]\n      )\n    },\n  })\n}\n\nexport default createList\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}