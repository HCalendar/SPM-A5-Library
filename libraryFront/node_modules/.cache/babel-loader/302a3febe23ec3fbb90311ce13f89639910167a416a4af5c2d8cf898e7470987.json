{"ast":null,"code":"import { h, render, watch, isVNode } from 'vue';\nimport { hasOwn, isString } from '@vue/shared';\nimport isServer from '../../../utils/isServer.mjs';\nimport '../../../utils/util.mjs';\nimport './index.mjs';\nimport script from './index.vue_vue_type_script_lang.mjs';\nconst messageInstance = /* @__PURE__ */new Map();\nconst initInstance = (props, container) => {\n  const vnode = h(script, props);\n  render(vnode, container);\n  document.body.appendChild(container.firstElementChild);\n  return vnode.component;\n};\nconst genContainer = () => {\n  return document.createElement(\"div\");\n};\nconst showMessage = options => {\n  const container = genContainer();\n  options.onVanish = () => {\n    render(null, container);\n    messageInstance.delete(vm);\n  };\n  options.onAction = action => {\n    const currentMsg = messageInstance.get(vm);\n    let resolve;\n    if (options.showInput) {\n      resolve = {\n        value: vm.inputValue,\n        action\n      };\n    } else {\n      resolve = action;\n    }\n    if (options.callback) {\n      options.callback(resolve, instance.proxy);\n    } else {\n      if (action === \"cancel\" || action === \"close\") {\n        if (options.distinguishCancelAndClose && action !== \"cancel\") {\n          currentMsg.reject(\"close\");\n        } else {\n          currentMsg.reject(\"cancel\");\n        }\n      } else {\n        currentMsg.resolve(resolve);\n      }\n    }\n  };\n  const instance = initInstance(options, container);\n  const vm = instance.proxy;\n  for (const prop in options) {\n    if (hasOwn(options, prop) && !hasOwn(vm.$props, prop)) {\n      vm[prop] = options[prop];\n    }\n  }\n  watch(() => vm.message, (newVal, oldVal) => {\n    if (isVNode(newVal)) {\n      instance.slots.default = () => [newVal];\n    } else if (isVNode(oldVal) && !isVNode(newVal)) {\n      delete instance.slots.default;\n    }\n  }, {\n    immediate: true\n  });\n  vm.visible = true;\n  return vm;\n};\nfunction MessageBox(options) {\n  if (isServer) return;\n  let callback;\n  if (isString(options) || isVNode(options)) {\n    options = {\n      message: options\n    };\n  } else {\n    callback = options.callback;\n  }\n  return new Promise((resolve, reject) => {\n    const vm = showMessage(options);\n    messageInstance.set(vm, {\n      options,\n      callback,\n      resolve,\n      reject\n    });\n  });\n}\nMessageBox.alert = (message, title, options) => {\n  if (typeof title === \"object\") {\n    options = title;\n    title = \"\";\n  } else if (title === void 0) {\n    title = \"\";\n  }\n  return MessageBox(Object.assign({\n    title,\n    message,\n    type: \"\",\n    closeOnPressEscape: false,\n    closeOnClickModal: false\n  }, options, {\n    boxType: \"alert\"\n  }));\n};\nMessageBox.confirm = (message, title, options) => {\n  if (typeof title === \"object\") {\n    options = title;\n    title = \"\";\n  } else if (title === void 0) {\n    title = \"\";\n  }\n  return MessageBox(Object.assign({\n    title,\n    message,\n    type: \"\",\n    showCancelButton: true\n  }, options, {\n    boxType: \"confirm\"\n  }));\n};\nMessageBox.prompt = (message, title, options) => {\n  if (typeof title === \"object\") {\n    options = title;\n    title = \"\";\n  } else if (title === void 0) {\n    title = \"\";\n  }\n  return MessageBox(Object.assign({\n    title,\n    message,\n    showCancelButton: true,\n    showInput: true,\n    type: \"\"\n  }, options, {\n    boxType: \"prompt\"\n  }));\n};\nMessageBox.close = () => {\n  messageInstance.forEach((_, vm) => {\n    vm.doClose();\n  });\n  messageInstance.clear();\n};\nexport { MessageBox as default };","map":{"version":3,"names":["messageInstance","Map","initInstance","props","container","vnode","h","script","render","document","body","appendChild","firstElementChild","component","genContainer","createElement","showMessage","options","onVanish","delete","vm","onAction","action","currentMsg","get","resolve","showInput","value","inputValue","callback","instance","proxy","distinguishCancelAndClose","reject","prop","hasOwn","$props","watch","message","newVal","oldVal","isVNode","slots","default","immediate","visible","MessageBox","isServer","isString","Promise","set","alert","title","Object","assign","type","closeOnPressEscape","closeOnClickModal","boxType","confirm","showCancelButton","prompt","close","forEach","_","doClose","clear"],"sources":["../../../../../../packages/components/message-box/src/messageBox.ts"],"sourcesContent":["import { h, watch, render } from 'vue'\nimport { hasOwn } from '@vue/shared'\nimport isServer from '@element-plus/utils/isServer'\nimport { isVNode, isString } from '@element-plus/utils/util'\nimport MessageBoxConstructor from './index.vue'\n\nimport type { ComponentPublicInstance, VNode } from 'vue'\nimport type {\n  Action,\n  Callback,\n  MessageBoxState,\n  IElMessageBox,\n  ElMessageBoxOptions,\n  MessageBoxData,\n} from './message-box.type'\n\n// component default merge props & data\n\nconst messageInstance = new Map<\n  ComponentPublicInstance<{ doClose: () => void }>, // marking doClose as function\n  {\n    options: any\n    callback: Callback\n    resolve: (res: any) => void\n    reject: (reason?: any) => void\n  }\n>()\n\nconst initInstance = (props: any, container: HTMLElement) => {\n  const vnode = h(MessageBoxConstructor, props)\n  render(vnode, container)\n  document.body.appendChild(container.firstElementChild)\n  return vnode.component\n}\n\nconst genContainer = () => {\n  return document.createElement('div')\n}\n\nconst showMessage = (options: any) => {\n  const container = genContainer()\n  // Adding destruct method.\n  // when transition leaves emitting `vanish` evt. so that we can do the clean job.\n  options.onVanish = () => {\n    // not sure if this causes mem leak, need proof to verify that.\n    // maybe calling out like 1000 msg-box then close them all.\n    render(null, container)\n    messageInstance.delete(vm) // Remove vm to avoid mem leak.\n    // here we were suppose to call document.body.removeChild(container.firstElementChild)\n    // but render(null, container) did that job for us. so that we do not call that directly\n  }\n\n  options.onAction = (action: Action) => {\n    const currentMsg = messageInstance.get(vm)\n    let resolve: Action | { value: string; action: Action }\n    if (options.showInput) {\n      resolve = { value: vm.inputValue, action }\n    } else {\n      resolve = action\n    }\n    if (options.callback) {\n      options.callback(resolve, instance.proxy)\n    } else {\n      if (action === 'cancel' || action === 'close') {\n        if (options.distinguishCancelAndClose && action !== 'cancel') {\n          currentMsg.reject('close')\n        } else {\n          currentMsg.reject('cancel')\n        }\n      } else {\n        currentMsg.resolve(resolve)\n      }\n    }\n  }\n\n  const instance = initInstance(options, container)\n\n  // This is how we use message box programmably.\n  // Maybe consider releasing a template version?\n  // get component instance like v2.\n  const vm = instance.proxy as ComponentPublicInstance<\n    {\n      visible: boolean\n      doClose: () => void\n    } & MessageBoxState\n  >\n\n  for (const prop in options) {\n    if (hasOwn(options, prop) && !hasOwn(vm.$props, prop)) {\n      vm[prop as string] = options[prop]\n    }\n  }\n\n  watch(\n    () => vm.message,\n    (newVal, oldVal) => {\n      if (isVNode(newVal)) {\n        // Override slots since message is vnode type.\n        instance.slots.default = () => [newVal]\n      } else if (isVNode(oldVal) && !isVNode(newVal)) {\n        delete instance.slots.default\n      }\n    },\n    {\n      immediate: true,\n    }\n  )\n\n  // change visibility after everything is settled\n  vm.visible = true\n  return vm\n}\n\nasync function MessageBox(options: ElMessageBoxOptions): Promise<MessageBoxData>\nfunction MessageBox(\n  options: ElMessageBoxOptions | string | VNode\n): Promise<{ value: string; action: Action } | Action> {\n  if (isServer) return\n  let callback\n  if (isString(options) || isVNode(options)) {\n    options = {\n      message: options,\n    }\n  } else {\n    callback = options.callback\n  }\n\n  return new Promise((resolve, reject) => {\n    const vm = showMessage(options)\n    // collect this vm in order to handle upcoming events.\n    messageInstance.set(vm, {\n      options,\n      callback,\n      resolve,\n      reject,\n    })\n  })\n}\n\nMessageBox.alert = (\n  message: string,\n  title: string,\n  options?: ElMessageBoxOptions\n) => {\n  if (typeof title === 'object') {\n    options = title\n    title = ''\n  } else if (title === undefined) {\n    title = ''\n  }\n\n  return MessageBox(\n    Object.assign(\n      {\n        title,\n        message,\n        type: '',\n        closeOnPressEscape: false,\n        closeOnClickModal: false,\n      },\n      options,\n      {\n        boxType: 'alert',\n      }\n    )\n  )\n}\n\nMessageBox.confirm = (\n  message: string,\n  title: string,\n  options?: ElMessageBoxOptions\n) => {\n  if (typeof title === 'object') {\n    options = title\n    title = ''\n  } else if (title === undefined) {\n    title = ''\n  }\n  return MessageBox(\n    Object.assign(\n      {\n        title,\n        message,\n        type: '',\n        showCancelButton: true,\n      },\n      options,\n      {\n        boxType: 'confirm',\n      }\n    )\n  )\n}\n\nMessageBox.prompt = (\n  message: string,\n  title: string,\n  options?: ElMessageBoxOptions\n) => {\n  if (typeof title === 'object') {\n    options = title\n    title = ''\n  } else if (title === undefined) {\n    title = ''\n  }\n  return MessageBox(\n    Object.assign(\n      {\n        title,\n        message,\n        showCancelButton: true,\n        showInput: true,\n        type: '',\n      },\n      options,\n      {\n        boxType: 'prompt',\n      }\n    )\n  )\n}\n\nMessageBox.close = () => {\n  // instance.setupInstall.doClose()\n  // instance.setupInstall.state.visible = false\n\n  messageInstance.forEach((_, vm) => {\n    vm.doClose()\n  })\n\n  messageInstance.clear()\n}\n\nexport default MessageBox as IElMessageBox\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}