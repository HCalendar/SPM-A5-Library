{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { ref, getCurrentInstance, computed, unref, watch } from 'vue';\nimport { getRowIdentity, walkTreeNode } from '../util.mjs';\nfunction useTree(watcherData) {\n  const expandRowKeys = ref([]);\n  const treeData = ref({});\n  const indent = ref(16);\n  const lazy = ref(false);\n  const lazyTreeNodeMap = ref({});\n  const lazyColumnIdentifier = ref(\"hasChildren\");\n  const childrenColumnName = ref(\"children\");\n  const instance = getCurrentInstance();\n  const normalizedData = computed(() => {\n    if (!watcherData.rowKey.value) return {};\n    const data = watcherData.data.value || [];\n    return normalize(data);\n  });\n  const normalizedLazyNode = computed(() => {\n    const rowKey = watcherData.rowKey.value;\n    const keys = Object.keys(lazyTreeNodeMap.value);\n    const res = {};\n    if (!keys.length) return res;\n    keys.forEach(key => {\n      if (lazyTreeNodeMap.value[key].length) {\n        const item = {\n          children: []\n        };\n        lazyTreeNodeMap.value[key].forEach(row => {\n          const currentRowKey = getRowIdentity(row, rowKey);\n          item.children.push(currentRowKey);\n          if (row[lazyColumnIdentifier.value] && !res[currentRowKey]) {\n            res[currentRowKey] = {\n              children: []\n            };\n          }\n        });\n        res[key] = item;\n      }\n    });\n    return res;\n  });\n  const normalize = data => {\n    const rowKey = watcherData.rowKey.value;\n    const res = {};\n    walkTreeNode(data, (parent, children, level) => {\n      const parentId = getRowIdentity(parent, rowKey);\n      if (Array.isArray(children)) {\n        res[parentId] = {\n          children: children.map(row => getRowIdentity(row, rowKey)),\n          level\n        };\n      } else if (lazy.value) {\n        res[parentId] = {\n          children: [],\n          lazy: true,\n          level\n        };\n      }\n    }, childrenColumnName.value, lazyColumnIdentifier.value);\n    return res;\n  };\n  const updateTreeData = (ifChangeExpandRowKeys = false, ifExpandAll = (_a => (_a = instance.store) == null ? void 0 : _a.states.defaultExpandAll.value)()) => {\n    var _a2;\n    const nested = normalizedData.value;\n    const normalizedLazyNode_ = normalizedLazyNode.value;\n    const keys = Object.keys(nested);\n    const newTreeData = {};\n    if (keys.length) {\n      const oldTreeData = unref(treeData);\n      const rootLazyRowKeys = [];\n      const getExpanded = (oldValue, key) => {\n        if (ifChangeExpandRowKeys) {\n          if (expandRowKeys.value) {\n            return ifExpandAll || expandRowKeys.value.includes(key);\n          } else {\n            return !!(ifExpandAll || (oldValue == null ? void 0 : oldValue.expanded));\n          }\n        } else {\n          const included = ifExpandAll || expandRowKeys.value && expandRowKeys.value.includes(key);\n          return !!((oldValue == null ? void 0 : oldValue.expanded) || included);\n        }\n      };\n      keys.forEach(key => {\n        const oldValue = oldTreeData[key];\n        const newValue = {\n          ...nested[key]\n        };\n        newValue.expanded = getExpanded(oldValue, key);\n        if (newValue.lazy) {\n          const {\n            loaded = false,\n            loading = false\n          } = oldValue || {};\n          newValue.loaded = !!loaded;\n          newValue.loading = !!loading;\n          rootLazyRowKeys.push(key);\n        }\n        newTreeData[key] = newValue;\n      });\n      const lazyKeys = Object.keys(normalizedLazyNode_);\n      if (lazy.value && lazyKeys.length && rootLazyRowKeys.length) {\n        lazyKeys.forEach(key => {\n          const oldValue = oldTreeData[key];\n          const lazyNodeChildren = normalizedLazyNode_[key].children;\n          if (rootLazyRowKeys.indexOf(key) !== -1) {\n            if (newTreeData[key].children.length !== 0) {\n              throw new Error(\"[ElTable]children must be an empty array.\");\n            }\n            newTreeData[key].children = lazyNodeChildren;\n          } else {\n            const {\n              loaded = false,\n              loading = false\n            } = oldValue || {};\n            newTreeData[key] = {\n              lazy: true,\n              loaded: !!loaded,\n              loading: !!loading,\n              expanded: getExpanded(oldValue, key),\n              children: lazyNodeChildren,\n              level: \"\"\n            };\n          }\n        });\n      }\n    }\n    treeData.value = newTreeData;\n    (_a2 = instance.store) == null ? void 0 : _a2.updateTableScrollY();\n  };\n  watch(() => expandRowKeys.value, () => {\n    updateTreeData(true);\n  });\n  watch(() => normalizedData.value, () => {\n    updateTreeData();\n  });\n  watch(() => normalizedLazyNode.value, () => {\n    updateTreeData();\n  });\n  const updateTreeExpandKeys = value => {\n    expandRowKeys.value = value;\n    updateTreeData();\n  };\n  const toggleTreeExpansion = (row, expanded) => {\n    instance.store.assertRowKey();\n    const rowKey = watcherData.rowKey.value;\n    const id = getRowIdentity(row, rowKey);\n    const data = id && treeData.value[id];\n    if (id && data && \"expanded\" in data) {\n      const oldExpanded = data.expanded;\n      expanded = typeof expanded === \"undefined\" ? !data.expanded : expanded;\n      treeData.value[id].expanded = expanded;\n      if (oldExpanded !== expanded) {\n        instance.emit(\"expand-change\", row, expanded);\n      }\n      instance.store.updateTableScrollY();\n    }\n  };\n  const loadOrToggle = row => {\n    instance.store.assertRowKey();\n    const rowKey = watcherData.rowKey.value;\n    const id = getRowIdentity(row, rowKey);\n    const data = treeData.value[id];\n    if (lazy.value && data && \"loaded\" in data && !data.loaded) {\n      loadData(row, id, data);\n    } else {\n      toggleTreeExpansion(row, void 0);\n    }\n  };\n  const loadData = (row, key, treeNode) => {\n    const {\n      load\n    } = instance.props;\n    if (load && !treeData.value[key].loaded) {\n      treeData.value[key].loading = true;\n      load(row, treeNode, data => {\n        if (!Array.isArray(data)) {\n          throw new Error(\"[ElTable] data must be an array\");\n        }\n        treeData.value[key].loading = false;\n        treeData.value[key].loaded = true;\n        treeData.value[key].expanded = true;\n        if (data.length) {\n          lazyTreeNodeMap.value[key] = data;\n        }\n        instance.emit(\"expand-change\", row, true);\n      });\n    }\n  };\n  return {\n    loadData,\n    loadOrToggle,\n    toggleTreeExpansion,\n    updateTreeExpandKeys,\n    updateTreeData,\n    normalize,\n    states: {\n      expandRowKeys,\n      treeData,\n      indent,\n      lazy,\n      lazyTreeNodeMap,\n      lazyColumnIdentifier,\n      childrenColumnName\n    }\n  };\n}\nexport { useTree as default };","map":{"version":3,"names":["useTree","watcherData","expandRowKeys","ref","treeData","indent","lazy","lazyTreeNodeMap","lazyColumnIdentifier","childrenColumnName","instance","getCurrentInstance","normalizedData","computed","rowKey","value","data","normalize","normalizedLazyNode","keys","Object","res","length","forEach","key","item","children","row","currentRowKey","getRowIdentity","push","walkTreeNode","parent","level","parentId","Array","isArray","map","updateTreeData","ifChangeExpandRowKeys","ifExpandAll","_a","store","states","defaultExpandAll","_a2","nested","normalizedLazyNode_","newTreeData","oldTreeData","unref","rootLazyRowKeys","getExpanded","oldValue","includes","expanded","included","newValue","loaded","loading","lazyKeys","lazyNodeChildren","indexOf","Error","updateTableScrollY","watch","updateTreeExpandKeys","toggleTreeExpansion","assertRowKey","id","oldExpanded","emit","loadOrToggle","loadData","treeNode","load","props"],"sources":["../../../../../../../packages/components/table/src/store/tree.ts"],"sourcesContent":["import { ref, computed, watch, getCurrentInstance, unref } from 'vue'\nimport { walkTreeNode, getRowIdentity } from '../util'\n\nimport type { WatcherPropsData } from '.'\nimport type { Table, TableProps } from '../table/defaults'\n\nfunction useTree<T>(watcherData: WatcherPropsData<T>) {\n  const expandRowKeys = ref<string[]>([])\n  const treeData = ref<unknown>({})\n  const indent = ref(16)\n  const lazy = ref(false)\n  const lazyTreeNodeMap = ref({})\n  const lazyColumnIdentifier = ref('hasChildren')\n  const childrenColumnName = ref('children')\n  const instance = getCurrentInstance() as Table<T>\n  const normalizedData = computed(() => {\n    if (!watcherData.rowKey.value) return {}\n    const data = watcherData.data.value || []\n    return normalize(data)\n  })\n  const normalizedLazyNode = computed(() => {\n    const rowKey = watcherData.rowKey.value\n    const keys = Object.keys(lazyTreeNodeMap.value)\n    const res = {}\n    if (!keys.length) return res\n    keys.forEach((key) => {\n      if (lazyTreeNodeMap.value[key].length) {\n        const item = { children: [] }\n        lazyTreeNodeMap.value[key].forEach((row) => {\n          const currentRowKey = getRowIdentity(row, rowKey)\n          item.children.push(currentRowKey)\n          if (row[lazyColumnIdentifier.value] && !res[currentRowKey]) {\n            res[currentRowKey] = { children: [] }\n          }\n        })\n        res[key] = item\n      }\n    })\n    return res\n  })\n\n  const normalize = (data) => {\n    const rowKey = watcherData.rowKey.value\n    const res = {}\n    walkTreeNode(\n      data,\n      (parent, children, level) => {\n        const parentId = getRowIdentity(parent, rowKey)\n        if (Array.isArray(children)) {\n          res[parentId] = {\n            children: children.map((row) => getRowIdentity(row, rowKey)),\n            level,\n          }\n        } else if (lazy.value) {\n          // 当 children 不存在且 lazy 为 true，该节点即为懒加载的节点\n          res[parentId] = {\n            children: [],\n            lazy: true,\n            level,\n          }\n        }\n      },\n      childrenColumnName.value,\n      lazyColumnIdentifier.value\n    )\n    return res\n  }\n\n  const updateTreeData = (\n    ifChangeExpandRowKeys = false,\n    ifExpandAll = instance.store?.states.defaultExpandAll.value\n  ) => {\n    const nested = normalizedData.value\n    const normalizedLazyNode_ = normalizedLazyNode.value\n    const keys = Object.keys(nested)\n    const newTreeData = {}\n    if (keys.length) {\n      const oldTreeData = unref(treeData)\n      const rootLazyRowKeys = []\n      const getExpanded = (oldValue, key) => {\n        if (ifChangeExpandRowKeys) {\n          if (expandRowKeys.value) {\n            return ifExpandAll || expandRowKeys.value.includes(key)\n          } else {\n            return !!(ifExpandAll || oldValue?.expanded)\n          }\n        } else {\n          const included =\n            ifExpandAll ||\n            (expandRowKeys.value && expandRowKeys.value.includes(key))\n          return !!(oldValue?.expanded || included)\n        }\n      }\n      // 合并 expanded 与 display，确保数据刷新后，状态不变\n      keys.forEach((key) => {\n        const oldValue = oldTreeData[key]\n        const newValue = { ...nested[key] }\n        newValue.expanded = getExpanded(oldValue, key)\n        if (newValue.lazy) {\n          const { loaded = false, loading = false } = oldValue || {}\n          newValue.loaded = !!loaded\n          newValue.loading = !!loading\n          rootLazyRowKeys.push(key)\n        }\n        newTreeData[key] = newValue\n      })\n      // 根据懒加载数据更新 treeData\n      const lazyKeys = Object.keys(normalizedLazyNode_)\n      if (lazy.value && lazyKeys.length && rootLazyRowKeys.length) {\n        lazyKeys.forEach((key) => {\n          const oldValue = oldTreeData[key]\n          const lazyNodeChildren = normalizedLazyNode_[key].children\n          if (rootLazyRowKeys.indexOf(key) !== -1) {\n            // 懒加载的 root 节点，更新一下原有的数据，原来的 children 一定是空数组\n            if (newTreeData[key].children.length !== 0) {\n              throw new Error('[ElTable]children must be an empty array.')\n            }\n            newTreeData[key].children = lazyNodeChildren\n          } else {\n            const { loaded = false, loading = false } = oldValue || {}\n            newTreeData[key] = {\n              lazy: true,\n              loaded: !!loaded,\n              loading: !!loading,\n              expanded: getExpanded(oldValue, key),\n              children: lazyNodeChildren,\n              level: '',\n            }\n          }\n        })\n      }\n    }\n    treeData.value = newTreeData\n    instance.store?.updateTableScrollY()\n  }\n\n  watch(\n    () => expandRowKeys.value,\n    () => {\n      updateTreeData(true)\n    }\n  )\n\n  watch(\n    () => normalizedData.value,\n    () => {\n      updateTreeData()\n    }\n  )\n  watch(\n    () => normalizedLazyNode.value,\n    () => {\n      updateTreeData()\n    }\n  )\n\n  const updateTreeExpandKeys = (value: string[]) => {\n    expandRowKeys.value = value\n    updateTreeData()\n  }\n\n  const toggleTreeExpansion = (row: T, expanded?: boolean) => {\n    instance.store.assertRowKey()\n\n    const rowKey = watcherData.rowKey.value\n    const id = getRowIdentity(row, rowKey)\n    const data = id && treeData.value[id]\n    if (id && data && 'expanded' in data) {\n      const oldExpanded = data.expanded\n      expanded = typeof expanded === 'undefined' ? !data.expanded : expanded\n      treeData.value[id].expanded = expanded\n      if (oldExpanded !== expanded) {\n        instance.emit('expand-change', row, expanded)\n      }\n      instance.store.updateTableScrollY()\n    }\n  }\n\n  const loadOrToggle = (row) => {\n    instance.store.assertRowKey()\n    const rowKey = watcherData.rowKey.value\n    const id = getRowIdentity(row, rowKey)\n    const data = treeData.value[id]\n    if (lazy.value && data && 'loaded' in data && !data.loaded) {\n      loadData(row, id, data)\n    } else {\n      toggleTreeExpansion(row, undefined)\n    }\n  }\n\n  const loadData = (row: T, key: string, treeNode) => {\n    const { load } = instance.props as unknown as TableProps<T>\n    if (load && !treeData.value[key].loaded) {\n      treeData.value[key].loading = true\n      load(row, treeNode, (data) => {\n        if (!Array.isArray(data)) {\n          throw new Error('[ElTable] data must be an array')\n        }\n        treeData.value[key].loading = false\n        treeData.value[key].loaded = true\n        treeData.value[key].expanded = true\n        if (data.length) {\n          lazyTreeNodeMap.value[key] = data\n        }\n        instance.emit('expand-change', row, true)\n      })\n    }\n  }\n\n  return {\n    loadData,\n    loadOrToggle,\n    toggleTreeExpansion,\n    updateTreeExpandKeys,\n    updateTreeData,\n    normalize,\n    states: {\n      expandRowKeys,\n      treeData,\n      indent,\n      lazy,\n      lazyTreeNodeMap,\n      lazyColumnIdentifier,\n      childrenColumnName,\n    },\n  }\n}\n\nexport default useTree\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}