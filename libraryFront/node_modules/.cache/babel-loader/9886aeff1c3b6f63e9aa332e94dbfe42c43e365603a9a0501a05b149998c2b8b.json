{"ast":null,"code":"import { defineComponent, shallowRef, reactive, computed, watch, onMounted } from 'vue';\nimport { useEventListener, useResizeObserver } from '@vueuse/core';\nimport { getScrollContainer } from '../../../utils/dom.mjs';\nimport { affixProps, affixEmits } from './affix.mjs';\nvar script = defineComponent({\n  name: \"ElAffix\",\n  props: affixProps,\n  emits: affixEmits,\n  setup(props, {\n    emit\n  }) {\n    const target = shallowRef();\n    const root = shallowRef();\n    const scrollContainer = shallowRef();\n    const state = reactive({\n      fixed: false,\n      height: 0,\n      width: 0,\n      scrollTop: 0,\n      clientHeight: 0,\n      transform: 0\n    });\n    const rootStyle = computed(() => {\n      return {\n        height: state.fixed ? `${state.height}px` : \"\",\n        width: state.fixed ? `${state.width}px` : \"\"\n      };\n    });\n    const affixStyle = computed(() => {\n      if (!state.fixed) return;\n      const offset = props.offset ? `${props.offset}px` : 0;\n      const transform = state.transform ? `translateY(${state.transform}px)` : \"\";\n      return {\n        height: `${state.height}px`,\n        width: `${state.width}px`,\n        top: props.position === \"top\" ? offset : \"\",\n        bottom: props.position === \"bottom\" ? offset : \"\",\n        transform,\n        zIndex: props.zIndex\n      };\n    });\n    const update = () => {\n      if (!root.value || !target.value || !scrollContainer.value) return;\n      const rootRect = root.value.getBoundingClientRect();\n      const targetRect = target.value.getBoundingClientRect();\n      state.height = rootRect.height;\n      state.width = rootRect.width;\n      state.scrollTop = scrollContainer.value instanceof Window ? document.documentElement.scrollTop : scrollContainer.value.scrollTop;\n      state.clientHeight = document.documentElement.clientHeight;\n      if (props.position === \"top\") {\n        if (props.target) {\n          const difference = targetRect.bottom - props.offset - state.height;\n          state.fixed = props.offset > rootRect.top && targetRect.bottom > 0;\n          state.transform = difference < 0 ? difference : 0;\n        } else {\n          state.fixed = props.offset > rootRect.top;\n        }\n      } else {\n        if (props.target) {\n          const difference = state.clientHeight - targetRect.top - props.offset - state.height;\n          state.fixed = state.clientHeight - props.offset < rootRect.bottom && state.clientHeight > targetRect.top;\n          state.transform = difference < 0 ? -difference : 0;\n        } else {\n          state.fixed = state.clientHeight - props.offset < rootRect.bottom;\n        }\n      }\n    };\n    const onScroll = () => {\n      update();\n      emit(\"scroll\", {\n        scrollTop: state.scrollTop,\n        fixed: state.fixed\n      });\n    };\n    watch(() => state.fixed, () => {\n      emit(\"change\", state.fixed);\n    });\n    onMounted(() => {\n      var _a;\n      if (props.target) {\n        target.value = (_a = document.querySelector(props.target)) != null ? _a : void 0;\n        if (!target.value) {\n          throw new Error(`Target is not existed: ${props.target}`);\n        }\n      } else {\n        target.value = document.documentElement;\n      }\n      scrollContainer.value = getScrollContainer(root.value, true);\n    });\n    useEventListener(scrollContainer, \"scroll\", onScroll);\n    useResizeObserver(root, () => update());\n    useResizeObserver(target, () => update());\n    return {\n      root,\n      state,\n      rootStyle,\n      affixStyle,\n      update\n    };\n  }\n});\nexport { script as default };","map":{"version":3,"names":["script","defineComponent","name","props","affixProps","emits","affixEmits","setup","emit","target","shallowRef","root","scrollContainer","state","reactive","fixed","height","width","scrollTop","clientHeight","transform","rootStyle","computed","affixStyle","offset","top","position","bottom","zIndex","update","value","rootRect","getBoundingClientRect","targetRect","Window","document","documentElement","difference","onScroll","watch","onMounted","_a","querySelector","Error","getScrollContainer","useEventListener","useResizeObserver"],"sources":["../../../../../../packages/components/affix/src/affix.vue"],"sourcesContent":["<template>\n  <div ref=\"root\" class=\"el-affix\" :style=\"rootStyle\">\n    <div :class=\"{ 'el-affix--fixed': state.fixed }\" :style=\"affixStyle\">\n      <slot></slot>\n    </div>\n  </div>\n</template>\n<script lang=\"ts\">\nimport {\n  computed,\n  defineComponent,\n  onMounted,\n  reactive,\n  shallowRef,\n  watch,\n} from 'vue'\nimport { useEventListener, useResizeObserver } from '@vueuse/core'\nimport { getScrollContainer } from '@element-plus/utils/dom'\nimport { affixEmits, affixProps } from './affix'\n\nimport type { CSSProperties } from 'vue'\n\nexport default defineComponent({\n  name: 'ElAffix',\n\n  props: affixProps,\n  emits: affixEmits,\n\n  setup(props, { emit }) {\n    const target = shallowRef<HTMLElement>()\n    const root = shallowRef<HTMLDivElement>()\n    const scrollContainer = shallowRef<HTMLElement | Window>()\n\n    const state = reactive({\n      fixed: false,\n      height: 0, // height of root\n      width: 0, // width of root\n      scrollTop: 0, // scrollTop of documentElement\n      clientHeight: 0, // clientHeight of documentElement\n      transform: 0,\n    })\n\n    const rootStyle = computed<CSSProperties>(() => {\n      return {\n        height: state.fixed ? `${state.height}px` : '',\n        width: state.fixed ? `${state.width}px` : '',\n      }\n    })\n\n    const affixStyle = computed<CSSProperties | undefined>(() => {\n      if (!state.fixed) return\n\n      const offset = props.offset ? `${props.offset}px` : 0\n      const transform = state.transform\n        ? `translateY(${state.transform}px)`\n        : ''\n\n      return {\n        height: `${state.height}px`,\n        width: `${state.width}px`,\n        top: props.position === 'top' ? offset : '',\n        bottom: props.position === 'bottom' ? offset : '',\n        transform,\n        zIndex: props.zIndex,\n      }\n    })\n\n    const update = () => {\n      if (!root.value || !target.value || !scrollContainer.value) return\n\n      const rootRect = root.value.getBoundingClientRect()\n      const targetRect = target.value.getBoundingClientRect()\n      state.height = rootRect.height\n      state.width = rootRect.width\n      state.scrollTop =\n        scrollContainer.value instanceof Window\n          ? document.documentElement.scrollTop\n          : scrollContainer.value.scrollTop\n      state.clientHeight = document.documentElement.clientHeight\n\n      if (props.position === 'top') {\n        if (props.target) {\n          const difference = targetRect.bottom - props.offset - state.height\n          state.fixed = props.offset > rootRect.top && targetRect.bottom > 0\n          state.transform = difference < 0 ? difference : 0\n        } else {\n          state.fixed = props.offset > rootRect.top\n        }\n      } else {\n        if (props.target) {\n          const difference =\n            state.clientHeight - targetRect.top - props.offset - state.height\n          state.fixed =\n            state.clientHeight - props.offset < rootRect.bottom &&\n            state.clientHeight > targetRect.top\n          state.transform = difference < 0 ? -difference : 0\n        } else {\n          state.fixed = state.clientHeight - props.offset < rootRect.bottom\n        }\n      }\n    }\n\n    const onScroll = () => {\n      update()\n\n      emit('scroll', {\n        scrollTop: state.scrollTop,\n        fixed: state.fixed,\n      })\n    }\n\n    watch(\n      () => state.fixed,\n      () => {\n        emit('change', state.fixed)\n      }\n    )\n\n    onMounted(() => {\n      if (props.target) {\n        target.value =\n          document.querySelector<HTMLElement>(props.target) ?? undefined\n        if (!target.value) {\n          throw new Error(`Target is not existed: ${props.target}`)\n        }\n      } else {\n        target.value = document.documentElement\n      }\n      scrollContainer.value = getScrollContainer(root.value!, true)\n    })\n\n    useEventListener(scrollContainer, 'scroll', onScroll)\n    useResizeObserver(root, () => update())\n    useResizeObserver(target, () => update())\n\n    return {\n      root,\n      state,\n      rootStyle,\n      affixStyle,\n      update,\n    }\n  },\n})\n</script>\n"],"mappings":";;;;AAsBA,IAAAA,MAAA,GAAeC,eAAA,CAAgB;EAC7BC,IAAA,EAAM;EAENC,KAAA,EAAOC,UAAA;EACPC,KAAA,EAAOC,UAAA;EAEPC,MAAMJ,KAAA,EAAO;IAAEK;EAAA,GAAQ;IACrB,MAAMC,MAAA,GAASC,UAAA;IACf,MAAMC,IAAA,GAAOD,UAAA;IACb,MAAME,eAAA,GAAkBF,UAAA;IAExB,MAAMG,KAAA,GAAQC,QAAA,CAAS;MACrBC,KAAA,EAAO;MACPC,MAAA,EAAQ;MACRC,KAAA,EAAO;MACPC,SAAA,EAAW;MACXC,YAAA,EAAc;MACdC,SAAA,EAAW;IAAA;IAGb,MAAMC,SAAA,GAAYC,QAAA,CAAwB,MAAM;MAC9C,OAAO;QACLN,MAAA,EAAQH,KAAA,CAAME,KAAA,GAAQ,GAAGF,KAAA,CAAMG,MAAA,OAAa;QAC5CC,KAAA,EAAOJ,KAAA,CAAME,KAAA,GAAQ,GAAGF,KAAA,CAAMI,KAAA,OAAY;MAAA;IAAA;IAI9C,MAAMM,UAAA,GAAaD,QAAA,CAAoC,MAAM;MAC3D,IAAI,CAACT,KAAA,CAAME,KAAA,EAAO;MAElB,MAAMS,MAAA,GAASrB,KAAA,CAAMqB,MAAA,GAAS,GAAGrB,KAAA,CAAMqB,MAAA,OAAa;MACpD,MAAMJ,SAAA,GAAYP,KAAA,CAAMO,SAAA,GACpB,cAAcP,KAAA,CAAMO,SAAA,QACpB;MAEJ,OAAO;QACLJ,MAAA,EAAQ,GAAGH,KAAA,CAAMG,MAAA;QACjBC,KAAA,EAAO,GAAGJ,KAAA,CAAMI,KAAA;QAChBQ,GAAA,EAAKtB,KAAA,CAAMuB,QAAA,KAAa,QAAQF,MAAA,GAAS;QACzCG,MAAA,EAAQxB,KAAA,CAAMuB,QAAA,KAAa,WAAWF,MAAA,GAAS;QAC/CJ,SAAA;QACAQ,MAAA,EAAQzB,KAAA,CAAMyB;MAAA;IAAA;IAIlB,MAAMC,MAAA,GAASA,CAAA,KAAM;MACnB,IAAI,CAAClB,IAAA,CAAKmB,KAAA,IAAS,CAACrB,MAAA,CAAOqB,KAAA,IAAS,CAAClB,eAAA,CAAgBkB,KAAA,EAAO;MAE5D,MAAMC,QAAA,GAAWpB,IAAA,CAAKmB,KAAA,CAAME,qBAAA;MAC5B,MAAMC,UAAA,GAAaxB,MAAA,CAAOqB,KAAA,CAAME,qBAAA;MAChCnB,KAAA,CAAMG,MAAA,GAASe,QAAA,CAASf,MAAA;MACxBH,KAAA,CAAMI,KAAA,GAAQc,QAAA,CAASd,KAAA;MACvBJ,KAAA,CAAMK,SAAA,GACJN,eAAA,CAAgBkB,KAAA,YAAiBI,MAAA,GAC7BC,QAAA,CAASC,eAAA,CAAgBlB,SAAA,GACzBN,eAAA,CAAgBkB,KAAA,CAAMZ,SAAA;MAC5BL,KAAA,CAAMM,YAAA,GAAegB,QAAA,CAASC,eAAA,CAAgBjB,YAAA;MAE9C,IAAIhB,KAAA,CAAMuB,QAAA,KAAa,OAAO;QAC5B,IAAIvB,KAAA,CAAMM,MAAA,EAAQ;UAChB,MAAM4B,UAAA,GAAaJ,UAAA,CAAWN,MAAA,GAASxB,KAAA,CAAMqB,MAAA,GAASX,KAAA,CAAMG,MAAA;UAC5DH,KAAA,CAAME,KAAA,GAAQZ,KAAA,CAAMqB,MAAA,GAASO,QAAA,CAASN,GAAA,IAAOQ,UAAA,CAAWN,MAAA,GAAS;UACjEd,KAAA,CAAMO,SAAA,GAAYiB,UAAA,GAAa,IAAIA,UAAA,GAAa;QAAA,OAC3C;UACLxB,KAAA,CAAME,KAAA,GAAQZ,KAAA,CAAMqB,MAAA,GAASO,QAAA,CAASN,GAAA;QAAA;MAAA,OAEnC;QACL,IAAItB,KAAA,CAAMM,MAAA,EAAQ;UAChB,MAAM4B,UAAA,GACJxB,KAAA,CAAMM,YAAA,GAAec,UAAA,CAAWR,GAAA,GAAMtB,KAAA,CAAMqB,MAAA,GAASX,KAAA,CAAMG,MAAA;UAC7DH,KAAA,CAAME,KAAA,GACJF,KAAA,CAAMM,YAAA,GAAehB,KAAA,CAAMqB,MAAA,GAASO,QAAA,CAASJ,MAAA,IAC7Cd,KAAA,CAAMM,YAAA,GAAec,UAAA,CAAWR,GAAA;UAClCZ,KAAA,CAAMO,SAAA,GAAYiB,UAAA,GAAa,IAAI,CAACA,UAAA,GAAa;QAAA,OAC5C;UACLxB,KAAA,CAAME,KAAA,GAAQF,KAAA,CAAMM,YAAA,GAAehB,KAAA,CAAMqB,MAAA,GAASO,QAAA,CAASJ,MAAA;QAAA;MAAA;IAAA;IAKjE,MAAMW,QAAA,GAAWA,CAAA,KAAM;MACrBT,MAAA;MAEArB,IAAA,CAAK,UAAU;QACbU,SAAA,EAAWL,KAAA,CAAMK,SAAA;QACjBH,KAAA,EAAOF,KAAA,CAAME;MAAA;IAAA;IAIjBwB,KAAA,CACE,MAAM1B,KAAA,CAAME,KAAA,EACZ,MAAM;MACJP,IAAA,CAAK,UAAUK,KAAA,CAAME,KAAA;IAAA;IAIzByB,SAAA,CAAU,MAAM;;MACd,IAAIrC,KAAA,CAAMM,MAAA,EAAQ;QAChBA,MAAA,CAAOqB,KAAA,GACL,CAAAW,EAAA,GAAAN,QAAA,CAASO,aAAA,CAA2BvC,KAAA,CAAMM,MAAA,MAA1C,OAAAgC,EAAA,GAAqD;QACvD,IAAI,CAAChC,MAAA,CAAOqB,KAAA,EAAO;UACjB,MAAM,IAAIa,KAAA,CAAM,0BAA0BxC,KAAA,CAAMM,MAAA;QAAA;MAAA,OAE7C;QACLA,MAAA,CAAOqB,KAAA,GAAQK,QAAA,CAASC,eAAA;MAAA;MAE1BxB,eAAA,CAAgBkB,KAAA,GAAQc,kBAAA,CAAmBjC,IAAA,CAAKmB,KAAA,EAAQ;IAAA;IAG1De,gBAAA,CAAiBjC,eAAA,EAAiB,UAAU0B,QAAA;IAC5CQ,iBAAA,CAAkBnC,IAAA,EAAM,MAAMkB,MAAA;IAC9BiB,iBAAA,CAAkBrC,MAAA,EAAQ,MAAMoB,MAAA;IAEhC,OAAO;MACLlB,IAAA;MACAE,KAAA;MACAQ,SAAA;MACAE,UAAA;MACAM;IAAA;EAAA;AAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}