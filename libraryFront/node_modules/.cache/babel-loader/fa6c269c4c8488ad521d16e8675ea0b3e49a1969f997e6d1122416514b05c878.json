{"ast":null,"code":"import isServer from './isServer.mjs';\nimport './util.mjs';\nimport { camelize, isObject } from '@vue/shared';\nconst trimArr = function (s) {\n  return (s || \"\").split(\" \").filter(item => !!item.trim());\n};\nconst on = function (element, event, handler, useCapture = false) {\n  if (element && event && handler) {\n    element == null ? void 0 : element.addEventListener(event, handler, useCapture);\n  }\n};\nconst off = function (element, event, handler, useCapture = false) {\n  if (element && event && handler) {\n    element == null ? void 0 : element.removeEventListener(event, handler, useCapture);\n  }\n};\nconst once = function (el, event, fn) {\n  const listener = function (...args) {\n    if (fn) {\n      fn.apply(this, args);\n    }\n    off(el, event, listener);\n  };\n  on(el, event, listener);\n};\nfunction hasClass(el, cls) {\n  if (!el || !cls) return false;\n  if (cls.indexOf(\" \") !== -1) throw new Error(\"className should not contain space.\");\n  if (el.classList) {\n    return el.classList.contains(cls);\n  } else {\n    const className = el.getAttribute(\"class\") || \"\";\n    return className.split(\" \").includes(cls);\n  }\n}\nfunction addClass(el, cls) {\n  if (!el) return;\n  let className = el.getAttribute(\"class\") || \"\";\n  const curClass = trimArr(className);\n  const classes = (cls || \"\").split(\" \").filter(item => !curClass.includes(item) && !!item.trim());\n  if (el.classList) {\n    el.classList.add(...classes);\n  } else {\n    className += ` ${classes.join(\" \")}`;\n    el.setAttribute(\"class\", className);\n  }\n}\nfunction removeClass(el, cls) {\n  if (!el || !cls) return;\n  const classes = trimArr(cls);\n  let curClass = el.getAttribute(\"class\") || \"\";\n  if (el.classList) {\n    el.classList.remove(...classes);\n    return;\n  }\n  classes.forEach(item => {\n    curClass = curClass.replace(` ${item} `, \" \");\n  });\n  const className = trimArr(curClass).join(\" \");\n  el.setAttribute(\"class\", className);\n}\nconst getStyle = function (element, styleName) {\n  var _a;\n  if (isServer) return \"\";\n  if (!element || !styleName) return \"\";\n  styleName = camelize(styleName);\n  if (styleName === \"float\") {\n    styleName = \"cssFloat\";\n  }\n  try {\n    const style = element.style[styleName];\n    if (style) return style;\n    const computed = (_a = document.defaultView) == null ? void 0 : _a.getComputedStyle(element, \"\");\n    return computed ? computed[styleName] : \"\";\n  } catch (e) {\n    return element.style[styleName];\n  }\n};\nfunction setStyle(element, styleName, value) {\n  if (!element || !styleName) return;\n  if (isObject(styleName)) {\n    Object.keys(styleName).forEach(prop => {\n      setStyle(element, prop, styleName[prop]);\n    });\n  } else {\n    styleName = camelize(styleName);\n    element.style[styleName] = value;\n  }\n}\nfunction removeStyle(element, style) {\n  if (!element || !style) return;\n  if (isObject(style)) {\n    Object.keys(style).forEach(prop => {\n      setStyle(element, prop, \"\");\n    });\n  } else {\n    setStyle(element, style, \"\");\n  }\n}\nconst isScroll = (el, isVertical) => {\n  if (isServer) return null;\n  const determinedDirection = isVertical === null || isVertical === void 0;\n  const overflow = determinedDirection ? getStyle(el, \"overflow\") : isVertical ? getStyle(el, \"overflow-y\") : getStyle(el, \"overflow-x\");\n  return overflow.match(/(scroll|auto|overlay)/);\n};\nconst getScrollContainer = (el, isVertical) => {\n  if (isServer) return;\n  let parent = el;\n  while (parent) {\n    if ([window, document, document.documentElement].includes(parent)) {\n      return window;\n    }\n    if (isScroll(parent, isVertical)) {\n      return parent;\n    }\n    parent = parent.parentNode;\n  }\n  return parent;\n};\nconst isInContainer = (el, container) => {\n  if (isServer || !el || !container) return false;\n  const elRect = el.getBoundingClientRect();\n  let containerRect;\n  if (container instanceof Element) {\n    containerRect = container.getBoundingClientRect();\n  } else {\n    containerRect = {\n      top: 0,\n      right: window.innerWidth,\n      bottom: window.innerHeight,\n      left: 0\n    };\n  }\n  return elRect.top < containerRect.bottom && elRect.bottom > containerRect.top && elRect.right > containerRect.left && elRect.left < containerRect.right;\n};\nconst getOffsetTop = el => {\n  let offset = 0;\n  let parent = el;\n  while (parent) {\n    offset += parent.offsetTop;\n    parent = parent.offsetParent;\n  }\n  return offset;\n};\nconst getOffsetTopDistance = (el, containerEl) => {\n  return Math.abs(getOffsetTop(el) - getOffsetTop(containerEl));\n};\nconst stop = e => e.stopPropagation();\nconst getClientXY = event => {\n  let clientX;\n  let clientY;\n  if (event.type === \"touchend\") {\n    clientY = event.changedTouches[0].clientY;\n    clientX = event.changedTouches[0].clientX;\n  } else if (event.type.startsWith(\"touch\")) {\n    clientY = event.touches[0].clientY;\n    clientX = event.touches[0].clientX;\n  } else {\n    clientY = event.clientY;\n    clientX = event.clientX;\n  }\n  return {\n    clientX,\n    clientY\n  };\n};\nexport { addClass, getClientXY, getOffsetTop, getOffsetTopDistance, getScrollContainer, getStyle, hasClass, isInContainer, isScroll, off, on, once, removeClass, removeStyle, setStyle, stop };","map":{"version":3,"names":["trimArr","s","split","filter","item","trim","on","element","event","handler","useCapture","addEventListener","off","removeEventListener","once","el","fn","listener","args","apply","cls","indexOf","Error","classList","contains","className","getAttribute","includes","curClass","classes","add","join","setAttribute","remove","forEach","replace","getStyle","styleName","_a","isServer","camelize","style","computed","document","defaultView","getComputedStyle","e","value","isObject","Object","keys","prop","setStyle","isScroll","isVertical","determinedDirection","overflow","match","getScrollContainer","parent","window","documentElement","parentNode","isInContainer","container","elRect","getBoundingClientRect","containerRect","Element","top","right","innerWidth","bottom","innerHeight","left","getOffsetTop","offset","offsetTop","offsetParent","getOffsetTopDistance","containerEl","Math","abs","stop","stopPropagation","getClientXY","clientX","clientY","type","changedTouches","startsWith","touches"],"sources":["../../../../packages/utils/dom.ts"],"sourcesContent":["import isServer from './isServer'\nimport { camelize, isObject } from './util'\nimport type { CSSProperties } from 'vue'\n\nimport type { Nullable } from './types'\n\n/* istanbul ignore next */\nconst trimArr = function (s: string) {\n  return (s || '').split(' ').filter((item) => !!item.trim())\n}\n\n/* istanbul ignore next */\nexport const on = function (\n  element: HTMLElement | Document | Window,\n  event: string,\n  handler: EventListenerOrEventListenerObject,\n  useCapture = false\n): void {\n  if (element && event && handler) {\n    element?.addEventListener(event, handler, useCapture)\n  }\n}\n\n/* istanbul ignore next */\nexport const off = function (\n  element: HTMLElement | Document | Window,\n  event: string,\n  handler: EventListenerOrEventListenerObject,\n  useCapture = false\n): void {\n  if (element && event && handler) {\n    element?.removeEventListener(event, handler, useCapture)\n  }\n}\n\n/* istanbul ignore next */\nexport const once = function (\n  el: HTMLElement,\n  event: string,\n  fn: EventListener\n): void {\n  const listener = function (this: any, ...args: any) {\n    if (fn) {\n      fn.apply(this, args)\n    }\n    off(el, event, listener)\n  }\n  on(el, event, listener)\n}\n\n/* istanbul ignore next */\nexport function hasClass(el: HTMLElement | Element, cls: string): boolean {\n  if (!el || !cls) return false\n  if (cls.indexOf(' ') !== -1)\n    throw new Error('className should not contain space.')\n  if (el.classList) {\n    return el.classList.contains(cls)\n  } else {\n    const className = el.getAttribute('class') || ''\n    return className.split(' ').includes(cls)\n  }\n}\n\n/* istanbul ignore next */\nexport function addClass(el: HTMLElement | Element, cls: string): void {\n  if (!el) return\n  let className = el.getAttribute('class') || ''\n  const curClass = trimArr(className)\n  const classes = (cls || '')\n    .split(' ')\n    .filter((item) => !curClass.includes(item) && !!item.trim())\n\n  if (el.classList) {\n    el.classList.add(...classes)\n  } else {\n    className += ` ${classes.join(' ')}`\n    el.setAttribute('class', className)\n  }\n}\n\n/* istanbul ignore next */\nexport function removeClass(el: HTMLElement | Element, cls: string): void {\n  if (!el || !cls) return\n  const classes = trimArr(cls)\n  let curClass = el.getAttribute('class') || ''\n\n  if (el.classList) {\n    el.classList.remove(...classes)\n    return\n  }\n  classes.forEach((item) => {\n    curClass = curClass.replace(` ${item} `, ' ')\n  })\n  const className = trimArr(curClass).join(' ')\n  el.setAttribute('class', className)\n}\n\n/* istanbul ignore next */\n// Here I want to use the type CSSProperties, but the definition for CSSProperties\n// has { [index: number]: string } in its type annotation, which does not satisfy the method\n// camelize(s: string)\n// Same as the return type\nexport const getStyle = function (\n  element: HTMLElement,\n  styleName: string\n): string {\n  if (isServer) return ''\n  if (!element || !styleName) return ''\n  styleName = camelize(styleName)\n  if (styleName === 'float') {\n    styleName = 'cssFloat'\n  }\n  try {\n    const style = element.style[styleName]\n    if (style) return style\n    const computed = document.defaultView?.getComputedStyle(element, '')\n    return computed ? computed[styleName] : ''\n  } catch (e) {\n    return element.style[styleName]\n  }\n}\n\n/* istanbul ignore next */\nexport function setStyle(\n  element: HTMLElement,\n  styleName: CSSProperties | string,\n  value?: string\n): void {\n  if (!element || !styleName) return\n\n  if (isObject(styleName)) {\n    Object.keys(styleName).forEach((prop) => {\n      setStyle(element, prop, styleName[prop])\n    })\n  } else {\n    styleName = camelize(styleName)\n    element.style[styleName] = value\n  }\n}\n\nexport function removeStyle(\n  element: HTMLElement,\n  style: CSSProperties | string\n) {\n  if (!element || !style) return\n\n  if (isObject(style)) {\n    Object.keys(style).forEach((prop) => {\n      setStyle(element, prop, '')\n    })\n  } else {\n    setStyle(element, style, '')\n  }\n}\n\nexport const isScroll = (\n  el: HTMLElement,\n  isVertical?: Nullable<boolean>\n): RegExpMatchArray | null => {\n  if (isServer) return null\n  const determinedDirection = isVertical === null || isVertical === undefined\n  const overflow = determinedDirection\n    ? getStyle(el, 'overflow')\n    : isVertical\n    ? getStyle(el, 'overflow-y')\n    : getStyle(el, 'overflow-x')\n\n  return overflow.match(/(scroll|auto|overlay)/)\n}\n\nexport const getScrollContainer = (\n  el: HTMLElement,\n  isVertical?: Nullable<boolean>\n): Window | HTMLElement | undefined => {\n  if (isServer) return\n\n  let parent: HTMLElement = el\n  while (parent) {\n    if ([window, document, document.documentElement].includes(parent)) {\n      return window\n    }\n    if (isScroll(parent, isVertical)) {\n      return parent\n    }\n    parent = parent.parentNode as HTMLElement\n  }\n  return parent\n}\n\nexport const isInContainer = (\n  el: Element | undefined,\n  container: Element | Window | undefined\n): boolean => {\n  if (isServer || !el || !container) return false\n\n  const elRect = el.getBoundingClientRect()\n\n  let containerRect: Pick<DOMRect, 'top' | 'bottom' | 'left' | 'right'>\n  if (container instanceof Element) {\n    containerRect = container.getBoundingClientRect()\n  } else {\n    containerRect = {\n      top: 0,\n      right: window.innerWidth,\n      bottom: window.innerHeight,\n      left: 0,\n    }\n  }\n  return (\n    elRect.top < containerRect.bottom &&\n    elRect.bottom > containerRect.top &&\n    elRect.right > containerRect.left &&\n    elRect.left < containerRect.right\n  )\n}\n\nexport const getOffsetTop = (el: HTMLElement) => {\n  let offset = 0\n  let parent = el\n\n  while (parent) {\n    offset += parent.offsetTop\n    parent = parent.offsetParent as HTMLElement\n  }\n\n  return offset\n}\n\nexport const getOffsetTopDistance = (\n  el: HTMLElement,\n  containerEl: HTMLElement\n) => {\n  return Math.abs(getOffsetTop(el) - getOffsetTop(containerEl))\n}\n\nexport const stop = (e: Event) => e.stopPropagation()\n\nexport const getClientXY = (event: MouseEvent | TouchEvent) => {\n  let clientX: number\n  let clientY: number\n  if (event.type === 'touchend') {\n    clientY = (event as TouchEvent).changedTouches[0].clientY\n    clientX = (event as TouchEvent).changedTouches[0].clientX\n  } else if (event.type.startsWith('touch')) {\n    clientY = (event as TouchEvent).touches[0].clientY\n    clientX = (event as TouchEvent).touches[0].clientX\n  } else {\n    clientY = (event as MouseEvent).clientY\n    clientX = (event as MouseEvent).clientX\n  }\n  return {\n    clientX,\n    clientY,\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}