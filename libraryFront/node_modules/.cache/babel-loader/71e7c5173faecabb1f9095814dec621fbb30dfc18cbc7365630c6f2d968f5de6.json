{"ast":null,"code":"import { isFunction } from '@vue/shared';\nimport { throwError } from '../../../../utils/error.mjs';\nimport createGrid from '../builders/build-grid.mjs';\nimport { SMART_ALIGNMENT, AUTO_ALIGNMENT, CENTERED_ALIGNMENT, END_ALIGNMENT, START_ALIGNMENT, DEFAULT_DYNAMIC_LIST_ITEM_SIZE } from '../defaults.mjs';\nconst {\n  max,\n  min,\n  floor\n} = Math;\nconst SCOPE = \"ElDynamicSizeGrid\";\nconst ACCESS_SIZER_KEY_MAP = {\n  column: \"columnWidth\",\n  row: \"rowHeight\"\n};\nconst ACCESS_LAST_VISITED_KEY_MAP = {\n  column: \"lastVisitedColumnIndex\",\n  row: \"lastVisitedRowIndex\"\n};\nconst getItemFromCache = (props, index, gridCache, type) => {\n  const [cachedItems, sizer, lastVisited] = [gridCache[type], props[ACCESS_SIZER_KEY_MAP[type]], gridCache[ACCESS_LAST_VISITED_KEY_MAP[type]]];\n  if (index > lastVisited) {\n    let offset = 0;\n    if (lastVisited >= 0) {\n      const item = cachedItems[lastVisited];\n      offset = item.offset + item.size;\n    }\n    for (let i = lastVisited + 1; i <= index; i++) {\n      const size = sizer(i);\n      cachedItems[i] = {\n        offset,\n        size\n      };\n      offset += size;\n    }\n    gridCache[ACCESS_LAST_VISITED_KEY_MAP[type]] = index;\n  }\n  return cachedItems[index];\n};\nconst bs = (props, gridCache, low, high, offset, type) => {\n  while (low <= high) {\n    const mid = low + floor((high - low) / 2);\n    const currentOffset = getItemFromCache(props, mid, gridCache, type).offset;\n    if (currentOffset === offset) {\n      return mid;\n    } else if (currentOffset < offset) {\n      low = mid + 1;\n    } else {\n      high = mid - 1;\n    }\n  }\n  return max(0, low - 1);\n};\nconst es = (props, gridCache, idx, offset, type) => {\n  const total = type === \"column\" ? props.totalColumn : props.totalRow;\n  let exponent = 1;\n  while (idx < total && getItemFromCache(props, idx, gridCache, type).offset < offset) {\n    idx += exponent;\n    exponent *= 2;\n  }\n  return bs(props, gridCache, floor(idx / 2), min(idx, total - 1), offset, type);\n};\nconst findItem = (props, gridCache, offset, type) => {\n  const [cache, lastVisitedIndex] = [gridCache[type], gridCache[ACCESS_LAST_VISITED_KEY_MAP[type]]];\n  const lastVisitedItemOffset = lastVisitedIndex > 0 ? cache[lastVisitedIndex].offset : 0;\n  if (lastVisitedItemOffset >= offset) {\n    return bs(props, gridCache, 0, lastVisitedIndex, offset, type);\n  }\n  return es(props, gridCache, max(0, lastVisitedIndex), offset, type);\n};\nconst getEstimatedTotalHeight = ({\n  totalRow\n}, {\n  estimatedRowHeight,\n  lastVisitedRowIndex,\n  row\n}) => {\n  let sizeOfVisitedRows = 0;\n  if (lastVisitedRowIndex >= totalRow) {\n    lastVisitedRowIndex = totalRow - 1;\n  }\n  if (lastVisitedRowIndex >= 0) {\n    const item = row[lastVisitedRowIndex];\n    sizeOfVisitedRows = item.offset + item.size;\n  }\n  const unvisitedItems = totalRow - lastVisitedRowIndex - 1;\n  const sizeOfUnvisitedItems = unvisitedItems * estimatedRowHeight;\n  return sizeOfVisitedRows + sizeOfUnvisitedItems;\n};\nconst getEstimatedTotalWidth = ({\n  totalColumn\n}, {\n  column,\n  estimatedColumnWidth,\n  lastVisitedColumnIndex\n}) => {\n  let sizeOfVisitedColumns = 0;\n  if (lastVisitedColumnIndex > totalColumn) {\n    lastVisitedColumnIndex = totalColumn - 1;\n  }\n  if (lastVisitedColumnIndex >= 0) {\n    const item = column[lastVisitedColumnIndex];\n    sizeOfVisitedColumns = item.offset + item.size;\n  }\n  const unvisitedItems = totalColumn - lastVisitedColumnIndex - 1;\n  const sizeOfUnvisitedItems = unvisitedItems * estimatedColumnWidth;\n  return sizeOfVisitedColumns + sizeOfUnvisitedItems;\n};\nconst ACCESS_ESTIMATED_SIZE_KEY_MAP = {\n  column: getEstimatedTotalWidth,\n  row: getEstimatedTotalHeight\n};\nconst getOffset = (props, index, alignment, scrollOffset, cache, type, scrollBarWidth) => {\n  const [size, estimatedSizeAssociates] = [type === \"row\" ? props.height : props.width, ACCESS_ESTIMATED_SIZE_KEY_MAP[type]];\n  const item = getItemFromCache(props, index, cache, type);\n  const estimatedSize = estimatedSizeAssociates(props, cache);\n  const maxOffset = max(0, min(estimatedSize - size, item.offset));\n  const minOffset = max(0, item.offset - size + scrollBarWidth + item.size);\n  if (alignment === SMART_ALIGNMENT) {\n    if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\n      alignment = AUTO_ALIGNMENT;\n    } else {\n      alignment = CENTERED_ALIGNMENT;\n    }\n  }\n  switch (alignment) {\n    case START_ALIGNMENT:\n      {\n        return maxOffset;\n      }\n    case END_ALIGNMENT:\n      {\n        return minOffset;\n      }\n    case CENTERED_ALIGNMENT:\n      {\n        return Math.round(minOffset + (maxOffset - minOffset) / 2);\n      }\n    case AUTO_ALIGNMENT:\n    default:\n      {\n        if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n          return scrollOffset;\n        } else if (minOffset > maxOffset) {\n          return minOffset;\n        } else if (scrollOffset < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n      }\n  }\n};\nconst FixedSizeGrid = createGrid({\n  name: \"ElDynamicSizeGrid\",\n  getColumnPosition: (props, idx, cache) => {\n    const item = getItemFromCache(props, idx, cache, \"column\");\n    return [item.size, item.offset];\n  },\n  getRowPosition: (props, idx, cache) => {\n    const item = getItemFromCache(props, idx, cache, \"row\");\n    return [item.size, item.offset];\n  },\n  getColumnOffset: (props, columnIndex, alignment, scrollLeft, cache, scrollBarWidth) => getOffset(props, columnIndex, alignment, scrollLeft, cache, \"column\", scrollBarWidth),\n  getRowOffset: (props, rowIndex, alignment, scrollTop, cache, scrollBarWidth) => getOffset(props, rowIndex, alignment, scrollTop, cache, \"row\", scrollBarWidth),\n  getColumnStartIndexForOffset: (props, scrollLeft, cache) => findItem(props, cache, scrollLeft, \"column\"),\n  getColumnStopIndexForStartIndex: (props, startIndex, scrollLeft, cache) => {\n    const item = getItemFromCache(props, startIndex, cache, \"column\");\n    const maxOffset = scrollLeft + props.width;\n    let offset = item.offset + item.size;\n    let stopIndex = startIndex;\n    while (stopIndex < props.totalColumn - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemFromCache(props, startIndex, cache, \"column\").size;\n    }\n    return stopIndex;\n  },\n  getEstimatedTotalHeight,\n  getEstimatedTotalWidth,\n  getRowStartIndexForOffset: (props, scrollTop, cache) => findItem(props, cache, scrollTop, \"row\"),\n  getRowStopIndexForStartIndex: (props, startIndex, scrollTop, cache) => {\n    const {\n      totalRow,\n      height\n    } = props;\n    const item = getItemFromCache(props, startIndex, cache, \"row\");\n    const maxOffset = scrollTop + height;\n    let offset = item.size + item.offset;\n    let stopIndex = startIndex;\n    while (stopIndex < totalRow - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemFromCache(props, stopIndex, cache, \"row\").size;\n    }\n    return stopIndex;\n  },\n  initCache: ({\n    estimatedColumnWidth = DEFAULT_DYNAMIC_LIST_ITEM_SIZE,\n    estimatedRowHeight = DEFAULT_DYNAMIC_LIST_ITEM_SIZE\n  }) => {\n    const cache = {\n      column: {},\n      estimatedColumnWidth,\n      estimatedRowHeight,\n      lastVisitedColumnIndex: -1,\n      lastVisitedRowIndex: -1,\n      row: {}\n    };\n    return cache;\n  },\n  clearCache: true,\n  validateProps: ({\n    columnWidth,\n    rowHeight\n  }) => {\n    if (process.env.NODE_ENV !== \"production\") {\n      if (!isFunction(columnWidth)) {\n        throwError(SCOPE, `\n          \"columnWidth\" must be passed as function,\n            instead ${typeof columnWidth} was given.\n        `);\n      }\n      if (!isFunction(rowHeight)) {\n        throwError(SCOPE, `\n          \"columnWidth\" must be passed as function,\n            instead ${typeof rowHeight} was given.\n        `);\n      }\n    }\n  }\n});\nexport { FixedSizeGrid as default };","map":{"version":3,"names":["max","min","floor","Math","SCOPE","ACCESS_SIZER_KEY_MAP","column","row","ACCESS_LAST_VISITED_KEY_MAP","getItemFromCache","props","index","gridCache","type","cachedItems","sizer","lastVisited","offset","item","size","i","bs","low","high","mid","currentOffset","es","idx","total","totalColumn","totalRow","exponent","findItem","cache","lastVisitedIndex","lastVisitedItemOffset","getEstimatedTotalHeight","estimatedRowHeight","lastVisitedRowIndex","sizeOfVisitedRows","unvisitedItems","sizeOfUnvisitedItems","getEstimatedTotalWidth","estimatedColumnWidth","lastVisitedColumnIndex","sizeOfVisitedColumns","ACCESS_ESTIMATED_SIZE_KEY_MAP","getOffset","alignment","scrollOffset","scrollBarWidth","estimatedSizeAssociates","height","width","estimatedSize","maxOffset","minOffset","SMART_ALIGNMENT","AUTO_ALIGNMENT","CENTERED_ALIGNMENT","START_ALIGNMENT","END_ALIGNMENT","round","FixedSizeGrid","createGrid","name","getColumnPosition","getRowPosition","getColumnOffset","columnIndex","scrollLeft","getRowOffset","rowIndex","scrollTop","getColumnStartIndexForOffset","getColumnStopIndexForStartIndex","startIndex","stopIndex","getRowStartIndexForOffset","getRowStopIndexForStartIndex","initCache","DEFAULT_DYNAMIC_LIST_ITEM_SIZE","clearCache","validateProps","columnWidth","rowHeight","process","env","NODE_ENV","isFunction","throwError"],"sources":["../../../../../../../packages/components/virtual-list/src/components/dynamic-size-grid.ts"],"sourcesContent":["import { isFunction } from '@vue/shared'\nimport { throwError } from '@element-plus/utils/error'\nimport createGrid from '../builders/build-grid'\n\nimport {\n  AUTO_ALIGNMENT,\n  CENTERED_ALIGNMENT,\n  DEFAULT_DYNAMIC_LIST_ITEM_SIZE,\n  END_ALIGNMENT,\n  SMART_ALIGNMENT,\n  START_ALIGNMENT,\n} from '../defaults'\nimport type { VirtualizedGridProps } from '../props'\n\nimport type { Alignment, GridCache, ListItem, ItemSize } from '../types'\n\nconst { max, min, floor } = Math\nconst SCOPE = 'ElDynamicSizeGrid'\n\ntype Props = VirtualizedGridProps\ntype CacheItemType = 'column' | 'row'\n\n// generates props access key via type\nconst ACCESS_SIZER_KEY_MAP = {\n  column: 'columnWidth',\n  row: 'rowHeight',\n}\n\n// generates cache access key via type\nconst ACCESS_LAST_VISITED_KEY_MAP = {\n  column: 'lastVisitedColumnIndex',\n  row: 'lastVisitedRowIndex',\n}\n\nconst getItemFromCache = (\n  props: Props,\n  index: number,\n  gridCache: GridCache,\n  type: CacheItemType\n) => {\n  const [cachedItems, sizer, lastVisited] = [\n    gridCache[type],\n    props[ACCESS_SIZER_KEY_MAP[type]],\n    gridCache[ACCESS_LAST_VISITED_KEY_MAP[type]],\n  ] as [Record<string, ListItem>, ItemSize, number]\n\n  if (index > lastVisited) {\n    let offset = 0\n    if (lastVisited >= 0) {\n      const item = cachedItems[lastVisited]\n      offset = item.offset + item.size\n    }\n\n    for (let i = lastVisited + 1; i <= index; i++) {\n      const size = sizer(i)\n\n      cachedItems[i] = {\n        offset,\n        size,\n      }\n\n      offset += size\n    }\n\n    gridCache[ACCESS_LAST_VISITED_KEY_MAP[type]] = index\n  }\n\n  return cachedItems[index]\n}\n\nconst bs = (\n  props: Props,\n  gridCache: GridCache,\n  low: number,\n  high: number,\n  offset: number,\n  type: CacheItemType\n) => {\n  while (low <= high) {\n    const mid = low + floor((high - low) / 2)\n    const currentOffset = getItemFromCache(props, mid, gridCache, type).offset\n\n    if (currentOffset === offset) {\n      return mid\n    } else if (currentOffset < offset) {\n      low = mid + 1\n    } else {\n      high = mid - 1\n    }\n  }\n\n  return max(0, low - 1)\n}\n\nconst es = (\n  props: Props,\n  gridCache: GridCache,\n  idx: number,\n  offset: number,\n  type: CacheItemType\n) => {\n  const total = type === 'column' ? props.totalColumn : props.totalRow\n  let exponent = 1\n\n  while (\n    idx < total &&\n    getItemFromCache(props, idx, gridCache, type).offset < offset\n  ) {\n    idx += exponent\n    exponent *= 2\n  }\n\n  return bs(props, gridCache, floor(idx / 2), min(idx, total - 1), offset, type)\n}\n\nconst findItem = (\n  props: Props,\n  gridCache: GridCache,\n  offset: number,\n  type: CacheItemType\n) => {\n  const [cache, lastVisitedIndex] = [\n    gridCache[type],\n    gridCache[ACCESS_LAST_VISITED_KEY_MAP[type]],\n  ] as [Record<string, ListItem>, number]\n\n  const lastVisitedItemOffset =\n    lastVisitedIndex > 0 ? cache[lastVisitedIndex].offset : 0\n\n  if (lastVisitedItemOffset >= offset) {\n    return bs(props, gridCache, 0, lastVisitedIndex, offset, type)\n  }\n\n  return es(props, gridCache, max(0, lastVisitedIndex), offset, type)\n}\n\nconst getEstimatedTotalHeight = (\n  { totalRow }: Props,\n  { estimatedRowHeight, lastVisitedRowIndex, row }: GridCache\n) => {\n  let sizeOfVisitedRows = 0\n\n  if (lastVisitedRowIndex >= totalRow) {\n    lastVisitedRowIndex = totalRow - 1\n  }\n\n  if (lastVisitedRowIndex >= 0) {\n    const item = row[lastVisitedRowIndex]\n    sizeOfVisitedRows = item.offset + item.size\n  }\n\n  const unvisitedItems = totalRow - lastVisitedRowIndex - 1\n  const sizeOfUnvisitedItems = unvisitedItems * estimatedRowHeight\n\n  return sizeOfVisitedRows + sizeOfUnvisitedItems\n}\nconst getEstimatedTotalWidth = (\n  { totalColumn }: Props,\n  { column, estimatedColumnWidth, lastVisitedColumnIndex }: GridCache\n) => {\n  let sizeOfVisitedColumns = 0\n\n  if (lastVisitedColumnIndex > totalColumn) {\n    lastVisitedColumnIndex = totalColumn - 1\n  }\n\n  if (lastVisitedColumnIndex >= 0) {\n    const item = column[lastVisitedColumnIndex]\n    sizeOfVisitedColumns = item.offset + item.size\n  }\n\n  const unvisitedItems = totalColumn - lastVisitedColumnIndex - 1\n  const sizeOfUnvisitedItems = unvisitedItems * estimatedColumnWidth\n\n  return sizeOfVisitedColumns + sizeOfUnvisitedItems\n}\n\nconst ACCESS_ESTIMATED_SIZE_KEY_MAP = {\n  column: getEstimatedTotalWidth,\n  row: getEstimatedTotalHeight,\n}\n\nconst getOffset = (\n  props: Props,\n  index: number,\n  alignment: Alignment,\n  scrollOffset: number,\n  cache: GridCache,\n  type: CacheItemType,\n  scrollBarWidth: number\n) => {\n  const [size, estimatedSizeAssociates] = [\n    type === 'row' ? props.height : props.width,\n    ACCESS_ESTIMATED_SIZE_KEY_MAP[type],\n  ] as [number, (props: Props, cache: GridCache) => number]\n  const item = getItemFromCache(props, index, cache, type)\n\n  const estimatedSize = estimatedSizeAssociates(props, cache)\n\n  const maxOffset = max(0, min(estimatedSize - size, item.offset))\n  const minOffset = max(0, item.offset - size + scrollBarWidth + item.size)\n\n  if (alignment === SMART_ALIGNMENT) {\n    if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\n      alignment = AUTO_ALIGNMENT\n    } else {\n      alignment = CENTERED_ALIGNMENT\n    }\n  }\n\n  switch (alignment) {\n    case START_ALIGNMENT: {\n      return maxOffset\n    }\n    case END_ALIGNMENT: {\n      return minOffset\n    }\n    case CENTERED_ALIGNMENT: {\n      return Math.round(minOffset + (maxOffset - minOffset) / 2)\n    }\n    case AUTO_ALIGNMENT:\n    default: {\n      if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n        return scrollOffset\n      } else if (minOffset > maxOffset) {\n        return minOffset\n      } else if (scrollOffset < minOffset) {\n        return minOffset\n      } else {\n        return maxOffset\n      }\n    }\n  }\n}\n\nconst FixedSizeGrid = createGrid({\n  name: 'ElDynamicSizeGrid',\n  getColumnPosition: (props, idx, cache) => {\n    const item = getItemFromCache(props, idx, cache, 'column')\n    return [item.size, item.offset]\n  },\n\n  getRowPosition: (props, idx, cache) => {\n    const item = getItemFromCache(props, idx, cache, 'row')\n    return [item.size, item.offset]\n  },\n\n  getColumnOffset: (\n    props,\n    columnIndex,\n    alignment,\n    scrollLeft,\n    cache,\n    scrollBarWidth\n  ) =>\n    getOffset(\n      props,\n      columnIndex,\n      alignment,\n      scrollLeft,\n      cache,\n      'column',\n      scrollBarWidth\n    ),\n\n  getRowOffset: (\n    props,\n    rowIndex,\n    alignment,\n    scrollTop,\n    cache,\n    scrollBarWidth: number\n  ) =>\n    getOffset(\n      props,\n      rowIndex,\n      alignment,\n      scrollTop,\n      cache,\n      'row',\n      scrollBarWidth\n    ),\n\n  getColumnStartIndexForOffset: (props, scrollLeft, cache) =>\n    findItem(props, cache, scrollLeft, 'column'),\n\n  getColumnStopIndexForStartIndex: (props, startIndex, scrollLeft, cache) => {\n    const item = getItemFromCache(props, startIndex, cache, 'column')\n\n    const maxOffset = scrollLeft + (props.width as number)\n\n    let offset = item.offset + item.size\n    let stopIndex = startIndex\n    while (stopIndex < props.totalColumn - 1 && offset < maxOffset) {\n      stopIndex++\n      offset += getItemFromCache(props, startIndex, cache, 'column').size\n    }\n    return stopIndex\n  },\n\n  getEstimatedTotalHeight,\n  getEstimatedTotalWidth,\n\n  getRowStartIndexForOffset: (props, scrollTop, cache) =>\n    findItem(props, cache, scrollTop, 'row'),\n\n  getRowStopIndexForStartIndex: (props, startIndex, scrollTop, cache) => {\n    const { totalRow, height } = props\n    const item = getItemFromCache(props, startIndex, cache, 'row')\n    const maxOffset = scrollTop + (height as number)\n\n    let offset = item.size + item.offset\n    let stopIndex = startIndex\n\n    while (stopIndex < totalRow - 1 && offset < maxOffset) {\n      stopIndex++\n      offset += getItemFromCache(props, stopIndex, cache, 'row').size\n    }\n\n    return stopIndex\n  },\n\n  initCache: ({\n    estimatedColumnWidth = DEFAULT_DYNAMIC_LIST_ITEM_SIZE,\n    estimatedRowHeight = DEFAULT_DYNAMIC_LIST_ITEM_SIZE,\n  }) => {\n    const cache = {\n      column: {},\n      estimatedColumnWidth,\n      estimatedRowHeight,\n      lastVisitedColumnIndex: -1,\n      lastVisitedRowIndex: -1,\n      row: {},\n    } as GridCache\n\n    // TODO: expose methods.\n    return cache\n  },\n\n  clearCache: true,\n\n  validateProps: ({ columnWidth, rowHeight }) => {\n    if (process.env.NODE_ENV !== 'production') {\n      if (!isFunction(columnWidth)) {\n        throwError(\n          SCOPE,\n          `\n          \"columnWidth\" must be passed as function,\n            instead ${typeof columnWidth} was given.\n        `\n        )\n      }\n\n      if (!isFunction(rowHeight)) {\n        throwError(\n          SCOPE,\n          `\n          \"columnWidth\" must be passed as function,\n            instead ${typeof rowHeight} was given.\n        `\n        )\n      }\n    }\n  },\n})\n\nexport default FixedSizeGrid\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}