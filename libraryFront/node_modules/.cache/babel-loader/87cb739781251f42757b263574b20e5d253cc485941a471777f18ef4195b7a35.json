{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { reactive } from 'vue';\nimport { hasOwn } from '@vue/shared';\nimport { markNodeData, NODE_KEY } from './util.mjs';\nconst getChildState = node => {\n  let all = true;\n  let none = true;\n  let allWithoutDisable = true;\n  for (let i = 0, j = node.length; i < j; i++) {\n    const n = node[i];\n    if (n.checked !== true || n.indeterminate) {\n      all = false;\n      if (!n.disabled) {\n        allWithoutDisable = false;\n      }\n    }\n    if (n.checked !== false || n.indeterminate) {\n      none = false;\n    }\n  }\n  return {\n    all,\n    none,\n    allWithoutDisable,\n    half: !all && !none\n  };\n};\nconst reInitChecked = function (node) {\n  if (node.childNodes.length === 0) return;\n  const {\n    all,\n    none,\n    half\n  } = getChildState(node.childNodes);\n  if (all) {\n    node.checked = true;\n    node.indeterminate = false;\n  } else if (half) {\n    node.checked = false;\n    node.indeterminate = true;\n  } else if (none) {\n    node.checked = false;\n    node.indeterminate = false;\n  }\n  const parent = node.parent;\n  if (!parent || parent.level === 0) return;\n  if (!node.store.checkStrictly) {\n    reInitChecked(parent);\n  }\n};\nconst getPropertyFromData = function (node, prop) {\n  const props = node.store.props;\n  const data = node.data || {};\n  const config = props[prop];\n  if (typeof config === \"function\") {\n    return config(data, node);\n  } else if (typeof config === \"string\") {\n    return data[config];\n  } else if (typeof config === \"undefined\") {\n    const dataProp = data[prop];\n    return dataProp === void 0 ? \"\" : dataProp;\n  }\n};\nlet nodeIdSeed = 0;\nclass Node {\n  constructor(options) {\n    this.id = nodeIdSeed++;\n    this.text = null;\n    this.checked = false;\n    this.indeterminate = false;\n    this.data = null;\n    this.expanded = false;\n    this.parent = null;\n    this.visible = true;\n    this.isCurrent = false;\n    this.canFocus = false;\n    for (const name in options) {\n      if (hasOwn(options, name)) {\n        this[name] = options[name];\n      }\n    }\n    this.level = 0;\n    this.loaded = false;\n    this.childNodes = [];\n    this.loading = false;\n    if (this.parent) {\n      this.level = this.parent.level + 1;\n    }\n  }\n  initialize() {\n    const store = this.store;\n    if (!store) {\n      throw new Error(\"[Node]store is required!\");\n    }\n    store.registerNode(this);\n    const props = store.props;\n    if (props && typeof props.isLeaf !== \"undefined\") {\n      const isLeaf = getPropertyFromData(this, \"isLeaf\");\n      if (typeof isLeaf === \"boolean\") {\n        this.isLeafByUser = isLeaf;\n      }\n    }\n    if (store.lazy !== true && this.data) {\n      this.setData(this.data);\n      if (store.defaultExpandAll) {\n        this.expanded = true;\n        this.canFocus = true;\n      }\n    } else if (this.level > 0 && store.lazy && store.defaultExpandAll) {\n      this.expand();\n    }\n    if (!Array.isArray(this.data)) {\n      markNodeData(this, this.data);\n    }\n    if (!this.data) return;\n    const defaultExpandedKeys = store.defaultExpandedKeys;\n    const key = store.key;\n    if (key && defaultExpandedKeys && defaultExpandedKeys.indexOf(this.key) !== -1) {\n      this.expand(null, store.autoExpandParent);\n    }\n    if (key && store.currentNodeKey !== void 0 && this.key === store.currentNodeKey) {\n      store.currentNode = this;\n      store.currentNode.isCurrent = true;\n    }\n    if (store.lazy) {\n      store._initDefaultCheckedNode(this);\n    }\n    this.updateLeafState();\n    if (this.parent && (this.level === 1 || this.parent.expanded === true)) this.canFocus = true;\n  }\n  setData(data) {\n    if (!Array.isArray(data)) {\n      markNodeData(this, data);\n    }\n    this.data = data;\n    this.childNodes = [];\n    let children;\n    if (this.level === 0 && this.data instanceof Array) {\n      children = this.data;\n    } else {\n      children = getPropertyFromData(this, \"children\") || [];\n    }\n    for (let i = 0, j = children.length; i < j; i++) {\n      this.insertChild({\n        data: children[i]\n      });\n    }\n  }\n  get label() {\n    return getPropertyFromData(this, \"label\");\n  }\n  get key() {\n    const nodeKey = this.store.key;\n    if (this.data) return this.data[nodeKey];\n    return null;\n  }\n  get disabled() {\n    return getPropertyFromData(this, \"disabled\");\n  }\n  get nextSibling() {\n    const parent = this.parent;\n    if (parent) {\n      const index = parent.childNodes.indexOf(this);\n      if (index > -1) {\n        return parent.childNodes[index + 1];\n      }\n    }\n    return null;\n  }\n  get previousSibling() {\n    const parent = this.parent;\n    if (parent) {\n      const index = parent.childNodes.indexOf(this);\n      if (index > -1) {\n        return index > 0 ? parent.childNodes[index - 1] : null;\n      }\n    }\n    return null;\n  }\n  contains(target, deep = true) {\n    return (this.childNodes || []).some(child => child === target || deep && child.contains(target));\n  }\n  remove() {\n    const parent = this.parent;\n    if (parent) {\n      parent.removeChild(this);\n    }\n  }\n  insertChild(child, index, batch) {\n    if (!child) throw new Error(\"InsertChild error: child is required.\");\n    if (!(child instanceof Node)) {\n      if (!batch) {\n        const children = this.getChildren(true);\n        if (children.indexOf(child.data) === -1) {\n          if (typeof index === \"undefined\" || index < 0) {\n            children.push(child.data);\n          } else {\n            children.splice(index, 0, child.data);\n          }\n        }\n      }\n      Object.assign(child, {\n        parent: this,\n        store: this.store\n      });\n      child = reactive(new Node(child));\n      if (child instanceof Node) {\n        child.initialize();\n      }\n    }\n    ;\n    child.level = this.level + 1;\n    if (typeof index === \"undefined\" || index < 0) {\n      this.childNodes.push(child);\n    } else {\n      this.childNodes.splice(index, 0, child);\n    }\n    this.updateLeafState();\n  }\n  insertBefore(child, ref) {\n    let index;\n    if (ref) {\n      index = this.childNodes.indexOf(ref);\n    }\n    this.insertChild(child, index);\n  }\n  insertAfter(child, ref) {\n    let index;\n    if (ref) {\n      index = this.childNodes.indexOf(ref);\n      if (index !== -1) index += 1;\n    }\n    this.insertChild(child, index);\n  }\n  removeChild(child) {\n    const children = this.getChildren() || [];\n    const dataIndex = children.indexOf(child.data);\n    if (dataIndex > -1) {\n      children.splice(dataIndex, 1);\n    }\n    const index = this.childNodes.indexOf(child);\n    if (index > -1) {\n      this.store && this.store.deregisterNode(child);\n      child.parent = null;\n      this.childNodes.splice(index, 1);\n    }\n    this.updateLeafState();\n  }\n  removeChildByData(data) {\n    let targetNode = null;\n    for (let i = 0; i < this.childNodes.length; i++) {\n      if (this.childNodes[i].data === data) {\n        targetNode = this.childNodes[i];\n        break;\n      }\n    }\n    if (targetNode) {\n      this.removeChild(targetNode);\n    }\n  }\n  expand(callback, expandParent) {\n    const done = () => {\n      if (expandParent) {\n        let parent = this.parent;\n        while (parent.level > 0) {\n          parent.expanded = true;\n          parent = parent.parent;\n        }\n      }\n      this.expanded = true;\n      if (callback) callback();\n      this.childNodes.forEach(item => {\n        item.canFocus = true;\n      });\n    };\n    if (this.shouldLoadData()) {\n      this.loadData(data => {\n        if (Array.isArray(data)) {\n          if (this.checked) {\n            this.setChecked(true, true);\n          } else if (!this.store.checkStrictly) {\n            reInitChecked(this);\n          }\n          done();\n        }\n      });\n    } else {\n      done();\n    }\n  }\n  doCreateChildren(array, defaultProps = {}) {\n    array.forEach(item => {\n      this.insertChild(Object.assign({\n        data: item\n      }, defaultProps), void 0, true);\n    });\n  }\n  collapse() {\n    this.expanded = false;\n    this.childNodes.forEach(item => {\n      item.canFocus = false;\n    });\n  }\n  shouldLoadData() {\n    return this.store.lazy === true && this.store.load && !this.loaded;\n  }\n  updateLeafState() {\n    if (this.store.lazy === true && this.loaded !== true && typeof this.isLeafByUser !== \"undefined\") {\n      this.isLeaf = this.isLeafByUser;\n      return;\n    }\n    const childNodes = this.childNodes;\n    if (!this.store.lazy || this.store.lazy === true && this.loaded === true) {\n      this.isLeaf = !childNodes || childNodes.length === 0;\n      return;\n    }\n    this.isLeaf = false;\n  }\n  setChecked(value, deep, recursion, passValue) {\n    this.indeterminate = value === \"half\";\n    this.checked = value === true;\n    if (this.store.checkStrictly) return;\n    if (!(this.shouldLoadData() && !this.store.checkDescendants)) {\n      const {\n        all,\n        allWithoutDisable\n      } = getChildState(this.childNodes);\n      if (!this.isLeaf && !all && allWithoutDisable) {\n        this.checked = false;\n        value = false;\n      }\n      const handleDescendants = () => {\n        if (deep) {\n          const childNodes = this.childNodes;\n          for (let i = 0, j = childNodes.length; i < j; i++) {\n            const child = childNodes[i];\n            passValue = passValue || value !== false;\n            const isCheck = child.disabled ? child.checked : passValue;\n            child.setChecked(isCheck, deep, true, passValue);\n          }\n          const {\n            half,\n            all: all2\n          } = getChildState(childNodes);\n          if (!all2) {\n            this.checked = all2;\n            this.indeterminate = half;\n          }\n        }\n      };\n      if (this.shouldLoadData()) {\n        this.loadData(() => {\n          handleDescendants();\n          reInitChecked(this);\n        }, {\n          checked: value !== false\n        });\n        return;\n      } else {\n        handleDescendants();\n      }\n    }\n    const parent = this.parent;\n    if (!parent || parent.level === 0) return;\n    if (!recursion) {\n      reInitChecked(parent);\n    }\n  }\n  getChildren(forceInit = false) {\n    if (this.level === 0) return this.data;\n    const data = this.data;\n    if (!data) return null;\n    const props = this.store.props;\n    let children = \"children\";\n    if (props) {\n      children = props.children || \"children\";\n    }\n    if (data[children] === void 0) {\n      data[children] = null;\n    }\n    if (forceInit && !data[children]) {\n      data[children] = [];\n    }\n    return data[children];\n  }\n  updateChildren() {\n    const newData = this.getChildren() || [];\n    const oldData = this.childNodes.map(node => node.data);\n    const newDataMap = {};\n    const newNodes = [];\n    newData.forEach((item, index) => {\n      const key = item[NODE_KEY];\n      const isNodeExists = !!key && oldData.findIndex(data => data[NODE_KEY] === key) >= 0;\n      if (isNodeExists) {\n        newDataMap[key] = {\n          index,\n          data: item\n        };\n      } else {\n        newNodes.push({\n          index,\n          data: item\n        });\n      }\n    });\n    if (!this.store.lazy) {\n      oldData.forEach(item => {\n        if (!newDataMap[item[NODE_KEY]]) this.removeChildByData(item);\n      });\n    }\n    newNodes.forEach(({\n      index,\n      data\n    }) => {\n      this.insertChild({\n        data\n      }, index);\n    });\n    this.updateLeafState();\n  }\n  loadData(callback, defaultProps = {}) {\n    if (this.store.lazy === true && this.store.load && !this.loaded && (!this.loading || Object.keys(defaultProps).length)) {\n      this.loading = true;\n      const resolve = children => {\n        this.loaded = true;\n        this.loading = false;\n        this.childNodes = [];\n        this.doCreateChildren(children, defaultProps);\n        this.updateLeafState();\n        if (callback) {\n          callback.call(this, children);\n        }\n      };\n      this.store.load(this, resolve);\n    } else {\n      if (callback) {\n        callback.call(this);\n      }\n    }\n  }\n}\nexport { Node as default, getChildState };","map":{"version":3,"names":["getChildState","node","all","none","allWithoutDisable","i","j","length","n","checked","indeterminate","disabled","half","reInitChecked","childNodes","parent","level","store","checkStrictly","getPropertyFromData","prop","props","data","config","dataProp","nodeIdSeed","Node","constructor","options","id","text","expanded","visible","isCurrent","canFocus","name","hasOwn","loaded","loading","initialize","Error","registerNode","isLeaf","isLeafByUser","lazy","setData","defaultExpandAll","expand","Array","isArray","markNodeData","defaultExpandedKeys","key","indexOf","autoExpandParent","currentNodeKey","currentNode","_initDefaultCheckedNode","updateLeafState","children","insertChild","label","nodeKey","nextSibling","index","previousSibling","contains","target","deep","some","child","remove","removeChild","batch","getChildren","push","splice","Object","assign","reactive","insertBefore","ref","insertAfter","dataIndex","deregisterNode","removeChildByData","targetNode","callback","expandParent","done","forEach","item","shouldLoadData","loadData","setChecked","doCreateChildren","array","defaultProps","collapse","load","value","recursion","passValue","checkDescendants","handleDescendants","isCheck","all2","forceInit","updateChildren","newData","oldData","map","newDataMap","newNodes","NODE_KEY","isNodeExists","findIndex","keys","resolve","call"],"sources":["../../../../../../../packages/components/tree/src/model/node.ts"],"sourcesContent":["import { reactive } from 'vue'\nimport { hasOwn } from '@vue/shared'\nimport { markNodeData, NODE_KEY } from './util'\nimport type TreeStore from './tree-store'\n\nimport type { Nullable } from '@element-plus/utils/types'\nimport type {\n  TreeNodeOptions,\n  TreeNodeData,\n  TreeKey,\n  FakeNode,\n  TreeNodeLoadedDefaultProps,\n  TreeNodeChildState,\n} from '../tree.type'\n\nexport const getChildState = (node: Node[]): TreeNodeChildState => {\n  let all = true\n  let none = true\n  let allWithoutDisable = true\n  for (let i = 0, j = node.length; i < j; i++) {\n    const n = node[i]\n    if (n.checked !== true || n.indeterminate) {\n      all = false\n      if (!n.disabled) {\n        allWithoutDisable = false\n      }\n    }\n    if (n.checked !== false || n.indeterminate) {\n      none = false\n    }\n  }\n\n  return { all, none, allWithoutDisable, half: !all && !none }\n}\n\nconst reInitChecked = function (node: Node): void {\n  if (node.childNodes.length === 0) return\n\n  const { all, none, half } = getChildState(node.childNodes)\n  if (all) {\n    node.checked = true\n    node.indeterminate = false\n  } else if (half) {\n    node.checked = false\n    node.indeterminate = true\n  } else if (none) {\n    node.checked = false\n    node.indeterminate = false\n  }\n\n  const parent = node.parent\n  if (!parent || parent.level === 0) return\n\n  if (!node.store.checkStrictly) {\n    reInitChecked(parent)\n  }\n}\n\nconst getPropertyFromData = function (node: Node, prop: string): any {\n  const props = node.store.props\n  const data = node.data || {}\n  const config = props[prop]\n\n  if (typeof config === 'function') {\n    return config(data, node)\n  } else if (typeof config === 'string') {\n    return data[config]\n  } else if (typeof config === 'undefined') {\n    const dataProp = data[prop]\n    return dataProp === undefined ? '' : dataProp\n  }\n}\n\nlet nodeIdSeed = 0\n\nclass Node {\n  id: number\n  text: string\n  checked: boolean\n  indeterminate: boolean\n  data: TreeNodeData\n  expanded: boolean\n  parent: Node\n  visible: boolean\n  isCurrent: boolean\n  store: TreeStore\n  isLeafByUser: boolean\n  isLeaf: boolean\n  canFocus: boolean\n\n  level: number\n  loaded: boolean\n  childNodes: Node[]\n  loading: boolean\n\n  constructor(options: TreeNodeOptions) {\n    this.id = nodeIdSeed++\n    this.text = null\n    this.checked = false\n    this.indeterminate = false\n    this.data = null\n    this.expanded = false\n    this.parent = null\n    this.visible = true\n    this.isCurrent = false\n    this.canFocus = false\n\n    for (const name in options) {\n      if (hasOwn(options, name)) {\n        this[name] = options[name]\n      }\n    }\n\n    // internal\n    this.level = 0\n    this.loaded = false\n    this.childNodes = []\n    this.loading = false\n\n    if (this.parent) {\n      this.level = this.parent.level + 1\n    }\n  }\n\n  initialize() {\n    const store = this.store\n    if (!store) {\n      throw new Error('[Node]store is required!')\n    }\n    store.registerNode(this)\n\n    const props = store.props\n    if (props && typeof props.isLeaf !== 'undefined') {\n      const isLeaf = getPropertyFromData(this, 'isLeaf')\n      if (typeof isLeaf === 'boolean') {\n        this.isLeafByUser = isLeaf\n      }\n    }\n\n    if (store.lazy !== true && this.data) {\n      this.setData(this.data)\n\n      if (store.defaultExpandAll) {\n        this.expanded = true\n        this.canFocus = true\n      }\n    } else if (this.level > 0 && store.lazy && store.defaultExpandAll) {\n      this.expand()\n    }\n    if (!Array.isArray(this.data)) {\n      markNodeData(this, this.data)\n    }\n    if (!this.data) return\n\n    const defaultExpandedKeys = store.defaultExpandedKeys\n    const key = store.key\n\n    if (\n      key &&\n      defaultExpandedKeys &&\n      defaultExpandedKeys.indexOf(this.key) !== -1\n    ) {\n      this.expand(null, store.autoExpandParent)\n    }\n\n    if (\n      key &&\n      store.currentNodeKey !== undefined &&\n      this.key === store.currentNodeKey\n    ) {\n      store.currentNode = this\n      store.currentNode.isCurrent = true\n    }\n\n    if (store.lazy) {\n      store._initDefaultCheckedNode(this)\n    }\n\n    this.updateLeafState()\n    if (this.parent && (this.level === 1 || this.parent.expanded === true))\n      this.canFocus = true\n  }\n\n  setData(data: TreeNodeData): void {\n    if (!Array.isArray(data)) {\n      markNodeData(this, data)\n    }\n\n    this.data = data\n    this.childNodes = []\n\n    let children\n    if (this.level === 0 && this.data instanceof Array) {\n      children = this.data\n    } else {\n      children = getPropertyFromData(this, 'children') || []\n    }\n\n    for (let i = 0, j = children.length; i < j; i++) {\n      this.insertChild({ data: children[i] })\n    }\n  }\n\n  get label(): string {\n    return getPropertyFromData(this, 'label')\n  }\n\n  get key(): TreeKey {\n    const nodeKey = this.store.key\n    if (this.data) return this.data[nodeKey]\n    return null\n  }\n\n  get disabled(): boolean {\n    return getPropertyFromData(this, 'disabled')\n  }\n\n  get nextSibling(): Nullable<Node> {\n    const parent = this.parent\n    if (parent) {\n      const index = parent.childNodes.indexOf(this)\n      if (index > -1) {\n        return parent.childNodes[index + 1]\n      }\n    }\n    return null\n  }\n\n  get previousSibling(): Nullable<Node> {\n    const parent = this.parent\n    if (parent) {\n      const index = parent.childNodes.indexOf(this)\n      if (index > -1) {\n        return index > 0 ? parent.childNodes[index - 1] : null\n      }\n    }\n    return null\n  }\n\n  contains(target: Node, deep = true): boolean {\n    return (this.childNodes || []).some(\n      (child) => child === target || (deep && child.contains(target))\n    )\n  }\n\n  remove(): void {\n    const parent = this.parent\n    if (parent) {\n      parent.removeChild(this)\n    }\n  }\n\n  insertChild(child?: FakeNode | Node, index?: number, batch?: boolean): void {\n    if (!child) throw new Error('InsertChild error: child is required.')\n\n    if (!(child instanceof Node)) {\n      if (!batch) {\n        const children = this.getChildren(true)\n        if (children.indexOf(child.data) === -1) {\n          if (typeof index === 'undefined' || index < 0) {\n            children.push(child.data)\n          } else {\n            children.splice(index, 0, child.data)\n          }\n        }\n      }\n      Object.assign(child, {\n        parent: this,\n        store: this.store,\n      })\n      child = reactive(new Node(child as TreeNodeOptions))\n      if (child instanceof Node) {\n        child.initialize()\n      }\n    }\n\n    ;(child as Node).level = this.level + 1\n\n    if (typeof index === 'undefined' || index < 0) {\n      this.childNodes.push(child as Node)\n    } else {\n      this.childNodes.splice(index, 0, child as Node)\n    }\n\n    this.updateLeafState()\n  }\n\n  insertBefore(child: FakeNode | Node, ref: Node): void {\n    let index\n    if (ref) {\n      index = this.childNodes.indexOf(ref)\n    }\n    this.insertChild(child, index)\n  }\n\n  insertAfter(child: FakeNode | Node, ref: Node): void {\n    let index\n    if (ref) {\n      index = this.childNodes.indexOf(ref)\n      if (index !== -1) index += 1\n    }\n    this.insertChild(child, index)\n  }\n\n  removeChild(child: Node): void {\n    const children = this.getChildren() || []\n    const dataIndex = children.indexOf(child.data)\n    if (dataIndex > -1) {\n      children.splice(dataIndex, 1)\n    }\n\n    const index = this.childNodes.indexOf(child)\n\n    if (index > -1) {\n      this.store && this.store.deregisterNode(child)\n      child.parent = null\n      this.childNodes.splice(index, 1)\n    }\n\n    this.updateLeafState()\n  }\n\n  removeChildByData(data: TreeNodeData): void {\n    let targetNode: Node = null\n\n    for (let i = 0; i < this.childNodes.length; i++) {\n      if (this.childNodes[i].data === data) {\n        targetNode = this.childNodes[i]\n        break\n      }\n    }\n\n    if (targetNode) {\n      this.removeChild(targetNode)\n    }\n  }\n\n  expand(callback?: () => void, expandParent?: boolean): void {\n    const done = (): void => {\n      if (expandParent) {\n        let parent = this.parent\n        while (parent.level > 0) {\n          parent.expanded = true\n          parent = parent.parent\n        }\n      }\n      this.expanded = true\n      if (callback) callback()\n      this.childNodes.forEach((item) => {\n        item.canFocus = true\n      })\n    }\n\n    if (this.shouldLoadData()) {\n      this.loadData((data) => {\n        if (Array.isArray(data)) {\n          if (this.checked) {\n            this.setChecked(true, true)\n          } else if (!this.store.checkStrictly) {\n            reInitChecked(this)\n          }\n          done()\n        }\n      })\n    } else {\n      done()\n    }\n  }\n\n  doCreateChildren(\n    array: TreeNodeData[],\n    defaultProps: TreeNodeLoadedDefaultProps = {}\n  ): void {\n    array.forEach((item) => {\n      this.insertChild(\n        Object.assign({ data: item }, defaultProps),\n        undefined,\n        true\n      )\n    })\n  }\n\n  collapse(): void {\n    this.expanded = false\n    this.childNodes.forEach((item) => {\n      item.canFocus = false\n    })\n  }\n\n  shouldLoadData(): boolean {\n    return this.store.lazy === true && this.store.load && !this.loaded\n  }\n\n  updateLeafState(): void {\n    if (\n      this.store.lazy === true &&\n      this.loaded !== true &&\n      typeof this.isLeafByUser !== 'undefined'\n    ) {\n      this.isLeaf = this.isLeafByUser\n      return\n    }\n    const childNodes = this.childNodes\n    if (\n      !this.store.lazy ||\n      (this.store.lazy === true && this.loaded === true)\n    ) {\n      this.isLeaf = !childNodes || childNodes.length === 0\n      return\n    }\n    this.isLeaf = false\n  }\n\n  setChecked(\n    value?: boolean | string,\n    deep?: boolean,\n    recursion?: boolean,\n    passValue?: boolean\n  ) {\n    this.indeterminate = value === 'half'\n    this.checked = value === true\n\n    if (this.store.checkStrictly) return\n\n    if (!(this.shouldLoadData() && !this.store.checkDescendants)) {\n      const { all, allWithoutDisable } = getChildState(this.childNodes)\n\n      if (!this.isLeaf && !all && allWithoutDisable) {\n        this.checked = false\n        value = false\n      }\n\n      const handleDescendants = (): void => {\n        if (deep) {\n          const childNodes = this.childNodes\n          for (let i = 0, j = childNodes.length; i < j; i++) {\n            const child = childNodes[i]\n            passValue = passValue || value !== false\n            const isCheck = child.disabled ? child.checked : passValue\n            child.setChecked(isCheck, deep, true, passValue)\n          }\n          const { half, all } = getChildState(childNodes)\n          if (!all) {\n            this.checked = all\n            this.indeterminate = half\n          }\n        }\n      }\n\n      if (this.shouldLoadData()) {\n        // Only work on lazy load data.\n        this.loadData(\n          () => {\n            handleDescendants()\n            reInitChecked(this)\n          },\n          {\n            checked: value !== false,\n          }\n        )\n        return\n      } else {\n        handleDescendants()\n      }\n    }\n\n    const parent = this.parent\n    if (!parent || parent.level === 0) return\n\n    if (!recursion) {\n      reInitChecked(parent)\n    }\n  }\n\n  getChildren(forceInit = false): TreeNodeData | TreeNodeData[] {\n    // this is data\n    if (this.level === 0) return this.data\n    const data = this.data\n    if (!data) return null\n\n    const props = this.store.props\n    let children = 'children'\n    if (props) {\n      children = props.children || 'children'\n    }\n\n    if (data[children] === undefined) {\n      data[children] = null\n    }\n\n    if (forceInit && !data[children]) {\n      data[children] = []\n    }\n\n    return data[children]\n  }\n\n  updateChildren(): void {\n    const newData = (this.getChildren() || []) as TreeNodeData[]\n    const oldData = this.childNodes.map((node) => node.data)\n\n    const newDataMap = {}\n    const newNodes = []\n\n    newData.forEach((item, index) => {\n      const key = item[NODE_KEY]\n      const isNodeExists =\n        !!key && oldData.findIndex((data) => data[NODE_KEY] === key) >= 0\n      if (isNodeExists) {\n        newDataMap[key] = { index, data: item }\n      } else {\n        newNodes.push({ index, data: item })\n      }\n    })\n\n    if (!this.store.lazy) {\n      oldData.forEach((item) => {\n        if (!newDataMap[item[NODE_KEY]]) this.removeChildByData(item)\n      })\n    }\n\n    newNodes.forEach(({ index, data }) => {\n      this.insertChild({ data }, index)\n    })\n\n    this.updateLeafState()\n  }\n\n  loadData(\n    callback: (node: Node) => void,\n    defaultProps: TreeNodeLoadedDefaultProps = {}\n  ) {\n    if (\n      this.store.lazy === true &&\n      this.store.load &&\n      !this.loaded &&\n      (!this.loading || Object.keys(defaultProps).length)\n    ) {\n      this.loading = true\n\n      const resolve = (children) => {\n        this.loaded = true\n        this.loading = false\n        this.childNodes = []\n\n        this.doCreateChildren(children, defaultProps)\n\n        this.updateLeafState()\n        if (callback) {\n          callback.call(this, children)\n        }\n      }\n\n      this.store.load(this, resolve)\n    } else {\n      if (callback) {\n        callback.call(this)\n      }\n    }\n  }\n}\n\nexport default Node\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}