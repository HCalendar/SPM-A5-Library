{"ast":null,"code":"import { ref, reactive, computed, unref, watch } from 'vue';\nimport { createPopper } from '@popperjs/core';\nimport { generateId, isBool, isHTMLElement } from '../../../../utils/util.mjs';\nimport PopupManager from '../../../../utils/popup-manager.mjs';\nimport usePopperOptions from './popper-options.mjs';\nexport { Effect } from './defaults.mjs';\nimport { isString, isArray } from '@vue/shared';\nconst DEFAULT_TRIGGER = [\"hover\"];\nconst UPDATE_VISIBLE_EVENT = \"update:visible\";\nfunction usePopper(props, {\n  emit\n}) {\n  const arrowRef = ref(null);\n  const triggerRef = ref(null);\n  const popperRef = ref(null);\n  const popperId = `el-popper-${generateId()}`;\n  let popperInstance = null;\n  let showTimer = null;\n  let hideTimer = null;\n  let triggerFocused = false;\n  const isManualMode = () => props.manualMode || props.trigger === \"manual\";\n  const popperStyle = ref({\n    zIndex: PopupManager.nextZIndex()\n  });\n  const popperOptions = usePopperOptions(props, {\n    arrow: arrowRef\n  });\n  const state = reactive({\n    visible: !!props.visible\n  });\n  const visibility = computed({\n    get() {\n      if (props.disabled) {\n        return false;\n      } else {\n        return isBool(props.visible) ? props.visible : state.visible;\n      }\n    },\n    set(val) {\n      if (isManualMode()) return;\n      isBool(props.visible) ? emit(UPDATE_VISIBLE_EVENT, val) : state.visible = val;\n    }\n  });\n  function _show() {\n    if (props.autoClose > 0) {\n      hideTimer = window.setTimeout(() => {\n        _hide();\n      }, props.autoClose);\n    }\n    visibility.value = true;\n  }\n  function _hide() {\n    visibility.value = false;\n  }\n  function clearTimers() {\n    clearTimeout(showTimer);\n    clearTimeout(hideTimer);\n  }\n  const show = () => {\n    if (isManualMode() || props.disabled) return;\n    clearTimers();\n    if (props.showAfter === 0) {\n      _show();\n    } else {\n      showTimer = window.setTimeout(() => {\n        _show();\n      }, props.showAfter);\n    }\n  };\n  const hide = () => {\n    if (isManualMode()) return;\n    clearTimers();\n    if (props.hideAfter > 0) {\n      hideTimer = window.setTimeout(() => {\n        close();\n      }, props.hideAfter);\n    } else {\n      close();\n    }\n  };\n  const close = () => {\n    _hide();\n    if (props.disabled) {\n      doDestroy(true);\n    }\n  };\n  function onPopperMouseEnter() {\n    if (props.enterable && props.trigger !== \"click\") {\n      clearTimeout(hideTimer);\n    }\n  }\n  function onPopperMouseLeave() {\n    const {\n      trigger\n    } = props;\n    const shouldPrevent = isString(trigger) && (trigger === \"click\" || trigger === \"focus\") || trigger.length === 1 && (trigger[0] === \"click\" || trigger[0] === \"focus\");\n    if (shouldPrevent) return;\n    hide();\n  }\n  function initializePopper() {\n    if (!unref(visibility)) {\n      return;\n    }\n    const unwrappedTrigger = unref(triggerRef);\n    const _trigger = isHTMLElement(unwrappedTrigger) ? unwrappedTrigger : unwrappedTrigger.$el;\n    popperInstance = createPopper(_trigger, unref(popperRef), unref(popperOptions));\n    popperInstance.update();\n  }\n  function doDestroy(forceDestroy) {\n    if (!popperInstance || unref(visibility) && !forceDestroy) return;\n    detachPopper();\n  }\n  function detachPopper() {\n    var _a;\n    (_a = popperInstance == null ? void 0 : popperInstance.destroy) == null ? void 0 : _a.call(popperInstance);\n    popperInstance = null;\n  }\n  const events = {};\n  function update() {\n    if (!unref(visibility)) {\n      return;\n    }\n    if (popperInstance) {\n      popperInstance.update();\n    } else {\n      initializePopper();\n    }\n  }\n  function onVisibilityChange(toState) {\n    if (toState) {\n      popperStyle.value.zIndex = PopupManager.nextZIndex();\n      initializePopper();\n    }\n  }\n  if (!isManualMode()) {\n    const toggleState = () => {\n      if (unref(visibility)) {\n        hide();\n      } else {\n        show();\n      }\n    };\n    const popperEventsHandler = e => {\n      e.stopPropagation();\n      switch (e.type) {\n        case \"click\":\n          {\n            if (triggerFocused) {\n              triggerFocused = false;\n            } else {\n              toggleState();\n            }\n            break;\n          }\n        case \"mouseenter\":\n          {\n            show();\n            break;\n          }\n        case \"mouseleave\":\n          {\n            hide();\n            break;\n          }\n        case \"focus\":\n          {\n            triggerFocused = true;\n            show();\n            break;\n          }\n        case \"blur\":\n          {\n            triggerFocused = false;\n            hide();\n            break;\n          }\n      }\n    };\n    const triggerEventsMap = {\n      click: [\"onClick\"],\n      hover: [\"onMouseenter\", \"onMouseleave\"],\n      focus: [\"onFocus\", \"onBlur\"]\n    };\n    const mapEvents = t => {\n      triggerEventsMap[t].forEach(event => {\n        events[event] = popperEventsHandler;\n      });\n    };\n    if (isArray(props.trigger)) {\n      Object.values(props.trigger).forEach(mapEvents);\n    } else {\n      mapEvents(props.trigger);\n    }\n  }\n  watch(popperOptions, val => {\n    if (!popperInstance) return;\n    popperInstance.setOptions(val);\n    popperInstance.update();\n  });\n  watch(visibility, onVisibilityChange);\n  return {\n    update,\n    doDestroy,\n    show,\n    hide,\n    onPopperMouseEnter,\n    onPopperMouseLeave,\n    onAfterEnter: () => {\n      emit(\"after-enter\");\n    },\n    onAfterLeave: () => {\n      detachPopper();\n      emit(\"after-leave\");\n    },\n    onBeforeEnter: () => {\n      emit(\"before-enter\");\n    },\n    onBeforeLeave: () => {\n      emit(\"before-leave\");\n    },\n    initializePopper,\n    isManualMode,\n    arrowRef,\n    events,\n    popperId,\n    popperInstance,\n    popperRef,\n    popperStyle,\n    triggerRef,\n    visibility\n  };\n}\nexport { DEFAULT_TRIGGER, UPDATE_VISIBLE_EVENT, usePopper as default };","map":{"version":3,"names":["DEFAULT_TRIGGER","UPDATE_VISIBLE_EVENT","props","emit","arrowRef","ref","triggerRef","popperRef","popperId","generateId","popperInstance","showTimer","hideTimer","triggerFocused","isManualMode","manualMode","trigger","popperStyle","zIndex","PopupManager","nextZIndex","popperOptions","usePopperOptions","arrow","state","reactive","visible","visibility","computed","get","disabled","isBool","set","val","_show","autoClose","window","setTimeout","_hide","value","clearTimers","clearTimeout","show","showAfter","hide","hideAfter","close","doDestroy","onPopperMouseEnter","enterable","onPopperMouseLeave","shouldPrevent","isString","length","initializePopper","unref","unwrappedTrigger","_trigger","isHTMLElement","$el","createPopper","update","forceDestroy","detachPopper","_a","destroy","call","events","onVisibilityChange","toState","toggleState","popperEventsHandler","e","stopPropagation","type","triggerEventsMap","click","hover","focus","mapEvents","t","forEach","event","isArray","Object","values","watch","setOptions","onAfterEnter","onAfterLeave","onBeforeEnter","onBeforeLeave"],"sources":["../../../../../../../packages/components/popper/src/use-popper/index.ts"],"sourcesContent":["import { computed, ref, reactive, watch, unref } from 'vue'\nimport { createPopper } from '@popperjs/core'\nimport {\n  generateId,\n  isBool,\n  isHTMLElement,\n  isArray,\n  isString,\n} from '@element-plus/utils/util'\nimport PopupManager from '@element-plus/utils/popup-manager'\nimport usePopperOptions from './popper-options'\n\nimport type {\n  ComponentPublicInstance,\n  CSSProperties,\n  SetupContext,\n  Ref,\n} from 'vue'\nimport type { TimeoutHandle, Nullable } from '@element-plus/utils/types'\nimport type {\n  IPopperOptions,\n  TriggerType,\n  PopperInstance,\n  RefElement,\n} from './defaults'\n\nexport type ElementType = ComponentPublicInstance | HTMLElement\nexport type EmitType =\n  | 'update:visible'\n  | 'after-enter'\n  | 'after-leave'\n  | 'before-enter'\n  | 'before-leave'\n\nexport interface PopperEvents {\n  onClick?: (e: Event) => void\n  onMouseenter?: (e: Event) => void\n  onMouseleave?: (e: Event) => void\n  onFocus?: (e: Event) => void\n  onBlur?: (e: Event) => void\n}\n\nexport const DEFAULT_TRIGGER = ['hover']\nexport const UPDATE_VISIBLE_EVENT = 'update:visible'\nexport default function (\n  props: IPopperOptions,\n  { emit }: SetupContext<EmitType[]>\n) {\n  const arrowRef = ref<RefElement>(null)\n  const triggerRef = ref(null) as Ref<ElementType>\n  const popperRef = ref<RefElement>(null)\n\n  const popperId = `el-popper-${generateId()}`\n  let popperInstance: Nullable<PopperInstance> = null\n  let showTimer: Nullable<TimeoutHandle> = null\n  let hideTimer: Nullable<TimeoutHandle> = null\n  let triggerFocused = false\n\n  const isManualMode = () => props.manualMode || props.trigger === 'manual'\n\n  const popperStyle = ref<CSSProperties>({ zIndex: PopupManager.nextZIndex() })\n\n  const popperOptions = usePopperOptions(props, {\n    arrow: arrowRef,\n  })\n\n  const state = reactive({\n    visible: !!props.visible,\n  })\n  // visible has been taken by props.visible, avoiding name collision\n  // Either marking type here or setter parameter\n  const visibility = computed<boolean>({\n    get() {\n      if (props.disabled) {\n        return false\n      } else {\n        return isBool(props.visible) ? props.visible : state.visible\n      }\n    },\n    set(val) {\n      if (isManualMode()) return\n      isBool(props.visible)\n        ? emit(UPDATE_VISIBLE_EVENT, val)\n        : (state.visible = val)\n    },\n  })\n\n  function _show() {\n    if (props.autoClose > 0) {\n      hideTimer = window.setTimeout(() => {\n        _hide()\n      }, props.autoClose)\n    }\n    visibility.value = true\n  }\n\n  function _hide() {\n    visibility.value = false\n  }\n\n  function clearTimers() {\n    clearTimeout(showTimer)\n    clearTimeout(hideTimer)\n  }\n\n  const show = () => {\n    if (isManualMode() || props.disabled) return\n    clearTimers()\n    if (props.showAfter === 0) {\n      _show()\n    } else {\n      showTimer = window.setTimeout(() => {\n        _show()\n      }, props.showAfter)\n    }\n  }\n\n  const hide = () => {\n    if (isManualMode()) return\n    clearTimers()\n    if (props.hideAfter > 0) {\n      hideTimer = window.setTimeout(() => {\n        close()\n      }, props.hideAfter)\n    } else {\n      close()\n    }\n  }\n  const close = () => {\n    _hide()\n    if (props.disabled) {\n      doDestroy(true)\n    }\n  }\n\n  function onPopperMouseEnter() {\n    // if trigger is click, user won't be able to close popper when\n    // user tries to move the mouse over popper contents\n    if (props.enterable && props.trigger !== 'click') {\n      clearTimeout(hideTimer)\n    }\n  }\n\n  function onPopperMouseLeave() {\n    const { trigger } = props\n    const shouldPrevent =\n      (isString(trigger) && (trigger === 'click' || trigger === 'focus')) ||\n      // we'd like to test array type trigger here, but the only case we need to cover is trigger === 'click' or\n      // trigger === 'focus', because that when trigger is string\n      // trigger.length === 1 and trigger[0] === 5 chars string is mutually exclusive.\n      // so there will be no need to test if trigger is array type.\n      (trigger.length === 1 &&\n        (trigger[0] === 'click' || trigger[0] === 'focus'))\n\n    if (shouldPrevent) return\n\n    hide()\n  }\n\n  function initializePopper() {\n    if (!unref(visibility)) {\n      return\n    }\n    const unwrappedTrigger = unref(triggerRef)\n    const _trigger = isHTMLElement(unwrappedTrigger)\n      ? unwrappedTrigger\n      : (unwrappedTrigger as ComponentPublicInstance).$el\n    popperInstance = createPopper(\n      _trigger,\n      unref(popperRef),\n      unref(popperOptions)\n    )\n\n    popperInstance.update()\n  }\n\n  function doDestroy(forceDestroy?: boolean) {\n    /* istanbul ignore if */\n    if (!popperInstance || (unref(visibility) && !forceDestroy)) return\n    detachPopper()\n  }\n\n  function detachPopper() {\n    popperInstance?.destroy?.()\n    popperInstance = null\n  }\n\n  const events = {} as PopperEvents\n\n  function update() {\n    if (!unref(visibility)) {\n      return\n    }\n    if (popperInstance) {\n      popperInstance.update()\n    } else {\n      initializePopper()\n    }\n  }\n\n  function onVisibilityChange(toState: boolean) {\n    if (toState) {\n      popperStyle.value.zIndex = PopupManager.nextZIndex()\n      initializePopper()\n    }\n  }\n\n  if (!isManualMode()) {\n    const toggleState = () => {\n      if (unref(visibility)) {\n        hide()\n      } else {\n        show()\n      }\n    }\n\n    const popperEventsHandler = (e: Event) => {\n      e.stopPropagation()\n      switch (e.type) {\n        case 'click': {\n          if (triggerFocused) {\n            // reset previous focus event\n            triggerFocused = false\n          } else {\n            toggleState()\n          }\n          break\n        }\n        case 'mouseenter': {\n          show()\n          break\n        }\n        case 'mouseleave': {\n          hide()\n          break\n        }\n        case 'focus': {\n          triggerFocused = true\n          show()\n          break\n        }\n        case 'blur': {\n          triggerFocused = false\n          hide()\n          break\n        }\n      }\n    }\n\n    const triggerEventsMap: Partial<\n      Record<TriggerType, (keyof PopperEvents)[]>\n    > = {\n      click: ['onClick'],\n      hover: ['onMouseenter', 'onMouseleave'],\n      focus: ['onFocus', 'onBlur'],\n    }\n\n    const mapEvents = (t: TriggerType) => {\n      triggerEventsMap[t].forEach((event) => {\n        events[event] = popperEventsHandler\n      })\n    }\n\n    if (isArray(props.trigger)) {\n      Object.values(props.trigger).forEach(mapEvents)\n    } else {\n      mapEvents(props.trigger as TriggerType)\n    }\n  }\n\n  watch(popperOptions, (val) => {\n    if (!popperInstance) return\n    popperInstance.setOptions(val)\n    popperInstance.update()\n  })\n\n  watch(visibility, onVisibilityChange)\n\n  return {\n    update,\n    doDestroy,\n    show,\n    hide,\n    onPopperMouseEnter,\n    onPopperMouseLeave,\n    onAfterEnter: () => {\n      emit('after-enter')\n    },\n    onAfterLeave: () => {\n      detachPopper()\n      emit('after-leave')\n    },\n    onBeforeEnter: () => {\n      emit('before-enter')\n    },\n    onBeforeLeave: () => {\n      emit('before-leave')\n    },\n    initializePopper,\n    isManualMode,\n    arrowRef,\n    events,\n    popperId,\n    popperInstance,\n    popperRef,\n    popperStyle,\n    triggerRef,\n    visibility,\n  }\n}\n\nexport * from './defaults'\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}