{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { isFunction, capitalize } from '@vue/shared';\nimport { isEmpty, isUndefined } from '../../../utils/util.mjs';\nvar ExpandTrigger = /* @__PURE__ */(ExpandTrigger2 => {\n  ExpandTrigger2[\"CLICK\"] = \"click\";\n  ExpandTrigger2[\"HOVER\"] = \"hover\";\n  return ExpandTrigger2;\n})(ExpandTrigger || {});\nlet uid = 0;\nconst calculatePathNodes = node => {\n  const nodes = [node];\n  let {\n    parent\n  } = node;\n  while (parent) {\n    nodes.unshift(parent);\n    parent = parent.parent;\n  }\n  return nodes;\n};\nclass Node {\n  constructor(data, config, parent, root = false) {\n    this.data = data;\n    this.config = config;\n    this.parent = parent;\n    this.root = root;\n    this.uid = uid++;\n    this.checked = false;\n    this.indeterminate = false;\n    this.loading = false;\n    const {\n      value: valueKey,\n      label: labelKey,\n      children: childrenKey\n    } = config;\n    const childrenData = data[childrenKey];\n    const pathNodes = calculatePathNodes(this);\n    this.level = root ? 0 : parent ? parent.level + 1 : 1;\n    this.value = data[valueKey];\n    this.label = data[labelKey];\n    this.pathNodes = pathNodes;\n    this.pathValues = pathNodes.map(node => node.value);\n    this.pathLabels = pathNodes.map(node => node.label);\n    this.childrenData = childrenData;\n    this.children = (childrenData || []).map(child => new Node(child, config, this));\n    this.loaded = !config.lazy || this.isLeaf || !isEmpty(childrenData);\n  }\n  get isDisabled() {\n    const {\n      data,\n      parent,\n      config\n    } = this;\n    const {\n      disabled,\n      checkStrictly\n    } = config;\n    const isDisabled = isFunction(disabled) ? disabled(data, this) : !!data[disabled];\n    return isDisabled || !checkStrictly && (parent == null ? void 0 : parent.isDisabled);\n  }\n  get isLeaf() {\n    const {\n      data,\n      config,\n      childrenData,\n      loaded\n    } = this;\n    const {\n      lazy,\n      leaf\n    } = config;\n    const isLeaf = isFunction(leaf) ? leaf(data, this) : data[leaf];\n    return isUndefined(isLeaf) ? lazy && !loaded ? false : !(Array.isArray(childrenData) && childrenData.length) : !!isLeaf;\n  }\n  get valueByOption() {\n    return this.config.emitPath ? this.pathValues : this.value;\n  }\n  appendChild(childData) {\n    const {\n      childrenData,\n      children\n    } = this;\n    const node = new Node(childData, this.config, this);\n    if (Array.isArray(childrenData)) {\n      childrenData.push(childData);\n    } else {\n      this.childrenData = [childData];\n    }\n    children.push(node);\n    return node;\n  }\n  calcText(allLevels, separator) {\n    const text = allLevels ? this.pathLabels.join(separator) : this.label;\n    this.text = text;\n    return text;\n  }\n  broadcast(event, ...args) {\n    const handlerName = `onParent${capitalize(event)}`;\n    this.children.forEach(child => {\n      if (child) {\n        child.broadcast(event, ...args);\n        child[handlerName] && child[handlerName](...args);\n      }\n    });\n  }\n  emit(event, ...args) {\n    const {\n      parent\n    } = this;\n    const handlerName = `onChild${capitalize(event)}`;\n    if (parent) {\n      parent[handlerName] && parent[handlerName](...args);\n      parent.emit(event, ...args);\n    }\n  }\n  onParentCheck(checked) {\n    if (!this.isDisabled) {\n      this.setCheckState(checked);\n    }\n  }\n  onChildCheck() {\n    const {\n      children\n    } = this;\n    const validChildren = children.filter(child => !child.isDisabled);\n    const checked = validChildren.length ? validChildren.every(child => child.checked) : false;\n    this.setCheckState(checked);\n  }\n  setCheckState(checked) {\n    const totalNum = this.children.length;\n    const checkedNum = this.children.reduce((c, p) => {\n      const num = p.checked ? 1 : p.indeterminate ? 0.5 : 0;\n      return c + num;\n    }, 0);\n    this.checked = this.loaded && this.children.every(child => child.loaded && child.checked) && checked;\n    this.indeterminate = this.loaded && checkedNum !== totalNum && checkedNum > 0;\n  }\n  doCheck(checked) {\n    if (this.checked === checked) return;\n    const {\n      checkStrictly,\n      multiple\n    } = this.config;\n    if (checkStrictly || !multiple) {\n      this.checked = checked;\n    } else {\n      this.broadcast(\"check\", checked);\n      this.setCheckState(checked);\n      this.emit(\"check\");\n    }\n  }\n}\nexport { ExpandTrigger, Node as default };","map":{"version":3,"names":["ExpandTrigger","ExpandTrigger2","uid","calculatePathNodes","node","nodes","parent","unshift","Node","constructor","data","config","root","checked","indeterminate","loading","value","valueKey","label","labelKey","children","childrenKey","childrenData","pathNodes","level","pathValues","map","pathLabels","child","loaded","lazy","isLeaf","isEmpty","isDisabled","disabled","checkStrictly","isFunction","leaf","isUndefined","Array","isArray","length","valueByOption","emitPath","appendChild","childData","push","calcText","allLevels","separator","text","join","broadcast","event","args","handlerName","capitalize","forEach","emit","onParentCheck","setCheckState","onChildCheck","validChildren","filter","every","totalNum","checkedNum","reduce","c","p","num","doCheck","multiple"],"sources":["../../../../../../packages/components/cascader-panel/src/node.ts"],"sourcesContent":["import { isFunction } from '@vue/shared'\nimport { capitalize, isUndefined, isEmpty } from '@element-plus/utils/util'\nimport type { VNode } from 'vue'\n\nexport type CascaderNodeValue = string | number\nexport type CascaderNodePathValue = CascaderNodeValue[]\nexport type CascaderValue =\n  | CascaderNodeValue\n  | CascaderNodePathValue\n  | (CascaderNodeValue | CascaderNodePathValue)[]\nexport type CascaderConfig = Required<CascaderProps>\nexport enum ExpandTrigger {\n  CLICK = 'click',\n  HOVER = 'hover',\n}\nexport type isDisabled = (data: CascaderOption, node: Node) => boolean\nexport type isLeaf = (data: CascaderOption, node: Node) => boolean\nexport type Resolve = (dataList?: CascaderOption[]) => void\nexport type LazyLoad = (node: Node, resolve: Resolve) => void\nexport type RenderLabel = ({\n  node: Node,\n  data: CascaderOption,\n}) => VNode | VNode[]\nexport interface CascaderOption extends Record<string, unknown> {\n  label?: string\n  value?: CascaderNodeValue\n  children?: CascaderOption[]\n  disabled?: boolean\n  leaf?: boolean\n}\n\nexport interface CascaderProps {\n  expandTrigger?: ExpandTrigger\n  multiple?: boolean\n  checkStrictly?: boolean\n  emitPath?: boolean\n  lazy?: boolean\n  lazyLoad?: LazyLoad\n  value?: string\n  label?: string\n  children?: string\n  disabled?: string | isDisabled\n  leaf?: string | isLeaf\n  hoverThreshold?: number\n}\n\nexport type Nullable<T> = null | T\n\ntype ChildrenData = CascaderOption[] | undefined\n\nlet uid = 0\n\nconst calculatePathNodes = (node: Node) => {\n  const nodes = [node]\n  let { parent } = node\n\n  while (parent) {\n    nodes.unshift(parent)\n    parent = parent.parent\n  }\n\n  return nodes\n}\n\nclass Node {\n  readonly uid: number = uid++\n  readonly level: number\n  readonly value: CascaderNodeValue\n  readonly label: string\n  readonly pathNodes: Node[]\n  readonly pathValues: CascaderNodePathValue\n  readonly pathLabels: string[]\n\n  childrenData: ChildrenData\n  children: Node[]\n  text: string\n  loaded: boolean\n  checked = false\n  indeterminate = false\n  loading = false\n\n  constructor(\n    readonly data: Nullable<CascaderOption>,\n    readonly config: CascaderConfig,\n    readonly parent?: Node,\n    readonly root = false\n  ) {\n    const { value: valueKey, label: labelKey, children: childrenKey } = config\n\n    const childrenData = data[childrenKey] as ChildrenData\n    const pathNodes = calculatePathNodes(this)\n\n    this.level = root ? 0 : parent ? parent.level + 1 : 1\n    this.value = data[valueKey] as CascaderNodeValue\n    this.label = data[labelKey] as string\n    this.pathNodes = pathNodes\n    this.pathValues = pathNodes.map((node) => node.value)\n    this.pathLabels = pathNodes.map((node) => node.label)\n    this.childrenData = childrenData\n    this.children = (childrenData || []).map(\n      (child) => new Node(child, config, this)\n    )\n    this.loaded = !config.lazy || this.isLeaf || !isEmpty(childrenData)\n  }\n\n  get isDisabled(): boolean {\n    const { data, parent, config } = this\n    const { disabled, checkStrictly } = config\n    const isDisabled = isFunction(disabled)\n      ? disabled(data, this)\n      : !!data[disabled]\n    return isDisabled || (!checkStrictly && parent?.isDisabled)\n  }\n\n  get isLeaf(): boolean {\n    const { data, config, childrenData, loaded } = this\n    const { lazy, leaf } = config\n    const isLeaf = isFunction(leaf) ? leaf(data, this) : data[leaf]\n\n    return isUndefined(isLeaf)\n      ? lazy && !loaded\n        ? false\n        : !(Array.isArray(childrenData) && childrenData.length)\n      : !!isLeaf\n  }\n\n  get valueByOption() {\n    return this.config.emitPath ? this.pathValues : this.value\n  }\n\n  appendChild(childData: CascaderOption) {\n    const { childrenData, children } = this\n    const node = new Node(childData, this.config, this)\n\n    if (Array.isArray(childrenData)) {\n      childrenData.push(childData)\n    } else {\n      this.childrenData = [childData]\n    }\n\n    children.push(node)\n\n    return node\n  }\n\n  calcText(allLevels: boolean, separator: string) {\n    const text = allLevels ? this.pathLabels.join(separator) : this.label\n    this.text = text\n    return text\n  }\n\n  broadcast(event: string, ...args: unknown[]) {\n    const handlerName = `onParent${capitalize(event)}`\n    this.children.forEach((child) => {\n      if (child) {\n        // bottom up\n        child.broadcast(event, ...args)\n        child[handlerName] && child[handlerName](...args)\n      }\n    })\n  }\n\n  emit(event: string, ...args: unknown[]) {\n    const { parent } = this\n    const handlerName = `onChild${capitalize(event)}`\n    if (parent) {\n      parent[handlerName] && parent[handlerName](...args)\n      parent.emit(event, ...args)\n    }\n  }\n\n  onParentCheck(checked: boolean) {\n    if (!this.isDisabled) {\n      this.setCheckState(checked)\n    }\n  }\n\n  onChildCheck() {\n    const { children } = this\n    const validChildren = children.filter((child) => !child.isDisabled)\n    const checked = validChildren.length\n      ? validChildren.every((child) => child.checked)\n      : false\n\n    this.setCheckState(checked)\n  }\n\n  setCheckState(checked: boolean) {\n    const totalNum = this.children.length\n    const checkedNum = this.children.reduce((c, p) => {\n      const num = p.checked ? 1 : p.indeterminate ? 0.5 : 0\n      return c + num\n    }, 0)\n\n    this.checked =\n      this.loaded &&\n      this.children.every((child) => child.loaded && child.checked) &&\n      checked\n    this.indeterminate =\n      this.loaded && checkedNum !== totalNum && checkedNum > 0\n  }\n\n  doCheck(checked: boolean) {\n    if (this.checked === checked) return\n\n    const { checkStrictly, multiple } = this.config\n\n    if (checkStrictly || !multiple) {\n      this.checked = checked\n    } else {\n      // bottom up to unify the calculation of the indeterminate state\n      this.broadcast('check', checked)\n      this.setCheckState(checked)\n      this.emit('check')\n    }\n  }\n}\n\nexport default Node\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}