{"ast":null,"code":"import '../../../../utils/util.mjs';\nimport { throwError } from '../../../../utils/error.mjs';\nimport createList from '../builders/build-list.mjs';\nimport { isHorizontal } from '../utils.mjs';\nimport { SMART_ALIGNMENT, AUTO_ALIGNMENT, CENTERED_ALIGNMENT, END_ALIGNMENT, START_ALIGNMENT } from '../defaults.mjs';\nimport { isString } from '@vue/shared';\nconst FixedSizeList = createList({\n  name: \"ElFixedSizeList\",\n  getItemOffset: ({\n    itemSize\n  }, index) => index * itemSize,\n  getItemSize: ({\n    itemSize\n  }) => itemSize,\n  getEstimatedTotalSize: ({\n    total,\n    itemSize\n  }) => itemSize * total,\n  getOffset: ({\n    height,\n    total,\n    itemSize,\n    layout,\n    width\n  }, index, alignment, scrollOffset) => {\n    const size = isHorizontal(layout) ? width : height;\n    if (process.env.NODE_ENV !== \"production\" && isString(size)) {\n      throwError(\"[ElVirtualList]\", `\n        You should set\n          width/height\n        to number when your layout is\n          horizontal/vertical\n      `);\n    }\n    const lastItemOffset = Math.max(0, total * itemSize - size);\n    const maxOffset = Math.min(lastItemOffset, index * itemSize);\n    const minOffset = Math.max(0, (index + 1) * itemSize - size);\n    if (alignment === SMART_ALIGNMENT) {\n      if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\n        alignment = AUTO_ALIGNMENT;\n      } else {\n        alignment = CENTERED_ALIGNMENT;\n      }\n    }\n    switch (alignment) {\n      case START_ALIGNMENT:\n        {\n          return maxOffset;\n        }\n      case END_ALIGNMENT:\n        {\n          return minOffset;\n        }\n      case CENTERED_ALIGNMENT:\n        {\n          const middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);\n          if (middleOffset < Math.ceil(size / 2)) {\n            return 0;\n          } else if (middleOffset > lastItemOffset + Math.floor(size / 2)) {\n            return lastItemOffset;\n          } else {\n            return middleOffset;\n          }\n        }\n      case AUTO_ALIGNMENT:\n      default:\n        {\n          if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n            return scrollOffset;\n          } else if (scrollOffset < minOffset) {\n            return minOffset;\n          } else {\n            return maxOffset;\n          }\n        }\n    }\n  },\n  getStartIndexForOffset: ({\n    total,\n    itemSize\n  }, offset) => Math.max(0, Math.min(total - 1, Math.floor(offset / itemSize))),\n  getStopIndexForStartIndex: ({\n    height,\n    total,\n    itemSize,\n    layout,\n    width\n  }, startIndex, scrollOffset) => {\n    const offset = startIndex * itemSize;\n    const size = isHorizontal(layout) ? width : height;\n    const numVisibleItems = Math.ceil((size + scrollOffset - offset) / itemSize);\n    return Math.max(0, Math.min(total - 1, startIndex + numVisibleItems - 1));\n  },\n  initCache() {\n    return void 0;\n  },\n  clearCache: true,\n  validateProps() {}\n});\nexport { FixedSizeList as default };","map":{"version":3,"names":["FixedSizeList","createList","name","getItemOffset","itemSize","index","getItemSize","getEstimatedTotalSize","total","getOffset","height","layout","width","alignment","scrollOffset","size","isHorizontal","process","env","NODE_ENV","isString","throwError","lastItemOffset","Math","max","maxOffset","min","minOffset","SMART_ALIGNMENT","AUTO_ALIGNMENT","CENTERED_ALIGNMENT","START_ALIGNMENT","END_ALIGNMENT","middleOffset","round","ceil","floor","getStartIndexForOffset","offset","getStopIndexForStartIndex","startIndex","numVisibleItems","initCache","clearCache","validateProps"],"sources":["../../../../../../../packages/components/virtual-list/src/components/fixed-size-list.ts"],"sourcesContent":["import { isString } from '@element-plus/utils/util'\nimport { throwError } from '@element-plus/utils/error'\nimport buildList from '../builders/build-list'\nimport { isHorizontal } from '../utils'\nimport {\n  SMART_ALIGNMENT,\n  AUTO_ALIGNMENT,\n  START_ALIGNMENT,\n  END_ALIGNMENT,\n  CENTERED_ALIGNMENT,\n} from '../defaults'\n\nimport type { VirtualizedListProps } from '../props'\n\ntype Props = VirtualizedListProps\n\nconst FixedSizeList = buildList({\n  name: 'ElFixedSizeList',\n  getItemOffset: ({ itemSize }, index) => index * (itemSize as number),\n\n  getItemSize: ({ itemSize }) => itemSize as number,\n\n  getEstimatedTotalSize: ({ total, itemSize }) => (itemSize as number) * total,\n\n  getOffset: (\n    { height, total, itemSize, layout, width },\n    index,\n    alignment,\n    scrollOffset\n  ) => {\n    const size = (isHorizontal(layout) ? width : height) as number\n    if (process.env.NODE_ENV !== 'production' && isString(size)) {\n      throwError(\n        '[ElVirtualList]',\n        `\n        You should set\n          width/height\n        to number when your layout is\n          horizontal/vertical\n      `\n      )\n    }\n    const lastItemOffset = Math.max(0, total * (itemSize as number) - size)\n    const maxOffset = Math.min(lastItemOffset, index * (itemSize as number))\n    const minOffset = Math.max(0, (index + 1) * (itemSize as number) - size)\n\n    if (alignment === SMART_ALIGNMENT) {\n      if (\n        scrollOffset >= minOffset - size &&\n        scrollOffset <= maxOffset + size\n      ) {\n        alignment = AUTO_ALIGNMENT\n      } else {\n        alignment = CENTERED_ALIGNMENT\n      }\n    }\n\n    switch (alignment) {\n      case START_ALIGNMENT: {\n        return maxOffset\n      }\n      case END_ALIGNMENT: {\n        return minOffset\n      }\n      case CENTERED_ALIGNMENT: {\n        // \"Centered\" offset is usually the average of the min and max.\n        // But near the edges of the list, this doesn't hold true.\n        const middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2)\n        if (middleOffset < Math.ceil(size / 2)) {\n          return 0 // near the beginning\n        } else if (middleOffset > lastItemOffset + Math.floor(size / 2)) {\n          return lastItemOffset // near the end\n        } else {\n          return middleOffset\n        }\n      }\n      case AUTO_ALIGNMENT:\n      default: {\n        if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n          return scrollOffset\n        } else if (scrollOffset < minOffset) {\n          return minOffset\n        } else {\n          return maxOffset\n        }\n      }\n    }\n  },\n\n  getStartIndexForOffset: ({ total, itemSize }, offset) =>\n    Math.max(0, Math.min(total - 1, Math.floor(offset / (itemSize as number)))),\n\n  getStopIndexForStartIndex: (\n    { height, total, itemSize, layout, width }: Props,\n    startIndex: number,\n    scrollOffset: number\n  ) => {\n    const offset = startIndex * (itemSize as number)\n    const size = isHorizontal(layout) ? width : height\n    const numVisibleItems = Math.ceil(\n      ((size as number) + scrollOffset - offset) / (itemSize as number)\n    )\n    return Math.max(\n      0,\n      Math.min(\n        total - 1,\n        // because startIndex is inclusive, so in order to prevent array outbound indexing\n        // we need to - 1 to prevent outbound behavior\n        startIndex + numVisibleItems - 1\n      )\n    )\n  },\n\n  /**\n   * Fixed size list does not need this cache\n   * Using any to bypass it, TODO: Using type inference to fix this.\n   */\n  initCache() {\n    return undefined as any\n  },\n\n  clearCache: true,\n\n  validateProps() {\n    //\n  },\n})\n\nexport default FixedSizeList\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}