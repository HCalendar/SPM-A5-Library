{"ast":null,"code":"import { defineComponent, ref, reactive, computed, unref, watch, onMounted, onBeforeUnmount, h, withModifiers } from 'vue';\nimport '../../../scrollbar/index.mjs';\nimport { on, off } from '../../../../utils/dom.mjs';\nimport { cAF, rAF } from '../../../../utils/raf.mjs';\nimport isServer from '../../../../utils/isServer.mjs';\nimport { HORIZONTAL, ScrollbarDirKey, SCROLLBAR_MIN_SIZE } from '../defaults.mjs';\nimport { virtualizedScrollbarProps } from '../props.mjs';\nimport { renderThumbStyle } from '../utils.mjs';\nimport { BAR_MAP } from '../../../scrollbar/src/util.mjs';\nconst ScrollBar = defineComponent({\n  name: \"ElVirtualScrollBar\",\n  props: virtualizedScrollbarProps,\n  emits: [\"scroll\", \"start-move\", \"stop-move\"],\n  setup(props, {\n    emit\n  }) {\n    const GAP = 4;\n    const trackRef = ref();\n    const thumbRef = ref();\n    let frameHandle = null;\n    let onselectstartStore = null;\n    const state = reactive({\n      isDragging: false,\n      traveled: 0\n    });\n    const bar = computed(() => BAR_MAP[props.layout]);\n    const trackSize = computed(() => props.clientSize - GAP);\n    const trackStyle = computed(() => ({\n      position: \"absolute\",\n      width: HORIZONTAL === props.layout ? `${trackSize.value}px` : \"6px\",\n      height: HORIZONTAL === props.layout ? \"6px\" : `${trackSize.value}px`,\n      [ScrollbarDirKey[props.layout]]: \"2px\",\n      right: \"2px\",\n      bottom: \"2px\",\n      borderRadius: \"4px\"\n    }));\n    const thumbSize = computed(() => {\n      const ratio = props.ratio;\n      const clientSize = props.clientSize;\n      if (ratio >= 100) {\n        return Number.POSITIVE_INFINITY;\n      }\n      if (ratio >= 50) {\n        return ratio * clientSize / 100;\n      }\n      const SCROLLBAR_MAX_SIZE = clientSize / 3;\n      return Math.floor(Math.min(Math.max(ratio * clientSize, SCROLLBAR_MIN_SIZE), SCROLLBAR_MAX_SIZE));\n    });\n    const thumbStyle = computed(() => {\n      if (!Number.isFinite(thumbSize.value)) {\n        return {\n          display: \"none\"\n        };\n      }\n      const thumb = `${thumbSize.value}px`;\n      const style = renderThumbStyle({\n        bar: bar.value,\n        size: thumb,\n        move: state.traveled\n      }, props.layout);\n      return style;\n    });\n    const totalSteps = computed(() => Math.floor(props.clientSize - thumbSize.value - GAP));\n    const attachEvents = () => {\n      on(window, \"mousemove\", onMouseMove);\n      on(window, \"mouseup\", onMouseUp);\n      const thumbEl = unref(thumbRef);\n      if (!thumbEl) return;\n      onselectstartStore = document.onselectstart;\n      document.onselectstart = () => false;\n      on(thumbEl, \"touchmove\", onMouseMove);\n      on(thumbEl, \"touchend\", onMouseUp);\n    };\n    const detachEvents = () => {\n      off(window, \"mousemove\", onMouseMove);\n      off(window, \"mouseup\", onMouseUp);\n      document.onselectstart = onselectstartStore;\n      onselectstartStore = null;\n      const thumbEl = unref(thumbRef);\n      if (!thumbEl) return;\n      off(thumbEl, \"touchmove\", onMouseMove);\n      off(thumbEl, \"touchend\", onMouseUp);\n    };\n    const onThumbMouseDown = e => {\n      e.stopImmediatePropagation();\n      if (e.ctrlKey || [1, 2].includes(e.button)) {\n        return;\n      }\n      state.isDragging = true;\n      state[bar.value.axis] = e.currentTarget[bar.value.offset] - (e[bar.value.client] - e.currentTarget.getBoundingClientRect()[bar.value.direction]);\n      emit(\"start-move\");\n      attachEvents();\n    };\n    const onMouseUp = () => {\n      state.isDragging = false;\n      state[bar.value.axis] = 0;\n      emit(\"stop-move\");\n      detachEvents();\n    };\n    const onMouseMove = e => {\n      const {\n        isDragging\n      } = state;\n      if (!isDragging) return;\n      if (!thumbRef.value || !trackRef.value) return;\n      const prevPage = state[bar.value.axis];\n      if (!prevPage) return;\n      cAF(frameHandle);\n      const offset = (trackRef.value.getBoundingClientRect()[bar.value.direction] - e[bar.value.client]) * -1;\n      const thumbClickPosition = thumbRef.value[bar.value.offset] - prevPage;\n      const distance = offset - thumbClickPosition;\n      frameHandle = rAF(() => {\n        state.traveled = Math.max(0, Math.min(distance, totalSteps.value));\n        emit(\"scroll\", distance, totalSteps.value);\n      });\n    };\n    const clickTrackHandler = e => {\n      const offset = Math.abs(e.target.getBoundingClientRect()[bar.value.direction] - e[bar.value.client]);\n      const thumbHalf = thumbRef.value[bar.value.offset] / 2;\n      const distance = offset - thumbHalf;\n      state.traveled = Math.max(0, Math.min(distance, totalSteps.value));\n      emit(\"scroll\", distance, totalSteps.value);\n    };\n    const onScrollbarTouchStart = e => e.preventDefault();\n    watch(() => props.scrollFrom, v => {\n      if (state.isDragging) return;\n      state.traveled = Math.ceil(v * totalSteps.value);\n    });\n    onMounted(() => {\n      if (isServer) return;\n      on(trackRef.value, \"touchstart\", onScrollbarTouchStart);\n      on(thumbRef.value, \"touchstart\", onThumbMouseDown);\n    });\n    onBeforeUnmount(() => {\n      off(trackRef.value, \"touchstart\", onScrollbarTouchStart);\n      detachEvents();\n    });\n    return () => {\n      return h(\"div\", {\n        role: \"presentation\",\n        ref: trackRef,\n        class: \"el-virtual-scrollbar\",\n        style: trackStyle.value,\n        onMousedown: withModifiers(clickTrackHandler, [\"stop\", \"prevent\"])\n      }, h(\"div\", {\n        ref: thumbRef,\n        class: \"el-scrollbar__thumb\",\n        style: thumbStyle.value,\n        onMousedown: onThumbMouseDown\n      }, []));\n    };\n  }\n});\nexport { ScrollBar as default };","map":{"version":3,"names":["ScrollBar","defineComponent","name","props","virtualizedScrollbarProps","emits","setup","emit","GAP","trackRef","ref","thumbRef","frameHandle","onselectstartStore","state","reactive","isDragging","traveled","bar","computed","BAR_MAP","layout","trackSize","clientSize","trackStyle","position","width","HORIZONTAL","value","height","ScrollbarDirKey","right","bottom","borderRadius","thumbSize","ratio","Number","POSITIVE_INFINITY","SCROLLBAR_MAX_SIZE","Math","floor","min","max","SCROLLBAR_MIN_SIZE","thumbStyle","isFinite","display","thumb","style","renderThumbStyle","size","move","totalSteps","attachEvents","on","window","onMouseMove","onMouseUp","thumbEl","unref","document","onselectstart","detachEvents","off","onThumbMouseDown","e","stopImmediatePropagation","ctrlKey","includes","button","axis","currentTarget","offset","client","getBoundingClientRect","direction","prevPage","cAF","thumbClickPosition","distance","rAF","clickTrackHandler","abs","target","thumbHalf","onScrollbarTouchStart","preventDefault","watch","scrollFrom","v","ceil","onMounted","isServer","onBeforeUnmount","h","role","class","onMousedown","withModifiers"],"sources":["../../../../../../../packages/components/virtual-list/src/components/scrollbar.ts"],"sourcesContent":["import {\n  computed,\n  defineComponent,\n  ref,\n  reactive,\n  onMounted,\n  onBeforeUnmount,\n  watch,\n  h,\n  withModifiers,\n  unref,\n} from 'vue'\nimport { BAR_MAP } from '@element-plus/components/scrollbar'\nimport { on, off } from '@element-plus/utils/dom'\nimport { rAF, cAF } from '@element-plus/utils/raf'\nimport isServer from '@element-plus/utils/isServer'\n\nimport { SCROLLBAR_MIN_SIZE, HORIZONTAL, ScrollbarDirKey } from '../defaults'\nimport { virtualizedScrollbarProps } from '../props'\nimport { renderThumbStyle } from '../utils'\n\nimport type { CSSProperties } from 'vue'\n\nconst ScrollBar = defineComponent({\n  name: 'ElVirtualScrollBar',\n  props: virtualizedScrollbarProps,\n  emits: ['scroll', 'start-move', 'stop-move'],\n  setup(props, { emit }) {\n    const GAP = 4 // top 2 + bottom 2 | left 2 + right 2\n\n    // DOM refs\n    const trackRef = ref<HTMLElement>()\n    const thumbRef = ref<HTMLElement>()\n\n    // local variables\n    let frameHandle: null | number = null\n    let onselectstartStore: null | typeof document.onselectstart = null\n\n    // data\n    const state = reactive({\n      isDragging: false,\n      traveled: 0,\n    })\n\n    const bar = computed(() => BAR_MAP[props.layout])\n\n    const trackSize = computed(() => props.clientSize! - GAP)\n\n    const trackStyle = computed<CSSProperties>(() => ({\n      position: 'absolute',\n      width: HORIZONTAL === props.layout ? `${trackSize.value}px` : '6px',\n      height: HORIZONTAL === props.layout ? '6px' : `${trackSize.value}px`,\n      [ScrollbarDirKey[props.layout]]: '2px',\n      right: '2px',\n      bottom: '2px',\n      borderRadius: '4px',\n    }))\n\n    const thumbSize = computed(() => {\n      const ratio = props.ratio!\n      const clientSize = props.clientSize!\n      if (ratio >= 100) {\n        return Number.POSITIVE_INFINITY\n      }\n\n      if (ratio >= 50) {\n        return (ratio * clientSize) / 100\n      }\n\n      const SCROLLBAR_MAX_SIZE = clientSize / 3\n      return Math.floor(\n        Math.min(\n          Math.max(ratio * clientSize, SCROLLBAR_MIN_SIZE),\n          SCROLLBAR_MAX_SIZE\n        )\n      )\n    })\n\n    // const sizeRange = computed(() => props.size - thumbSize.value)\n\n    const thumbStyle = computed<CSSProperties>(() => {\n      if (!Number.isFinite(thumbSize.value)) {\n        return {\n          display: 'none',\n        }\n      }\n\n      const thumb = `${thumbSize.value}px`\n\n      const style: CSSProperties = renderThumbStyle(\n        {\n          bar: bar.value,\n          size: thumb,\n          move: state.traveled,\n        },\n        props.layout\n      )\n\n      return style\n    })\n\n    const totalSteps = computed(() =>\n      Math.floor(props.clientSize! - thumbSize.value - GAP)\n    )\n\n    const attachEvents = () => {\n      on(window, 'mousemove', onMouseMove)\n      on(window, 'mouseup', onMouseUp)\n\n      const thumbEl = unref(thumbRef)\n\n      if (!thumbEl) return\n\n      onselectstartStore = document.onselectstart\n      document.onselectstart = () => false\n\n      on(thumbEl, 'touchmove', onMouseMove)\n      on(thumbEl, 'touchend', onMouseUp)\n    }\n\n    const detachEvents = () => {\n      off(window, 'mousemove', onMouseMove)\n      off(window, 'mouseup', onMouseUp)\n\n      document.onselectstart = onselectstartStore\n      onselectstartStore = null\n\n      const thumbEl = unref(thumbRef)\n      if (!thumbEl) return\n\n      off(thumbEl, 'touchmove', onMouseMove)\n      off(thumbEl, 'touchend', onMouseUp)\n    }\n\n    const onThumbMouseDown = (e: Event) => {\n      e.stopImmediatePropagation()\n      if (\n        (e as KeyboardEvent).ctrlKey ||\n        [1, 2].includes((e as MouseEvent).button)\n      ) {\n        return\n      }\n\n      state.isDragging = true\n      state[bar.value.axis] =\n        e.currentTarget![bar.value.offset] -\n        (e[bar.value.client] -\n          (e.currentTarget as HTMLElement).getBoundingClientRect()[\n            bar.value.direction\n          ])\n\n      emit('start-move')\n      attachEvents()\n    }\n\n    const onMouseUp = () => {\n      state.isDragging = false\n      state[bar.value.axis] = 0\n      emit('stop-move')\n      detachEvents()\n    }\n\n    const onMouseMove = (e: Event) => {\n      const { isDragging } = state\n      if (!isDragging) return\n      if (!thumbRef.value || !trackRef.value) return\n\n      const prevPage = state[bar.value.axis]\n      if (!prevPage) return\n\n      cAF(frameHandle!)\n      // using the current track's offset top/left - the current pointer's clientY/clientX\n      // to get the relative position of the pointer to the track.\n      const offset =\n        (trackRef.value.getBoundingClientRect()[bar.value.direction] -\n          e[bar.value.client]) *\n        -1\n\n      // find where the thumb was clicked on.\n      const thumbClickPosition = thumbRef.value[bar.value.offset] - prevPage\n      /**\n       *  +--------------+                                   +--------------+\n       *  |              -  <--------- thumb.offsetTop       |              |\n       *  |             |+|             <--+                 |              |\n       *  |              -                 |                 |              |\n       *  |   Content    |                 |                 |              |\n       *  |              |                 |                 |              |\n       *  |              |                 |                 |              |\n       *  |              |                 |                 |              -\n       *  |              |                 +-->              |             |+|\n       *  |              |                                   |              -\n       *  +--------------+                                   +--------------+\n       */\n\n      // using the current position - prev position to\n\n      const distance = offset - thumbClickPosition\n      // get how many steps in total.\n      // gap of 2 on top, 2 on bottom, in total 4.\n      // using totalSteps ÷ totalSize getting each step's size * distance to get the new\n      // scroll offset to scrollTo\n      frameHandle = rAF(() => {\n        state.traveled = Math.max(\n          0,\n          Math.min(\n            distance,\n            totalSteps.value // 2 is the top value\n          )\n        )\n        emit('scroll', distance, totalSteps.value)\n      })\n    }\n\n    const clickTrackHandler = (e: MouseEvent) => {\n      const offset = Math.abs(\n        (e.target as HTMLElement).getBoundingClientRect()[bar.value.direction] -\n          e[bar.value.client]\n      )\n      const thumbHalf = thumbRef.value![bar.value.offset] / 2\n      const distance = offset - thumbHalf\n\n      state.traveled = Math.max(0, Math.min(distance, totalSteps.value))\n      emit('scroll', distance, totalSteps.value)\n    }\n\n    const onScrollbarTouchStart = (e: Event) => e.preventDefault()\n\n    watch(\n      () => props.scrollFrom,\n      (v) => {\n        if (state.isDragging) return\n        /**\n         *  this is simply mapping the current scrollbar offset\n         *\n         *  formula 1:\n         *    v = scrollOffset / (estimatedTotalSize - clientSize)\n         *    traveled = v * (clientSize - thumbSize - GAP) --> v * totalSteps\n         *\n         *  formula 2:\n         *    traveled = (v * clientSize) / (clientSize / totalSteps) --> (v * clientSize) * (totalSteps / clientSize) --> v * totalSteps\n         */\n        state.traveled = Math.ceil(v! * totalSteps.value)\n      }\n    )\n\n    onMounted(() => {\n      if (isServer) return\n\n      on(trackRef.value!, 'touchstart', onScrollbarTouchStart)\n      on(thumbRef.value!, 'touchstart', onThumbMouseDown)\n    })\n\n    onBeforeUnmount(() => {\n      off(trackRef.value!, 'touchstart', onScrollbarTouchStart)\n      detachEvents()\n    })\n\n    return () => {\n      return h(\n        'div',\n        {\n          role: 'presentation',\n          ref: trackRef,\n          class: 'el-virtual-scrollbar',\n          style: trackStyle.value,\n          onMousedown: withModifiers(clickTrackHandler, ['stop', 'prevent']),\n        },\n        h(\n          'div',\n          {\n            ref: thumbRef,\n            class: 'el-scrollbar__thumb',\n            style: thumbStyle.value,\n            onMousedown: onThumbMouseDown,\n          },\n          []\n        )\n      )\n    }\n  },\n})\n\nexport default ScrollBar\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}