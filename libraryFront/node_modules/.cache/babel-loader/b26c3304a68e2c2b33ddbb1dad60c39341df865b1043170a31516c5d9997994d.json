{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { isVNode, defineComponent, renderSlot, createVNode, createTextVNode } from 'vue';\nimport { isString, isArray } from '@vue/shared';\nimport { isFragment, PatchFlags, isValidElementNode } from '../../../utils/vnode.mjs';\nimport { isNumber } from '../../../utils/util.mjs';\nimport { buildProps, definePropType, componentSize } from '../../../utils/props.mjs';\nimport './item.mjs';\nimport { useSpace } from './use-space.mjs';\nimport script from './item.vue_vue_type_script_lang.mjs';\nconst spaceProps = buildProps({\n  direction: {\n    type: String,\n    values: [\"horizontal\", \"vertical\"],\n    default: \"horizontal\"\n  },\n  class: {\n    type: definePropType([String, Object, Array]),\n    default: \"\"\n  },\n  style: {\n    type: definePropType([String, Array, Object]),\n    default: \"\"\n  },\n  alignment: {\n    type: definePropType(String),\n    default: \"center\"\n  },\n  prefixCls: {\n    type: String\n  },\n  spacer: {\n    type: definePropType([Object, String, Number, Array]),\n    default: null,\n    validator: val => isVNode(val) || isNumber(val) || isString(val)\n  },\n  wrap: {\n    type: Boolean,\n    default: false\n  },\n  fill: {\n    type: Boolean,\n    default: false\n  },\n  fillRatio: {\n    type: Number,\n    default: 100\n  },\n  size: {\n    type: [String, Array, Number],\n    values: componentSize,\n    validator: val => {\n      return isNumber(val) || isArray(val) && val.length === 2 && val.every(i => isNumber(i));\n    }\n  }\n});\nvar Space = defineComponent({\n  name: \"ElSpace\",\n  props: spaceProps,\n  setup(props, {\n    slots\n  }) {\n    const {\n      classes,\n      containerStyle,\n      itemStyle\n    } = useSpace(props);\n    return () => {\n      var _a;\n      const {\n        spacer,\n        prefixCls,\n        direction\n      } = props;\n      const children = renderSlot(slots, \"default\", {\n        key: 0\n      }, () => []);\n      if (((_a = children.children) != null ? _a : []).length === 0) return null;\n      if (isArray(children.children)) {\n        let extractedChildren = [];\n        children.children.forEach((child, loopKey) => {\n          if (isFragment(child)) {\n            if (isArray(child.children)) {\n              child.children.forEach((nested, key) => {\n                extractedChildren.push(createVNode(script, {\n                  style: itemStyle.value,\n                  prefixCls,\n                  key: `nested-${key}`\n                }, {\n                  default: () => [nested]\n                }, PatchFlags.PROPS | PatchFlags.STYLE, [\"style\", \"prefixCls\"]));\n              });\n            }\n          } else if (isValidElementNode(child)) {\n            extractedChildren.push(createVNode(script, {\n              style: itemStyle.value,\n              prefixCls,\n              key: `LoopKey${loopKey}`\n            }, {\n              default: () => [child]\n            }, PatchFlags.PROPS | PatchFlags.STYLE, [\"style\", \"prefixCls\"]));\n          }\n        });\n        if (spacer) {\n          const len = extractedChildren.length - 1;\n          extractedChildren = extractedChildren.reduce((acc, child, idx) => {\n            const children2 = [...acc, child];\n            if (idx !== len) {\n              children2.push(createVNode(\"span\", {\n                style: [itemStyle.value, direction === \"vertical\" ? \"width: 100%\" : null],\n                key: idx\n              }, [isVNode(spacer) ? spacer : createTextVNode(spacer, PatchFlags.TEXT)], PatchFlags.STYLE));\n            }\n            return children2;\n          }, []);\n        }\n        return createVNode(\"div\", {\n          class: classes.value,\n          style: containerStyle.value\n        }, extractedChildren, PatchFlags.STYLE | PatchFlags.CLASS);\n      }\n      return children.children;\n    };\n  }\n});\nexport { Space as default, spaceProps };","map":{"version":3,"names":["spaceProps","buildProps","direction","type","String","values","default","class","definePropType","Object","Array","style","alignment","prefixCls","spacer","Number","validator","val","isVNode","isNumber","isString","wrap","Boolean","fill","fillRatio","size","componentSize","isArray","length","every","i","Space","defineComponent","name","props","setup","slots","classes","containerStyle","itemStyle","useSpace","_a","children","renderSlot","key","extractedChildren","forEach","child","loopKey","isFragment","nested","push","createVNode","script","value","PatchFlags","PROPS","STYLE","isValidElementNode","len","reduce","acc","idx","children2","createTextVNode","TEXT","CLASS"],"sources":["../../../../../../packages/components/space/src/space.ts"],"sourcesContent":["import {\n  defineComponent,\n  renderSlot,\n  createVNode,\n  createTextVNode,\n  isVNode,\n} from 'vue'\nimport { isString } from '@vue/shared'\nimport {\n  PatchFlags,\n  isFragment,\n  isValidElementNode,\n} from '@element-plus/utils/vnode'\nimport { isArray, isNumber } from '@element-plus/utils/util'\nimport {\n  buildProps,\n  componentSize,\n  definePropType,\n} from '@element-plus/utils/props'\nimport Item from './item.vue'\nimport { useSpace } from './use-space'\n\nimport type { VNode, StyleValue, ExtractPropTypes, VNodeChild } from 'vue'\nimport type { AlignItemsProperty } from 'csstype'\n\nexport const spaceProps = buildProps({\n  direction: {\n    type: String,\n    values: ['horizontal', 'vertical'],\n    default: 'horizontal',\n  },\n\n  class: {\n    type: definePropType<string | string[] | Record<string, boolean>>([\n      String,\n      Object,\n      Array,\n    ]),\n    default: '',\n  },\n\n  style: {\n    type: definePropType<StyleValue>([String, Array, Object]),\n    default: '',\n  },\n\n  alignment: {\n    type: definePropType<AlignItemsProperty>(String),\n    default: 'center',\n  },\n\n  prefixCls: {\n    type: String,\n  },\n\n  spacer: {\n    type: definePropType<VNodeChild>([Object, String, Number, Array]),\n    default: null,\n    validator: (val: unknown) => isVNode(val) || isNumber(val) || isString(val),\n  },\n\n  wrap: {\n    type: Boolean,\n    default: false,\n  },\n\n  fill: {\n    type: Boolean,\n    default: false,\n  },\n\n  fillRatio: {\n    type: Number,\n    default: 100,\n  },\n\n  size: {\n    type: [String, Array, Number],\n    values: componentSize,\n    validator: (val: unknown): val is [number, number] | number => {\n      return (\n        isNumber(val) ||\n        (isArray(val) && val.length === 2 && val.every((i) => isNumber(i)))\n      )\n    },\n  },\n} as const)\nexport type SpaceProps = ExtractPropTypes<typeof spaceProps>\n\nexport default defineComponent({\n  name: 'ElSpace',\n\n  props: spaceProps,\n\n  setup(props, { slots }) {\n    const { classes, containerStyle, itemStyle } = useSpace(props)\n\n    return () => {\n      const { spacer, prefixCls, direction } = props\n\n      const children = renderSlot(slots, 'default', { key: 0 }, () => [])\n      // retrieve the children out via a simple for loop\n      // the edge case here is that when users uses directives like <v-for>, <v-if>\n      // we need to go one layer deeper\n\n      if ((children.children ?? []).length === 0) return null\n\n      // loop the children, if current children is rendered via `renderList` or `<v-for>`\n      if (isArray(children.children)) {\n        let extractedChildren: VNode[] = []\n        children.children.forEach((child, loopKey) => {\n          if (isFragment(child)) {\n            if (isArray(child.children)) {\n              child.children.forEach((nested, key) => {\n                extractedChildren.push(\n                  createVNode(\n                    Item,\n                    {\n                      style: itemStyle.value,\n                      prefixCls,\n                      key: `nested-${key}`,\n                    },\n                    {\n                      default: () => [nested],\n                    },\n                    PatchFlags.PROPS | PatchFlags.STYLE,\n                    ['style', 'prefixCls']\n                  )\n                )\n              })\n            }\n            // if the current child is valid vnode, then append this current vnode\n            // to item as child node.\n          } else if (isValidElementNode(child)) {\n            extractedChildren.push(\n              createVNode(\n                Item,\n                {\n                  style: itemStyle.value,\n                  prefixCls,\n                  key: `LoopKey${loopKey}`,\n                },\n                {\n                  default: () => [child],\n                },\n                PatchFlags.PROPS | PatchFlags.STYLE,\n                ['style', 'prefixCls']\n              )\n            )\n          }\n        })\n\n        if (spacer) {\n          // track the current rendering index, when encounters the last element\n          // then no need to add a spacer after it.\n          const len = extractedChildren.length - 1\n          extractedChildren = extractedChildren.reduce<VNode[]>(\n            (acc, child, idx) => {\n              const children = [...acc, child]\n              if (idx !== len) {\n                children.push(\n                  createVNode(\n                    'span',\n                    // adding width 100% for vertical alignment,\n                    // when the spacer inherit the width from the\n                    // parent, this span's width was not set, so space\n                    // might disappear\n                    {\n                      style: [\n                        itemStyle.value,\n                        direction === 'vertical' ? 'width: 100%' : null,\n                      ],\n                      key: idx,\n                    },\n                    [\n                      // if spacer is already a valid vnode, then append it to the current\n                      // span element.\n                      // otherwise, treat it as string.\n                      isVNode(spacer)\n                        ? spacer\n                        : createTextVNode(spacer as string, PatchFlags.TEXT),\n                    ],\n                    PatchFlags.STYLE\n                  )\n                )\n              }\n              return children\n            },\n            []\n          )\n        }\n\n        // spacer container.\n        return createVNode(\n          'div',\n          {\n            class: classes.value,\n            style: containerStyle.value,\n          },\n          extractedChildren,\n          PatchFlags.STYLE | PatchFlags.CLASS\n        )\n      }\n\n      return children.children\n    }\n  },\n})\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}