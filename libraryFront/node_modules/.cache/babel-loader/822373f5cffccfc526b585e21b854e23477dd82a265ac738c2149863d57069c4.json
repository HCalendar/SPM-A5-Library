{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { defineComponent, getCurrentInstance, ref, computed, unref, nextTick, onMounted, onUpdated, h, resolveDynamicComponent } from 'vue';\nimport { hasOwn, isString } from '@vue/shared';\nimport { isNumber } from '../../../../utils/util.mjs';\nimport isServer from '../../../../utils/isServer.mjs';\nimport scrollbarWidth from '../../../../utils/scrollbar-width.mjs';\nimport ScrollBar from '../components/scrollbar.mjs';\nimport { useGridWheel } from '../hooks/use-grid-wheel.mjs';\nimport { useCache } from '../hooks/use-cache.mjs';\nimport { virtualizedGridProps } from '../props.mjs';\nimport { isRTL, getRTLOffsetType, getScrollDir } from '../utils.mjs';\nimport { ITEM_RENDER_EVT, SCROLL_EVT, FORWARD, BACKWARD, RTL_OFFSET_POS_DESC, RTL_OFFSET_NAG, AUTO_ALIGNMENT, RTL, RTL_OFFSET_POS_ASC } from '../defaults.mjs';\nconst createGrid = ({\n  name,\n  clearCache,\n  getColumnPosition,\n  getColumnStartIndexForOffset,\n  getColumnStopIndexForStartIndex,\n  getEstimatedTotalHeight,\n  getEstimatedTotalWidth,\n  getColumnOffset,\n  getRowOffset,\n  getRowPosition,\n  getRowStartIndexForOffset,\n  getRowStopIndexForStartIndex,\n  initCache,\n  validateProps\n}) => {\n  return defineComponent({\n    name: name != null ? name : \"ElVirtualList\",\n    props: virtualizedGridProps,\n    emits: [ITEM_RENDER_EVT, SCROLL_EVT],\n    setup(props, {\n      emit,\n      expose,\n      slots\n    }) {\n      validateProps(props);\n      const instance = getCurrentInstance();\n      const cache = ref(initCache(props, instance));\n      const windowRef = ref();\n      const hScrollbar = ref();\n      const vScrollbar = ref();\n      const innerRef = ref(null);\n      const states = ref({\n        isScrolling: false,\n        scrollLeft: isNumber(props.initScrollLeft) ? props.initScrollLeft : 0,\n        scrollTop: isNumber(props.initScrollTop) ? props.initScrollTop : 0,\n        updateRequested: false,\n        xAxisScrollDir: FORWARD,\n        yAxisScrollDir: FORWARD\n      });\n      const getItemStyleCache = useCache();\n      const parsedHeight = computed(() => parseInt(`${props.height}`, 10));\n      const parsedWidth = computed(() => parseInt(`${props.width}`, 10));\n      const columnsToRender = computed(() => {\n        const {\n          totalColumn,\n          totalRow,\n          columnCache\n        } = props;\n        const {\n          isScrolling,\n          xAxisScrollDir,\n          scrollLeft\n        } = unref(states);\n        if (totalColumn === 0 || totalRow === 0) {\n          return [0, 0, 0, 0];\n        }\n        const startIndex = getColumnStartIndexForOffset(props, scrollLeft, unref(cache));\n        const stopIndex = getColumnStopIndexForStartIndex(props, startIndex, scrollLeft, unref(cache));\n        const cacheBackward = !isScrolling || xAxisScrollDir === BACKWARD ? Math.max(1, columnCache) : 1;\n        const cacheForward = !isScrolling || xAxisScrollDir === FORWARD ? Math.max(1, columnCache) : 1;\n        return [Math.max(0, startIndex - cacheBackward), Math.max(0, Math.min(totalColumn - 1, stopIndex + cacheForward)), startIndex, stopIndex];\n      });\n      const rowsToRender = computed(() => {\n        const {\n          totalColumn,\n          totalRow,\n          rowCache\n        } = props;\n        const {\n          isScrolling,\n          yAxisScrollDir,\n          scrollTop\n        } = unref(states);\n        if (totalColumn === 0 || totalRow === 0) {\n          return [0, 0, 0, 0];\n        }\n        const startIndex = getRowStartIndexForOffset(props, scrollTop, unref(cache));\n        const stopIndex = getRowStopIndexForStartIndex(props, startIndex, scrollTop, unref(cache));\n        const cacheBackward = !isScrolling || yAxisScrollDir === BACKWARD ? Math.max(1, rowCache) : 1;\n        const cacheForward = !isScrolling || yAxisScrollDir === FORWARD ? Math.max(1, rowCache) : 1;\n        return [Math.max(0, startIndex - cacheBackward), Math.max(0, Math.min(totalRow - 1, stopIndex + cacheForward)), startIndex, stopIndex];\n      });\n      const estimatedTotalHeight = computed(() => getEstimatedTotalHeight(props, unref(cache)));\n      const estimatedTotalWidth = computed(() => getEstimatedTotalWidth(props, unref(cache)));\n      const windowStyle = computed(() => {\n        var _a;\n        return [{\n          position: \"relative\",\n          overflow: \"hidden\",\n          WebkitOverflowScrolling: \"touch\",\n          willChange: \"transform\"\n        }, {\n          direction: props.direction,\n          height: isNumber(props.height) ? `${props.height}px` : props.height,\n          width: isNumber(props.width) ? `${props.width}px` : props.width\n        }, (_a = props.style) != null ? _a : {}];\n      });\n      const innerStyle = computed(() => {\n        const width = `${unref(estimatedTotalWidth)}px`;\n        const height = `${unref(estimatedTotalHeight)}px`;\n        return {\n          height,\n          pointerEvents: unref(states).isScrolling ? \"none\" : void 0,\n          width\n        };\n      });\n      const emitEvents = () => {\n        const {\n          totalColumn,\n          totalRow\n        } = props;\n        if (totalColumn > 0 && totalRow > 0) {\n          const [columnCacheStart, columnCacheEnd, columnVisibleStart, columnVisibleEnd] = unref(columnsToRender);\n          const [rowCacheStart, rowCacheEnd, rowVisibleStart, rowVisibleEnd] = unref(rowsToRender);\n          emit(ITEM_RENDER_EVT, columnCacheStart, columnCacheEnd, rowCacheStart, rowCacheEnd, columnVisibleStart, columnVisibleEnd, rowVisibleStart, rowVisibleEnd);\n        }\n        const {\n          scrollLeft,\n          scrollTop,\n          updateRequested,\n          xAxisScrollDir,\n          yAxisScrollDir\n        } = unref(states);\n        emit(SCROLL_EVT, xAxisScrollDir, scrollLeft, yAxisScrollDir, scrollTop, updateRequested);\n      };\n      const onScroll = e => {\n        const {\n          clientHeight,\n          clientWidth,\n          scrollHeight,\n          scrollLeft,\n          scrollTop,\n          scrollWidth\n        } = e.currentTarget;\n        const _states = unref(states);\n        if (_states.scrollTop === scrollTop && _states.scrollLeft === scrollLeft) {\n          return;\n        }\n        let _scrollLeft = scrollLeft;\n        if (isRTL(props.direction)) {\n          switch (getRTLOffsetType()) {\n            case RTL_OFFSET_NAG:\n              _scrollLeft = -scrollLeft;\n              break;\n            case RTL_OFFSET_POS_DESC:\n              _scrollLeft = scrollWidth - clientWidth - scrollLeft;\n              break;\n          }\n        }\n        states.value = {\n          ..._states,\n          isScrolling: true,\n          scrollLeft: _scrollLeft,\n          scrollTop: Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight)),\n          updateRequested: false,\n          xAxisScrollDir: getScrollDir(_states.scrollLeft, _scrollLeft),\n          yAxisScrollDir: getScrollDir(_states.scrollTop, scrollTop)\n        };\n        nextTick(resetIsScrolling);\n        emitEvents();\n      };\n      const onVerticalScroll = (distance, totalSteps) => {\n        const height = unref(parsedHeight);\n        const offset = (estimatedTotalHeight.value - height) / totalSteps * distance;\n        scrollTo({\n          scrollTop: Math.min(estimatedTotalHeight.value - height, offset)\n        });\n      };\n      const onHorizontalScroll = (distance, totalSteps) => {\n        const width = unref(parsedWidth);\n        const offset = (estimatedTotalWidth.value - width) / totalSteps * distance;\n        scrollTo({\n          scrollLeft: Math.min(estimatedTotalWidth.value - width, offset)\n        });\n      };\n      const {\n        onWheel\n      } = useGridWheel({\n        atXStartEdge: computed(() => states.value.scrollLeft <= 0),\n        atXEndEdge: computed(() => states.value.scrollLeft >= estimatedTotalWidth.value),\n        atYStartEdge: computed(() => states.value.scrollTop <= 0),\n        atYEndEdge: computed(() => states.value.scrollTop >= estimatedTotalHeight.value)\n      }, (x, y) => {\n        var _a, _b, _c, _d;\n        (_b = (_a = hScrollbar.value) == null ? void 0 : _a.onMouseUp) == null ? void 0 : _b.call(_a);\n        (_d = (_c = hScrollbar.value) == null ? void 0 : _c.onMouseUp) == null ? void 0 : _d.call(_c);\n        const width = unref(parsedWidth);\n        const height = unref(parsedHeight);\n        scrollTo({\n          scrollLeft: Math.min(states.value.scrollLeft + x, estimatedTotalWidth.value - width),\n          scrollTop: Math.min(states.value.scrollTop + y, estimatedTotalHeight.value - height)\n        });\n      });\n      const scrollTo = ({\n        scrollLeft = states.value.scrollLeft,\n        scrollTop = states.value.scrollTop\n      }) => {\n        scrollLeft = Math.max(scrollLeft, 0);\n        scrollTop = Math.max(scrollTop, 0);\n        const _states = unref(states);\n        if (scrollTop === _states.scrollTop && scrollLeft === _states.scrollLeft) {\n          return;\n        }\n        states.value = {\n          ..._states,\n          xAxisScrollDir: getScrollDir(_states.scrollLeft, scrollLeft),\n          yAxisScrollDir: getScrollDir(_states.scrollTop, scrollTop),\n          scrollLeft,\n          scrollTop,\n          updateRequested: true\n        };\n        nextTick(resetIsScrolling);\n      };\n      const scrollToItem = (rowIndex = 0, columnIdx = 0, alignment = AUTO_ALIGNMENT) => {\n        const _states = unref(states);\n        columnIdx = Math.max(0, Math.min(columnIdx, props.totalColumn - 1));\n        rowIndex = Math.max(0, Math.min(rowIndex, props.totalRow - 1));\n        const scrollBarWidth = scrollbarWidth();\n        const _cache = unref(cache);\n        const estimatedHeight = getEstimatedTotalHeight(props, _cache);\n        const estimatedWidth = getEstimatedTotalWidth(props, _cache);\n        scrollTo({\n          scrollLeft: getColumnOffset(props, columnIdx, alignment, _states.scrollLeft, _cache, estimatedWidth > props.width ? scrollBarWidth : 0),\n          scrollTop: getRowOffset(props, rowIndex, alignment, _states.scrollTop, _cache, estimatedHeight > props.height ? scrollBarWidth : 0)\n        });\n      };\n      const getItemStyle = (rowIndex, columnIndex) => {\n        const {\n          columnWidth,\n          direction,\n          rowHeight\n        } = props;\n        const itemStyleCache = getItemStyleCache.value(clearCache && columnWidth, clearCache && rowHeight, clearCache && direction);\n        const key = `${rowIndex},${columnIndex}`;\n        if (hasOwn(itemStyleCache, key)) {\n          return itemStyleCache[key];\n        } else {\n          const [, left] = getColumnPosition(props, columnIndex, unref(cache));\n          const _cache = unref(cache);\n          const rtl = isRTL(direction);\n          const [height, top] = getRowPosition(props, rowIndex, _cache);\n          const [width] = getColumnPosition(props, columnIndex, _cache);\n          itemStyleCache[key] = {\n            position: \"absolute\",\n            left: rtl ? void 0 : `${left}px`,\n            right: rtl ? `${left}px` : void 0,\n            top: `${top}px`,\n            height: `${height}px`,\n            width: `${width}px`\n          };\n          return itemStyleCache[key];\n        }\n      };\n      const resetIsScrolling = () => {\n        states.value.isScrolling = false;\n        nextTick(() => {\n          getItemStyleCache.value(-1, null, null);\n        });\n      };\n      onMounted(() => {\n        if (isServer) return;\n        const {\n          initScrollLeft,\n          initScrollTop\n        } = props;\n        const windowElement = unref(windowRef);\n        if (windowElement) {\n          if (isNumber(initScrollLeft)) {\n            windowElement.scrollLeft = initScrollLeft;\n          }\n          if (isNumber(initScrollTop)) {\n            windowElement.scrollTop = initScrollTop;\n          }\n        }\n        emitEvents();\n      });\n      onUpdated(() => {\n        const {\n          direction\n        } = props;\n        const {\n          scrollLeft,\n          scrollTop,\n          updateRequested\n        } = unref(states);\n        const windowElement = unref(windowRef);\n        if (updateRequested && windowElement) {\n          if (direction === RTL) {\n            switch (getRTLOffsetType()) {\n              case RTL_OFFSET_NAG:\n                {\n                  windowElement.scrollLeft = -scrollLeft;\n                  break;\n                }\n              case RTL_OFFSET_POS_ASC:\n                {\n                  windowElement.scrollLeft = scrollLeft;\n                  break;\n                }\n              default:\n                {\n                  const {\n                    clientWidth,\n                    scrollWidth\n                  } = windowElement;\n                  windowElement.scrollLeft = scrollWidth - clientWidth - scrollLeft;\n                  break;\n                }\n            }\n          } else {\n            windowElement.scrollLeft = Math.max(0, scrollLeft);\n          }\n          windowElement.scrollTop = Math.max(0, scrollTop);\n        }\n      });\n      expose({\n        windowRef,\n        innerRef,\n        getItemStyleCache,\n        scrollTo,\n        scrollToItem,\n        states\n      });\n      const renderScrollbars = () => {\n        const {\n          totalColumn,\n          totalRow\n        } = props;\n        const width = unref(parsedWidth);\n        const height = unref(parsedHeight);\n        const estimatedWidth = unref(estimatedTotalWidth);\n        const estimatedHeight = unref(estimatedTotalHeight);\n        const {\n          scrollLeft,\n          scrollTop\n        } = unref(states);\n        const horizontalScrollbar = h(ScrollBar, {\n          ref: hScrollbar,\n          clientSize: width,\n          layout: \"horizontal\",\n          onScroll: onHorizontalScroll,\n          ratio: width * 100 / estimatedWidth,\n          scrollFrom: scrollLeft / (estimatedWidth - width),\n          total: totalRow,\n          visible: true\n        });\n        const verticalScrollbar = h(ScrollBar, {\n          ref: vScrollbar,\n          clientSize: height,\n          layout: \"vertical\",\n          onScroll: onVerticalScroll,\n          ratio: height * 100 / estimatedHeight,\n          scrollFrom: scrollTop / (estimatedHeight - height),\n          total: totalColumn,\n          visible: true\n        });\n        return {\n          horizontalScrollbar,\n          verticalScrollbar\n        };\n      };\n      const renderItems = () => {\n        var _a;\n        const [columnStart, columnEnd] = unref(columnsToRender);\n        const [rowStart, rowEnd] = unref(rowsToRender);\n        const {\n          data,\n          totalColumn,\n          totalRow,\n          useIsScrolling\n        } = props;\n        const children = [];\n        if (totalRow > 0 && totalColumn > 0) {\n          for (let row = rowStart; row <= rowEnd; row++) {\n            for (let column = columnStart; column <= columnEnd; column++) {\n              children.push((_a = slots.default) == null ? void 0 : _a.call(slots, {\n                columnIndex: column,\n                data,\n                key: column,\n                isScrolling: useIsScrolling ? unref(states).isScrolling : void 0,\n                style: getItemStyle(row, column),\n                rowIndex: row\n              }));\n            }\n          }\n        }\n        return children;\n      };\n      const renderInner = () => {\n        const Inner = resolveDynamicComponent(props.innerElement);\n        const children = renderItems();\n        return [h(Inner, {\n          style: unref(innerStyle),\n          ref: innerRef\n        }, !isString(Inner) ? {\n          default: () => children\n        } : children)];\n      };\n      const renderWindow = () => {\n        const Container = resolveDynamicComponent(props.containerElement);\n        const {\n          horizontalScrollbar,\n          verticalScrollbar\n        } = renderScrollbars();\n        const Inner = renderInner();\n        return h(\"div\", {\n          key: 0,\n          class: \"el-vg__wrapper\"\n        }, [h(Container, {\n          class: props.className,\n          style: unref(windowStyle),\n          onScroll,\n          onWheel,\n          ref: windowRef\n        }, !isString(Container) ? {\n          default: () => Inner\n        } : Inner), horizontalScrollbar, verticalScrollbar]);\n      };\n      return renderWindow;\n    }\n  });\n};\nexport { createGrid as default };","map":{"version":3,"names":["createGrid","name","clearCache","getColumnPosition","getColumnStartIndexForOffset","getColumnStopIndexForStartIndex","getEstimatedTotalHeight","getEstimatedTotalWidth","getColumnOffset","getRowOffset","getRowPosition","getRowStartIndexForOffset","getRowStopIndexForStartIndex","initCache","validateProps","defineComponent","props","virtualizedGridProps","emits","ITEM_RENDER_EVT","SCROLL_EVT","setup","emit","expose","slots","instance","getCurrentInstance","cache","ref","windowRef","hScrollbar","vScrollbar","innerRef","states","isScrolling","scrollLeft","isNumber","initScrollLeft","scrollTop","initScrollTop","updateRequested","xAxisScrollDir","FORWARD","yAxisScrollDir","getItemStyleCache","useCache","parsedHeight","computed","parseInt","height","parsedWidth","width","columnsToRender","totalColumn","totalRow","columnCache","unref","startIndex","stopIndex","cacheBackward","BACKWARD","Math","max","cacheForward","min","rowsToRender","rowCache","estimatedTotalHeight","estimatedTotalWidth","windowStyle","_a","position","overflow","WebkitOverflowScrolling","willChange","direction","style","innerStyle","pointerEvents","emitEvents","columnCacheStart","columnCacheEnd","columnVisibleStart","columnVisibleEnd","rowCacheStart","rowCacheEnd","rowVisibleStart","rowVisibleEnd","onScroll","e","clientHeight","clientWidth","scrollHeight","scrollWidth","currentTarget","_states","_scrollLeft","isRTL","getRTLOffsetType","RTL_OFFSET_NAG","RTL_OFFSET_POS_DESC","value","getScrollDir","nextTick","resetIsScrolling","onVerticalScroll","distance","totalSteps","offset","scrollTo","onHorizontalScroll","onWheel","useGridWheel","atXStartEdge","atXEndEdge","atYStartEdge","atYEndEdge","x","y","_b","_c","_d","onMouseUp","call","scrollToItem","rowIndex","columnIdx","alignment","AUTO_ALIGNMENT","scrollBarWidth","scrollbarWidth","_cache","estimatedHeight","estimatedWidth","getItemStyle","columnIndex","columnWidth","rowHeight","itemStyleCache","key","hasOwn","left","rtl","top","right","onMounted","isServer","windowElement","onUpdated","RTL","RTL_OFFSET_POS_ASC","renderScrollbars","horizontalScrollbar","h","ScrollBar","clientSize","layout","ratio","scrollFrom","total","visible","verticalScrollbar","renderItems","columnStart","columnEnd","rowStart","rowEnd","data","useIsScrolling","children","row","column","push","default","renderInner","Inner","resolveDynamicComponent","innerElement","isString","renderWindow","Container","containerElement","class","className"],"sources":["../../../../../../../packages/components/virtual-list/src/builders/build-grid.ts"],"sourcesContent":["import {\n  computed,\n  defineComponent,\n  getCurrentInstance,\n  ref,\n  nextTick,\n  onMounted,\n  onUpdated,\n  resolveDynamicComponent,\n  h,\n  unref,\n} from 'vue'\nimport { hasOwn } from '@vue/shared'\n\nimport { isNumber, isString } from '@element-plus/utils/util'\nimport isServer from '@element-plus/utils/isServer'\nimport getScrollBarWidth from '@element-plus/utils/scrollbar-width'\n\nimport Scrollbar from '../components/scrollbar'\nimport { useGridWheel } from '../hooks/use-grid-wheel'\nimport { useCache } from '../hooks/use-cache'\nimport { virtualizedGridProps } from '../props'\nimport { getScrollDir, getRTLOffsetType, isRTL } from '../utils'\nimport {\n  AUTO_ALIGNMENT,\n  BACKWARD,\n  FORWARD,\n  RTL,\n  ITEM_RENDER_EVT,\n  SCROLL_EVT,\n  RTL_OFFSET_NAG,\n  RTL_OFFSET_POS_DESC,\n  RTL_OFFSET_POS_ASC,\n} from '../defaults'\n\nimport type { CSSProperties, VNode, VNodeChild } from 'vue'\nimport type { StyleValue } from '@element-plus/utils/types'\nimport type { GridConstructorProps, Alignment, ScrollbarExpose } from '../types'\nimport type { VirtualizedGridProps } from '../props'\n\nconst createGrid = ({\n  name,\n  clearCache,\n  getColumnPosition,\n  getColumnStartIndexForOffset,\n  getColumnStopIndexForStartIndex,\n  getEstimatedTotalHeight,\n  getEstimatedTotalWidth,\n  getColumnOffset,\n  getRowOffset,\n  getRowPosition,\n  getRowStartIndexForOffset,\n  getRowStopIndexForStartIndex,\n\n  initCache,\n  validateProps,\n}: GridConstructorProps<VirtualizedGridProps>) => {\n  return defineComponent({\n    name: name ?? 'ElVirtualList',\n    props: virtualizedGridProps,\n    emits: [ITEM_RENDER_EVT, SCROLL_EVT],\n    setup(props, { emit, expose, slots }) {\n      validateProps(props)\n      const instance = getCurrentInstance()!\n      const cache = ref(initCache(props, instance))\n      // refs\n      // here windowRef and innerRef can be type of HTMLElement\n      // or user defined component type, depends on the type passed\n      // by user\n      const windowRef = ref<HTMLElement>()\n      const hScrollbar = ref<ScrollbarExpose>()\n      const vScrollbar = ref<ScrollbarExpose>()\n      // innerRef is the actual container element which contains all the elements\n      const innerRef = ref(null)\n      const states = ref({\n        isScrolling: false,\n        scrollLeft: isNumber(props.initScrollLeft) ? props.initScrollLeft : 0,\n        scrollTop: isNumber(props.initScrollTop) ? props.initScrollTop : 0,\n        updateRequested: false,\n        xAxisScrollDir: FORWARD,\n        yAxisScrollDir: FORWARD,\n      })\n\n      const getItemStyleCache = useCache()\n\n      // computed\n      const parsedHeight = computed(() => parseInt(`${props.height}`, 10))\n      const parsedWidth = computed(() => parseInt(`${props.width}`, 10))\n      const columnsToRender = computed(() => {\n        const { totalColumn, totalRow, columnCache } = props\n        const { isScrolling, xAxisScrollDir, scrollLeft } = unref(states)\n\n        if (totalColumn === 0 || totalRow === 0) {\n          return [0, 0, 0, 0]\n        }\n\n        const startIndex = getColumnStartIndexForOffset(\n          props,\n          scrollLeft,\n          unref(cache)\n        )\n        const stopIndex = getColumnStopIndexForStartIndex(\n          props,\n          startIndex,\n          scrollLeft,\n          unref(cache)\n        )\n\n        const cacheBackward =\n          !isScrolling || xAxisScrollDir === BACKWARD\n            ? Math.max(1, columnCache)\n            : 1\n        const cacheForward =\n          !isScrolling || xAxisScrollDir === FORWARD\n            ? Math.max(1, columnCache)\n            : 1\n\n        return [\n          Math.max(0, startIndex - cacheBackward),\n          Math.max(0, Math.min(totalColumn! - 1, stopIndex + cacheForward)),\n          startIndex,\n          stopIndex,\n        ]\n      })\n\n      const rowsToRender = computed(() => {\n        const { totalColumn, totalRow, rowCache } = props\n        const { isScrolling, yAxisScrollDir, scrollTop } = unref(states)\n\n        if (totalColumn === 0 || totalRow === 0) {\n          return [0, 0, 0, 0]\n        }\n\n        const startIndex = getRowStartIndexForOffset(\n          props,\n          scrollTop,\n          unref(cache)\n        )\n        const stopIndex = getRowStopIndexForStartIndex(\n          props,\n          startIndex,\n          scrollTop,\n          unref(cache)\n        )\n\n        const cacheBackward =\n          !isScrolling || yAxisScrollDir === BACKWARD\n            ? Math.max(1, rowCache)\n            : 1\n        const cacheForward =\n          !isScrolling || yAxisScrollDir === FORWARD ? Math.max(1, rowCache) : 1\n\n        return [\n          Math.max(0, startIndex - cacheBackward),\n          Math.max(0, Math.min(totalRow! - 1, stopIndex + cacheForward)),\n          startIndex,\n          stopIndex,\n        ]\n      })\n\n      const estimatedTotalHeight = computed(() =>\n        getEstimatedTotalHeight(props, unref(cache))\n      )\n      const estimatedTotalWidth = computed(() =>\n        getEstimatedTotalWidth(props, unref(cache))\n      )\n\n      const windowStyle = computed<StyleValue>(() => [\n        {\n          position: 'relative',\n          overflow: 'hidden',\n          WebkitOverflowScrolling: 'touch',\n          willChange: 'transform',\n        },\n        {\n          direction: props.direction,\n          height: isNumber(props.height) ? `${props.height}px` : props.height,\n          width: isNumber(props.width) ? `${props.width}px` : props.width,\n        },\n        props.style ?? {},\n      ])\n\n      const innerStyle = computed(() => {\n        const width = `${unref(estimatedTotalWidth)}px`\n        const height = `${unref(estimatedTotalHeight)}px`\n\n        return {\n          height,\n          pointerEvents: unref(states).isScrolling ? 'none' : undefined,\n          width,\n        }\n      })\n\n      // methods\n      const emitEvents = () => {\n        const { totalColumn, totalRow } = props\n\n        if (totalColumn! > 0 && totalRow! > 0) {\n          const [\n            columnCacheStart,\n            columnCacheEnd,\n            columnVisibleStart,\n            columnVisibleEnd,\n          ] = unref(columnsToRender)\n          const [rowCacheStart, rowCacheEnd, rowVisibleStart, rowVisibleEnd] =\n            unref(rowsToRender)\n          // emit the render item event with\n          // [xAxisInvisibleStart, xAxisInvisibleEnd, xAxisVisibleStart, xAxisVisibleEnd]\n          // [yAxisInvisibleStart, yAxisInvisibleEnd, yAxisVisibleStart, yAxisVisibleEnd]\n          emit(\n            ITEM_RENDER_EVT,\n            columnCacheStart,\n            columnCacheEnd,\n            rowCacheStart,\n            rowCacheEnd,\n            columnVisibleStart,\n            columnVisibleEnd,\n            rowVisibleStart,\n            rowVisibleEnd\n          )\n        }\n\n        const {\n          scrollLeft,\n          scrollTop,\n          updateRequested,\n          xAxisScrollDir,\n          yAxisScrollDir,\n        } = unref(states)\n        emit(\n          SCROLL_EVT,\n          xAxisScrollDir,\n          scrollLeft,\n          yAxisScrollDir,\n          scrollTop,\n          updateRequested\n        )\n      }\n\n      const onScroll = (e: Event) => {\n        const {\n          clientHeight,\n          clientWidth,\n          scrollHeight,\n          scrollLeft,\n          scrollTop,\n          scrollWidth,\n        } = e.currentTarget as HTMLElement\n\n        const _states = unref(states)\n        if (\n          _states.scrollTop === scrollTop &&\n          _states.scrollLeft === scrollLeft\n        ) {\n          return\n        }\n\n        let _scrollLeft = scrollLeft\n\n        if (isRTL(props.direction)) {\n          switch (getRTLOffsetType()) {\n            case RTL_OFFSET_NAG:\n              _scrollLeft = -scrollLeft\n              break\n            case RTL_OFFSET_POS_DESC:\n              _scrollLeft = scrollWidth - clientWidth - scrollLeft\n              break\n          }\n        }\n\n        states.value = {\n          ..._states,\n          isScrolling: true,\n          scrollLeft: _scrollLeft,\n          scrollTop: Math.max(\n            0,\n            Math.min(scrollTop, scrollHeight - clientHeight)\n          ),\n          updateRequested: false,\n          xAxisScrollDir: getScrollDir(_states.scrollLeft, _scrollLeft),\n          yAxisScrollDir: getScrollDir(_states.scrollTop, scrollTop),\n        }\n\n        nextTick(resetIsScrolling)\n\n        emitEvents()\n      }\n\n      const onVerticalScroll = (distance: number, totalSteps: number) => {\n        const height = unref(parsedHeight)\n        const offset =\n          ((estimatedTotalHeight.value - height) / totalSteps) * distance\n        scrollTo({\n          scrollTop: Math.min(estimatedTotalHeight.value - height, offset),\n        })\n      }\n\n      const onHorizontalScroll = (distance: number, totalSteps: number) => {\n        const width = unref(parsedWidth)\n        const offset =\n          ((estimatedTotalWidth.value - width) / totalSteps) * distance\n        scrollTo({\n          scrollLeft: Math.min(estimatedTotalWidth.value - width, offset),\n        })\n      }\n\n      const { onWheel } = useGridWheel(\n        {\n          atXStartEdge: computed(() => states.value.scrollLeft <= 0),\n          atXEndEdge: computed(\n            () => states.value.scrollLeft >= estimatedTotalWidth.value\n          ),\n          atYStartEdge: computed(() => states.value.scrollTop <= 0),\n          atYEndEdge: computed(\n            () => states.value.scrollTop >= estimatedTotalHeight.value\n          ),\n        },\n        (x: number, y: number) => {\n          hScrollbar.value?.onMouseUp?.()\n          hScrollbar.value?.onMouseUp?.()\n          const width = unref(parsedWidth)\n          const height = unref(parsedHeight)\n          scrollTo({\n            scrollLeft: Math.min(\n              states.value.scrollLeft + x,\n              estimatedTotalWidth.value - width\n            ),\n            scrollTop: Math.min(\n              states.value.scrollTop + y,\n              estimatedTotalHeight.value - height\n            ),\n          })\n        }\n      )\n\n      const scrollTo = ({\n        scrollLeft = states.value.scrollLeft,\n        scrollTop = states.value.scrollTop,\n      }) => {\n        scrollLeft = Math.max(scrollLeft, 0)\n        scrollTop = Math.max(scrollTop, 0)\n        const _states = unref(states)\n        if (\n          scrollTop === _states.scrollTop &&\n          scrollLeft === _states.scrollLeft\n        ) {\n          return\n        }\n\n        states.value = {\n          ..._states,\n          xAxisScrollDir: getScrollDir(_states.scrollLeft, scrollLeft),\n          yAxisScrollDir: getScrollDir(_states.scrollTop, scrollTop),\n          scrollLeft,\n          scrollTop,\n          updateRequested: true,\n        }\n\n        nextTick(resetIsScrolling)\n      }\n\n      const scrollToItem = (\n        rowIndex = 0,\n        columnIdx = 0,\n        alignment: Alignment = AUTO_ALIGNMENT\n      ) => {\n        const _states = unref(states)\n        columnIdx = Math.max(0, Math.min(columnIdx, props.totalColumn! - 1))\n        rowIndex = Math.max(0, Math.min(rowIndex, props.totalRow! - 1))\n        const scrollBarWidth = getScrollBarWidth()\n\n        const _cache = unref(cache)\n        const estimatedHeight = getEstimatedTotalHeight(props, _cache)\n        const estimatedWidth = getEstimatedTotalWidth(props, _cache)\n\n        scrollTo({\n          scrollLeft: getColumnOffset(\n            props,\n            columnIdx,\n            alignment,\n            _states.scrollLeft,\n            _cache,\n            estimatedWidth > props.width! ? scrollBarWidth : 0\n          ),\n          scrollTop: getRowOffset(\n            props,\n            rowIndex,\n            alignment,\n            _states.scrollTop,\n            _cache,\n            estimatedHeight > props.height! ? scrollBarWidth : 0\n          ),\n        })\n      }\n\n      const getItemStyle = (\n        rowIndex: number,\n        columnIndex: number\n      ): CSSProperties => {\n        const { columnWidth, direction, rowHeight } = props\n\n        const itemStyleCache = getItemStyleCache.value(\n          clearCache && columnWidth,\n          clearCache && rowHeight,\n          clearCache && direction\n        )\n        // since there was no need to introduce an nested array into cache object\n        // we use row,column to construct the key for indexing the map.\n        const key = `${rowIndex},${columnIndex}`\n\n        if (hasOwn(itemStyleCache, key)) {\n          return itemStyleCache[key]\n        } else {\n          const [, left] = getColumnPosition(props, columnIndex, unref(cache))\n          const _cache = unref(cache)\n\n          const rtl = isRTL(direction)\n          const [height, top] = getRowPosition(props, rowIndex, _cache)\n          const [width] = getColumnPosition(props, columnIndex, _cache)\n\n          itemStyleCache[key] = {\n            position: 'absolute',\n            left: rtl ? undefined : `${left}px`,\n            right: rtl ? `${left}px` : undefined,\n            top: `${top}px`,\n            height: `${height}px`,\n            width: `${width}px`,\n          }\n\n          return itemStyleCache[key]\n        }\n      }\n\n      // TODO: debounce setting is scrolling.\n\n      const resetIsScrolling = () => {\n        // timer = null\n\n        states.value.isScrolling = false\n        nextTick(() => {\n          getItemStyleCache.value(-1, null, null)\n        })\n      }\n\n      // life cycles\n      onMounted(() => {\n        // for SSR\n        if (isServer) return\n        const { initScrollLeft, initScrollTop } = props\n        const windowElement = unref(windowRef)\n        if (windowElement) {\n          if (isNumber(initScrollLeft)) {\n            windowElement.scrollLeft = initScrollLeft\n          }\n          if (isNumber(initScrollTop)) {\n            windowElement.scrollTop = initScrollTop\n          }\n        }\n        emitEvents()\n      })\n\n      onUpdated(() => {\n        const { direction } = props\n        const { scrollLeft, scrollTop, updateRequested } = unref(states)\n\n        const windowElement = unref(windowRef)\n\n        if (updateRequested && windowElement) {\n          if (direction === RTL) {\n            switch (getRTLOffsetType()) {\n              case RTL_OFFSET_NAG: {\n                windowElement.scrollLeft = -scrollLeft\n                break\n              }\n              case RTL_OFFSET_POS_ASC: {\n                windowElement.scrollLeft = scrollLeft\n                break\n              }\n              default: {\n                const { clientWidth, scrollWidth } = windowElement\n                windowElement.scrollLeft =\n                  scrollWidth - clientWidth - scrollLeft\n                break\n              }\n            }\n          } else {\n            windowElement.scrollLeft = Math.max(0, scrollLeft)\n          }\n\n          windowElement.scrollTop = Math.max(0, scrollTop)\n        }\n      })\n\n      expose({\n        windowRef,\n        innerRef,\n        getItemStyleCache,\n        scrollTo,\n        scrollToItem,\n        states,\n      })\n\n      // rendering part\n\n      const renderScrollbars = () => {\n        const { totalColumn, totalRow } = props\n\n        const width = unref(parsedWidth)\n        const height = unref(parsedHeight)\n        const estimatedWidth = unref(estimatedTotalWidth)\n        const estimatedHeight = unref(estimatedTotalHeight)\n        const { scrollLeft, scrollTop } = unref(states)\n        const horizontalScrollbar = h(Scrollbar, {\n          ref: hScrollbar,\n          clientSize: width,\n          layout: 'horizontal',\n          onScroll: onHorizontalScroll,\n          ratio: (width * 100) / estimatedWidth,\n          scrollFrom: scrollLeft / (estimatedWidth - width),\n          total: totalRow,\n          visible: true,\n        })\n\n        const verticalScrollbar = h(Scrollbar, {\n          ref: vScrollbar,\n          clientSize: height,\n          layout: 'vertical',\n          onScroll: onVerticalScroll,\n          ratio: (height * 100) / estimatedHeight,\n          scrollFrom: scrollTop / (estimatedHeight - height),\n          total: totalColumn,\n          visible: true,\n        })\n\n        return {\n          horizontalScrollbar,\n          verticalScrollbar,\n        }\n      }\n\n      const renderItems = () => {\n        const [columnStart, columnEnd] = unref(columnsToRender)\n        const [rowStart, rowEnd] = unref(rowsToRender)\n        const { data, totalColumn, totalRow, useIsScrolling } = props\n        const children: VNodeChild[] = []\n        if (totalRow > 0 && totalColumn > 0) {\n          for (let row = rowStart; row <= rowEnd; row++) {\n            for (let column = columnStart; column <= columnEnd; column++) {\n              children.push(\n                slots.default?.({\n                  columnIndex: column,\n                  data,\n                  key: column,\n                  isScrolling: useIsScrolling\n                    ? unref(states).isScrolling\n                    : undefined,\n                  style: getItemStyle(row, column),\n                  rowIndex: row,\n                })\n              )\n            }\n          }\n        }\n        return children\n      }\n\n      const renderInner = () => {\n        const Inner = resolveDynamicComponent(props.innerElement) as VNode\n        const children = renderItems()\n        return [\n          h(\n            Inner,\n            {\n              style: unref(innerStyle),\n              ref: innerRef,\n            },\n            !isString(Inner)\n              ? {\n                  default: () => children,\n                }\n              : children\n          ),\n        ]\n      }\n\n      const renderWindow = () => {\n        const Container = resolveDynamicComponent(\n          props.containerElement\n        ) as VNode\n        const { horizontalScrollbar, verticalScrollbar } = renderScrollbars()\n        const Inner = renderInner()\n\n        return h(\n          'div',\n          {\n            key: 0,\n            class: 'el-vg__wrapper',\n          },\n          [\n            h(\n              Container,\n              {\n                class: props.className,\n                style: unref(windowStyle),\n                onScroll,\n                onWheel,\n                ref: windowRef,\n              },\n              !isString(Container) ? { default: () => Inner } : Inner\n            ),\n            horizontalScrollbar,\n            verticalScrollbar,\n          ]\n        )\n      }\n\n      return renderWindow\n    },\n  })\n}\nexport default createGrid\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}